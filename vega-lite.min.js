"use strict";const _excluded = ["order", "detail", "tooltip"],_excluded2 = ["row", "column", "facet"],_excluded3 = ["x", "y", "x2", "y2", "xOffset", "yOffset", "latitude", "longitude", "latitude2", "longitude2", "theta", "theta2", "radius", "radius2"],_excluded4 = ["text", "tooltip", "href", "url", "description", "detail", "key", "order"],_excluded5 = ["geoshape"],_excluded6 = ["anchor", "frame", "offset", "orient", "angle", "limit", "color", "subtitleColor", "subtitleFont", "subtitleFontSize", "subtitleFontStyle", "subtitleFontWeight", "subtitleLineHeight", "subtitlePadding"],_excluded7 = ["expr"],_excluded8 = ["expr"],_excluded9 = ["expr"],_excluded10 = ["type", "domain", "range", "rangeMax", "rangeMin", "scheme"],_excluded11 = ["utc"],_excluded12 = ["format", "formatType"],_excluded13 = ["format", "formatType"],_excluded14 = ["orient"],_excluded15 = ["field", "aggregate", "bin", "timeUnit"],_excluded16 = ["aggregate"],_excluded17 = ["mark", "encoding", "params", "projection"],_excluded18 = ["tooltip"],_excluded19 = ["color", "size"],_excluded20 = ["tooltip"],_excluded21 = ["mark", "encoding", "params", "projection"],_excluded22 = ["expr", "bind"],_excluded23 = ["color", "font", "fontSize", "selection"],_excluded24 = ["concat"],_excluded25 = ["point", "line"],_excluded26 = ["params", "projection", "mark", "name", "encoding"],_excluded27 = ["condition"],_excluded28 = ["transform"],_excluded29 = ["selection"],_excluded30 = ["selection"],_excluded31 = ["selection", "param", "test"],_excluded32 = ["selection", "param", "test"],_excluded33 = ["selection"],_excluded34 = ["repeat", "spec"],_excluded35 = ["repeat", "spec", "data"],_excluded36 = ["row", "column", "facet"],_excluded37 = ["mark", "width", "projection", "height", "view", "params", "encoding"],_excluded38 = ["align", "center", "spacing", "columns"],_excluded39 = ["align", "center", "spacing", "columns"],_excluded40 = ["parentEncoding", "parentProjection"],_excluded41 = ["encoding", "projection"],_excluded42 = ["selection"],_excluded43 = ["init", "bind", "empty"],_excluded44 = ["signals", "hasLegend", "index"],_excluded45 = ["timeUnit"],_excluded46 = ["unit", "utc"],_excluded47 = ["fill", "fillOpacity", "cursor"],_excluded48 = ["disable", "orient", "scale", "labelExpr", "title", "zindex"],_excluded49 = ["condition"],_excluded50 = ["test"],_excluded51 = ["test"],_excluded52 = ["disable", "labelExpr", "selections"],_excluded53 = ["extent"],_excluded54 = ["sort"],_excluded55 = ["name", "type", "selectionExtent", "domains", "range", "reverse"],_excluded56 = ["style"],_excluded57 = ["spacing"],_excluded58 = ["encoding"],_excluded59 = ["density"],_excluded60 = ["loess", "on"],_excluded61 = ["quantile"],_excluded62 = ["regression", "on"],_excluded63 = ["params"];function _objectWithoutProperties(source, excluded) {if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];}}return target;}function _objectWithoutPropertiesLoose(source, excluded) {if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];}return target;}function ownKeys(e, r) {var t = Object.keys(e);if (Object.getOwnPropertySymbols) {var o = Object.getOwnPropertySymbols(e);r && (o = o.filter(function (r) {return Object.getOwnPropertyDescriptor(e, r).enumerable;})), t.push.apply(t, o);}return t;}function _objectSpread(e) {for (var r = 1; r < arguments.length; r++) {var t = null != arguments[r] ? arguments[r] : {};r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {_defineProperty(e, r, t[r]);}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));});}return e;}function _defineProperty(obj, key, value) {key = _toPropertyKey(key);if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _toPropertyKey(arg) {var key = _toPrimitive(arg, "string");return typeof key === "symbol" ? key : String(key);}function _toPrimitive(input, hint) {if (typeof input !== "object" || input === null) return input;var prim = input[Symbol.toPrimitive];if (prim !== undefined) {var res = prim.call(input, hint || "default");if (typeof res !== "object") return res;throw new TypeError("@@toPrimitive must return a primitive value.");}return (hint === "string" ? String : Number)(input);}!function (e, t) {"object" == typeof exports && "undefined" != typeof module ? t(exports, require("vega")) : "function" == typeof define && define.amd ? define(["exports", "vega"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).vegaLite = {}, e.vega);}(void 0, function (e, t) {"use strict";var n = "5.16.3";const i = "object" == typeof self ? self : globalThis,r = (e) => ((e, t) => {const n = (t, n) => (e.set(n, t), t),r = (o) => {if (e.has(o)) return e.get(o);const [a, s] = t[o];switch (a) {case 0:case -1:return n(s, o);case 1:{const e = n([], o);for (const t of s) e.push(r(t));return e;}case 2:{const e = n({}, o);for (const [t, n] of s) e[r(t)] = r(n);return e;}case 3:return n(new Date(s), o);case 4:{const { source: e, flags: t } = s;return n(new RegExp(e, t), o);}case 5:{const e = n(new Map(), o);for (const [t, n] of s) e.set(r(t), r(n));return e;}case 6:{const e = n(new Set(), o);for (const t of s) e.add(r(t));return e;}case 7:{const { name: e, message: t } = s;return n(new i[e](t), o);}case 8:return n(BigInt(s), o);case "BigInt":return n(Object(BigInt(s)), o);}return n(new i[a](s), o);};return r;})(new Map(), e)(0),o = "",{ toString: a } = {},{ keys: s } = Object,l = (e) => {const t = typeof e;if ("object" !== t || !e) return [0, t];const n = a.call(e).slice(8, -1);switch (n) {case "Array":return [1, o];case "Object":return [2, o];case "Date":return [3, o];case "RegExp":return [4, o];case "Map":return [5, o];case "Set":return [6, o];}return n.includes("Array") ? [1, n] : n.includes("Error") ? [7, n] : [2, n];},c = (e) => {let [t, n] = e;return 0 === t && ("function" === n || "symbol" === n);},u = function u(e) {let { json: t, lossy: n } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};const i = [];return ((e, t, n, i) => {const r = (e, t) => {const r = i.push(e) - 1;return n.set(t, r), r;},o = (i) => {if (n.has(i)) return n.get(i);let [a, u] = l(i);switch (a) {case 0:{let t = i;switch (u) {case "bigint":a = 8, t = i.toString();break;case "function":case "symbol":if (e) throw new TypeError("unable to serialize " + u);t = null;break;case "undefined":return r([-1], i);}return r([a, t], i);}case 1:{if (u) return r([u, [...i]], i);const e = [],t = r([a, e], i);for (const t of i) e.push(o(t));return t;}case 2:{if (u) switch (u) {case "BigInt":return r([u, i.toString()], i);case "Boolean":case "Number":case "String":return r([u, i.valueOf()], i);}if (t && "toJSON" in i) return o(i.toJSON());const n = [],f = r([a, n], i);for (const t of s(i)) !e && c(l(i[t])) || n.push([o(t), o(i[t])]);return f;}case 3:return r([a, i.toISOString()], i);case 4:{const { source: e, flags: t } = i;return r([a, { source: e, flags: t }], i);}case 5:{const t = [],n = r([a, t], i);for (const [n, r] of i) (e || !c(l(n)) && !c(l(r))) && t.push([o(n), o(r)]);return n;}case 6:{const t = [],n = r([a, t], i);for (const n of i) !e && c(l(n)) || t.push(o(n));return n;}}const { message: f } = i;return r([a, { name: u, message: f }], i);};return o;})(!(t || n), !!t, new Map(), i)(e), i;};var f = "function" == typeof structuredClone ? (e, t) => t && ("json" in t || "lossy" in t) ? r(u(e, t)) : structuredClone(e) : (e, t) => r(u(e, t));function d(e) {return !!e.or;}function m(e) {return !!e.and;}function p(e) {return !!e.not;}function g(e, t) {if (p(e)) g(e.not, t);else if (m(e)) for (const n of e.and) g(n, t);else if (d(e)) for (const n of e.or) g(n, t);else t(e);}function h(e, t) {return p(e) ? { not: h(e.not, t) } : m(e) ? { and: e.and.map((e) => h(e, t)) } : d(e) ? { or: e.or.map((e) => h(e, t)) } : t(e);}const y = f;function v(e) {throw new Error(e);}function b(e, n) {const i = {};for (const r of n) t.hasOwnProperty(e, r) && (i[r] = e[r]);return i;}function x(e, t) {const n = _objectSpread({}, e);for (const e of t) delete n[e];return n;}function $(e) {if (t.isNumber(e)) return e;const n = t.isString(e) ? e : re(e);if (n.length < 250) return n;let i = 0;for (let e = 0; e < n.length; e++) {i = (i << 5) - i + n.charCodeAt(e), i &= i;}return i;}function w(e) {return !1 === e || null === e;}function k(e, t) {return e.includes(t);}function S(e, t) {let n = 0;for (const [i, r] of e.entries()) if (t(r, i, n++)) return !0;return !1;}function D(e, t) {let n = 0;for (const [i, r] of e.entries()) if (!t(r, i, n++)) return !1;return !0;}function F(e) {for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];for (const t of n) z(e, t !== null && t !== void 0 ? t : {});return e;}function z(e, n) {for (const i of j(n)) t.writeConfig(e, i, n[i], !0);}function O(e, t) {const n = [],i = {};let r;for (const o of e) r = t(o), r in i || (i[r] = 1, n.push(o));return n;}function _(e, t) {if (e.size !== t.size) return !1;for (const n of e) if (!t.has(n)) return !1;return !0;}function N(e, t) {for (const n of e) if (t.has(n)) return !0;return !1;}function C(e) {const n = new Set();for (const i of e) {const e = t.splitAccessPath(i).map((e, t) => 0 === t ? e : "[".concat(e, "]")),r = e.map((t, n) => e.slice(0, n + 1).join(""));for (const e of r) n.add(e);}return n;}function P(e, t) {return void 0 === e || void 0 === t || N(C(e), C(t));}function A(e) {return 0 === j(e).length;}Set.prototype.toJSON = function () {return "Set(".concat([...this].map((e) => re(e)).join(","), ")");};const j = Object.keys,T = Object.values,E = Object.entries;function M(e) {return !0 === e || !1 === e;}function L(e) {const t = e.replace(/\W/g, "_");return (e.match(/^\d+/) ? "_" : "") + t;}function q(e, t) {return p(e) ? "!(".concat(q(e.not, t), ")") : m(e) ? "(".concat(e.and.map((e) => q(e, t)).join(") && ("), ")") : d(e) ? "(".concat(e.or.map((e) => q(e, t)).join(") || ("), ")") : t(e);}function U(e, t) {if (0 === t.length) return !0;const n = t.shift();return n in e && U(e[n], t) && delete e[n], A(e);}function R(e) {return e.charAt(0).toUpperCase() + e.substr(1);}function W(e) {let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "datum";const i = t.splitAccessPath(e),r = [];for (let e = 1; e <= i.length; e++) {const o = "[".concat(i.slice(0, e).map(t.stringValue).join("]["), "]");r.push("".concat(n).concat(o));}return r.join(" && ");}function B(e) {return "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "datum", "[").concat(t.stringValue(t.splitAccessPath(e).join(".")), "]");}function I(e) {return e.replace(/(\[|\]|\.|'|")/g, "\\$1");}function H(e) {return "".concat(t.splitAccessPath(e).map(I).join("\\."));}function V(e, t, n) {return e.replace(new RegExp(t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), n);}function G(e) {return "".concat(t.splitAccessPath(e).join("."));}function Y(e) {return e ? t.splitAccessPath(e).length : 0;}function X() {for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];for (const e of t) if (void 0 !== e) return e;}let J = 42;function Q(e) {const t = ++J;return e ? String(e) + t : t;}function K(e) {return Z(e) ? e : "__".concat(e);}function Z(e) {return e.startsWith("__");}function ee(e) {if (void 0 !== e) return (e % 360 + 360) % 360;}function te(e) {return !!t.isNumber(e) || !isNaN(e) && !isNaN(parseFloat(e));}const ne = Object.getPrototypeOf(f({}));function ie(e, t) {if (e === t) return !0;if (e && t && "object" == typeof e && "object" == typeof t) {if (e.constructor.name !== t.constructor.name) return !1;let n, i;if (Array.isArray(e)) {if (n = e.length, n != t.length) return !1;for (i = n; 0 != i--;) if (!ie(e[i], t[i])) return !1;return !0;}if (e instanceof Map && t instanceof Map) {if (e.size !== t.size) return !1;for (i of e.entries()) if (!t.has(i[0])) return !1;for (i of e.entries()) if (!ie(i[1], t.get(i[0]))) return !1;return !0;}if (e instanceof Set && t instanceof Set) {if (e.size !== t.size) return !1;for (i of e.entries()) if (!t.has(i[0])) return !1;return !0;}if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {if (n = e.length, n != t.length) return !1;for (i = n; 0 != i--;) if (e[i] !== t[i]) return !1;return !0;}if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags;if (e.valueOf !== Object.prototype.valueOf && e.valueOf !== ne.valueOf) return e.valueOf() === t.valueOf();if (e.toString !== Object.prototype.toString && e.toString !== ne.toString) return e.toString() === t.toString();const r = Object.keys(e);if (n = r.length, n !== Object.keys(t).length) return !1;for (i = n; 0 != i--;) if (!Object.prototype.hasOwnProperty.call(t, r[i])) return !1;for (i = n; 0 != i--;) {const n = r[i];if (!ie(e[n], t[n])) return !1;}return !0;}return e != e && t != t;}function re(e) {const t = [];return function e(n) {if (n && n.toJSON && "function" == typeof n.toJSON && (n = n.toJSON()), void 0 === n) return;if ("number" == typeof n) return isFinite(n) ? "" + n : "null";if ("object" != typeof n) return JSON.stringify(n);let i, r;if (Array.isArray(n)) {for (r = "[", i = 0; i < n.length; i++) i && (r += ","), r += e(n[i]) || "null";return r + "]";}if (null === n) return "null";if (t.includes(n)) throw new TypeError("Converting circular structure to JSON");const o = t.push(n) - 1,a = Object.keys(n).sort();for (r = "", i = 0; i < a.length; i++) {const t = a[i],o = e(n[t]);o && (r && (r += ","), r += JSON.stringify(t) + ":" + o);}return t.splice(o, 1), "{".concat(r, "}");}(e);}const oe = "row",ae = "column",se = "facet",le = "x",ce = "y",ue = "x2",fe = "y2",de = "xOffset",me = "yOffset",pe = "radius",ge = "radius2",he = "theta",ye = "theta2",ve = "latitude",be = "longitude",xe = "latitude2",$e = "longitude2",we = "color",ke = "fill",Se = "stroke",De = "shape",Fe = "size",ze = "angle",Oe = "opacity",_e = "fillOpacity",Ne = "strokeOpacity",Ce = "strokeWidth",Pe = "strokeDash",Ae = "text",je = "order",Te = "detail",Ee = "key",Me = "tooltip",Le = "href",qe = "url",Ue = "description",Re = { theta: 1, theta2: 1, radius: 1, radius2: 1 };function We(e) {return e in Re;}const Be = { longitude: 1, longitude2: 1, latitude: 1, latitude2: 1 };function Ie(e) {switch (e) {case ve:return "y";case xe:return "y2";case be:return "x";case $e:return "x2";}}function He(e) {return e in Be;}const Ve = j(Be),Ge = _objectSpread(_objectSpread(_objectSpread({ x: 1, y: 1, x2: 1, y2: 1 }, Re), Be), {}, { xOffset: 1, yOffset: 1, color: 1, fill: 1, stroke: 1, opacity: 1, fillOpacity: 1, strokeOpacity: 1, strokeWidth: 1, strokeDash: 1, size: 1, angle: 1, shape: 1, order: 1, text: 1, detail: 1, key: 1, tooltip: 1, href: 1, url: 1, description: 1 });function Ye(e) {return e === we || e === ke || e === Se;}const Xe = { row: 1, column: 1, facet: 1 },Je = j(Xe),Qe = _objectSpread(_objectSpread({}, Ge), Xe),Ke = j(Qe),{ order: Ze, detail: et, tooltip: tt } = Qe,nt = _objectWithoutProperties(Qe, _excluded),{ row: it, column: rt, facet: ot } = nt,at = _objectWithoutProperties(nt, _excluded2);function st(e) {return !!Qe[e];}const lt = [ue, fe, xe, $e, ye, ge];function ct(e) {return ut(e) !== e;}function ut(e) {switch (e) {case ue:return le;case fe:return ce;case xe:return ve;case $e:return be;case ye:return he;case ge:return pe;}return e;}function ft(e) {if (We(e)) switch (e) {case he:return "startAngle";case ye:return "endAngle";case pe:return "outerRadius";case ge:return "innerRadius";}return e;}function dt(e) {switch (e) {case le:return ue;case ce:return fe;case ve:return xe;case be:return $e;case he:return ye;case pe:return ge;}}function mt(e) {switch (e) {case le:case ue:return "width";case ce:case fe:return "height";}}function pt(e) {switch (e) {case le:return "xOffset";case ce:return "yOffset";case ue:return "x2Offset";case fe:return "y2Offset";case he:return "thetaOffset";case pe:return "radiusOffset";case ye:return "theta2Offset";case ge:return "radius2Offset";}}function gt(e) {switch (e) {case le:return "xOffset";case ce:return "yOffset";}}function ht(e) {switch (e) {case "xOffset":return "x";case "yOffset":return "y";}}const yt = j(Ge),{ x: vt, y: bt, x2: xt, y2: $t, xOffset: wt, yOffset: kt, latitude: St, longitude: Dt, latitude2: Ft, longitude2: zt, theta: Ot, theta2: _t, radius: Nt, radius2: Ct } = Ge,Pt = _objectWithoutProperties(Ge, _excluded3),At = j(Pt),jt = { x: 1, y: 1 },Tt = j(jt);function Et(e) {return e in jt;}const Mt = { theta: 1, radius: 1 },Lt = j(Mt);function qt(e) {return "width" === e ? le : ce;}const Ut = { xOffset: 1, yOffset: 1 };function Rt(e) {return e in Ut;}const { text: Wt, tooltip: Bt, href: It, url: Ht, description: Vt, detail: Gt, key: Yt, order: Xt } = Pt,Jt = _objectWithoutProperties(Pt, _excluded4),Qt = j(Jt);const Kt = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, jt), Mt), Ut), Jt),Zt = j(Kt);function en(e) {return !!Kt[e];}function tn(e, t) {return function (e) {switch (e) {case we:case ke:case Se:case Ue:case Te:case Ee:case Me:case Le:case je:case Oe:case _e:case Ne:case Ce:case se:case oe:case ae:return nn;case le:case ce:case de:case me:case ve:case be:return on;case ue:case fe:case xe:case $e:return { area: "always", bar: "always", image: "always", rect: "always", rule: "always", circle: "binned", point: "binned", square: "binned", tick: "binned", line: "binned", trail: "binned" };case Fe:return { point: "always", tick: "always", rule: "always", circle: "always", square: "always", bar: "always", text: "always", line: "always", trail: "always" };case Pe:return { line: "always", point: "always", tick: "always", rule: "always", circle: "always", square: "always", bar: "always", geoshape: "always" };case De:return { point: "always", geoshape: "always" };case Ae:return { text: "always" };case ze:return { point: "always", square: "always", text: "always" };case qe:return { image: "always" };case he:case pe:return { text: "always", arc: "always" };case ye:case ge:return { arc: "always" };}}(e)[t];}const nn = { arc: "always", area: "always", bar: "always", circle: "always", geoshape: "always", image: "always", line: "always", rule: "always", point: "always", rect: "always", square: "always", trail: "always", text: "always", tick: "always" },{ geoshape: rn } = nn,on = _objectWithoutProperties(nn, _excluded5);function an(e) {switch (e) {case le:case ce:case he:case pe:case de:case me:case Fe:case ze:case Ce:case Oe:case _e:case Ne:case ue:case fe:case ye:case ge:return;case se:case oe:case ae:case De:case Pe:case Ae:case Me:case Le:case qe:case Ue:return "discrete";case we:case ke:case Se:return "flexible";case ve:case be:case xe:case $e:case Te:case Ee:case je:return;}}const sn = { argmax: 1, argmin: 1, average: 1, count: 1, distinct: 1, product: 1, max: 1, mean: 1, median: 1, min: 1, missing: 1, q1: 1, q3: 1, ci0: 1, ci1: 1, stderr: 1, stdev: 1, stdevp: 1, sum: 1, valid: 1, values: 1, variance: 1, variancep: 1 },ln = { count: 1, min: 1, max: 1 };function cn(e) {return !!e && !!e.argmin;}function un(e) {return !!e && !!e.argmax;}function fn(e) {return t.isString(e) && !!sn[e];}const dn = new Set(["count", "valid", "missing", "distinct"]);function mn(e) {return t.isString(e) && dn.has(e);}const pn = new Set(["count", "sum", "distinct", "valid", "missing"]),gn = new Set(["mean", "average", "median", "q1", "q3", "min", "max"]);function hn(e) {return t.isBoolean(e) && (e = Oa(e, void 0)), "bin" + j(e).map((t) => xn(e[t]) ? L("_".concat(t, "_").concat(E(e[t]))) : L("_".concat(t, "_").concat(e[t]))).join("");}function yn(e) {return !0 === e || bn(e) && !e.binned;}function vn(e) {return "binned" === e || bn(e) && !0 === e.binned;}function bn(e) {return t.isObject(e);}function xn(e) {return e === null || e === void 0 ? void 0 : e.param;}function $n(e) {switch (e) {case oe:case ae:case Fe:case we:case ke:case Se:case Ce:case Oe:case _e:case Ne:case De:return 6;case Pe:return 4;default:return 10;}}function wn(e) {return !!(e !== null && e !== void 0 && e.expr);}function kn(e) {const t = j(e || {}),n = {};for (const i of t) n[i] = An(e[i]);return n;}function Sn(e) {const { anchor: t, frame: n, offset: i, orient: r, angle: o, limit: a, color: s, subtitleColor: l, subtitleFont: c, subtitleFontSize: u, subtitleFontStyle: f, subtitleFontWeight: d, subtitleLineHeight: m, subtitlePadding: p } = e,g = _objectWithoutProperties(e, _excluded6),h = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, t ? { anchor: t } : {}), n ? { frame: n } : {}), i ? { offset: i } : {}), r ? { orient: r } : {}), void 0 !== o ? { angle: o } : {}), void 0 !== a ? { limit: a } : {}),y = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, l ? { subtitleColor: l } : {}), c ? { subtitleFont: c } : {}), u ? { subtitleFontSize: u } : {}), f ? { subtitleFontStyle: f } : {}), d ? { subtitleFontWeight: d } : {}), m ? { subtitleLineHeight: m } : {}), p ? { subtitlePadding: p } : {});return { titleMarkConfig: _objectSpread(_objectSpread({}, g), s ? { fill: s } : {}), subtitleMarkConfig: b(e, ["align", "baseline", "dx", "dy", "limit"]), nonMarkTitleProperties: h, subtitle: y };}function Dn(e) {return t.isString(e) || t.isArray(e) && t.isString(e[0]);}function Fn(e) {return !!(e !== null && e !== void 0 && e.signal);}function zn(e) {return !!e.step;}function On(e) {return !t.isArray(e) && "field" in e && "data" in e;}const _n = j({ aria: 1, description: 1, ariaRole: 1, ariaRoleDescription: 1, blend: 1, opacity: 1, fill: 1, fillOpacity: 1, stroke: 1, strokeCap: 1, strokeWidth: 1, strokeOpacity: 1, strokeDash: 1, strokeDashOffset: 1, strokeJoin: 1, strokeOffset: 1, strokeMiterLimit: 1, startAngle: 1, endAngle: 1, padAngle: 1, innerRadius: 1, outerRadius: 1, size: 1, shape: 1, interpolate: 1, tension: 1, orient: 1, align: 1, baseline: 1, text: 1, dir: 1, dx: 1, dy: 1, ellipsis: 1, limit: 1, radius: 1, theta: 1, angle: 1, font: 1, fontSize: 1, fontWeight: 1, fontStyle: 1, lineBreak: 1, lineHeight: 1, cursor: 1, href: 1, tooltip: 1, cornerRadius: 1, cornerRadiusTopLeft: 1, cornerRadiusTopRight: 1, cornerRadiusBottomLeft: 1, cornerRadiusBottomRight: 1, aspect: 1, width: 1, height: 1, url: 1, smooth: 1 }),Nn = { arc: 1, area: 1, group: 1, image: 1, line: 1, path: 1, rect: 1, rule: 1, shape: 1, symbol: 1, text: 1, trail: 1 },Cn = ["cornerRadius", "cornerRadiusTopLeft", "cornerRadiusTopRight", "cornerRadiusBottomLeft", "cornerRadiusBottomRight"];function Pn(e) {const n = t.isArray(e.condition) ? e.condition.map(jn) : jn(e.condition);return _objectSpread(_objectSpread({}, An(e)), {}, { condition: n });}function An(e) {if (wn(e)) {const { expr: t } = e,n = _objectWithoutProperties(e, _excluded7);return _objectSpread({ signal: t }, n);}return e;}function jn(e) {if (wn(e)) {const { expr: t } = e,n = _objectWithoutProperties(e, _excluded8);return _objectSpread({ signal: t }, n);}return e;}function Tn(e) {if (wn(e)) {const { expr: t } = e,n = _objectWithoutProperties(e, _excluded9);return _objectSpread({ signal: t }, n);}return Fn(e) ? e : void 0 !== e ? { value: e } : void 0;}function En(e) {return Fn(e) ? e.signal : t.stringValue(e.value);}function Mn(e) {return Fn(e) ? e.signal : null == e ? null : t.stringValue(e);}function Ln(e, t, n) {for (const i of n) {const n = Rn(i, t.markDef, t.config);void 0 !== n && (e[i] = Tn(n));}return e;}function qn(e) {var _e$style;return [].concat(e.type, (_e$style = e.style) !== null && _e$style !== void 0 ? _e$style : []);}function Un(e, t, n) {let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};const { vgChannel: r, ignoreVgConfig: o } = i;return r && void 0 !== t[r] ? t[r] : void 0 !== t[e] ? t[e] : !o || r && r !== e ? Rn(e, t, n, i) : void 0;}function Rn(e, t, n) {let { vgChannel: i } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};return X(i ? Wn(e, t, n.style) : void 0, Wn(e, t, n.style), i ? n[t.type][i] : void 0, n[t.type][e], i ? n.mark[i] : n.mark[e]);}function Wn(e, t, n) {return Bn(e, qn(t), n);}function Bn(e, n, i) {let r;n = t.array(n);for (const t of n) {const n = i[t];n && void 0 !== n[e] && (r = n[e]);}return r;}function In(e, n) {return t.array(e).reduce((e, t) => {var _t$sort;return e.field.push(pa(t, n)), e.order.push((_t$sort = t.sort) !== null && _t$sort !== void 0 ? _t$sort : "ascending"), e;}, { field: [], order: [] });}function Hn(e, t) {const n = [...e];return t.forEach((e) => {for (const t of n) if (ie(t, e)) return;n.push(e);}), n;}function Vn(e, n) {return ie(e, n) || !n ? e : e ? [...t.array(e), ...t.array(n)].join(", ") : n;}function Gn(e, t) {const n = e.value,i = t.value;if (null == n || null === i) return { explicit: e.explicit, value: null };if ((Dn(n) || Fn(n)) && (Dn(i) || Fn(i))) return { explicit: e.explicit, value: Vn(n, i) };if (Dn(n) || Fn(n)) return { explicit: e.explicit, value: n };if (Dn(i) || Fn(i)) return { explicit: e.explicit, value: i };if (!(Dn(n) || Fn(n) || Dn(i) || Fn(i))) return { explicit: e.explicit, value: Hn(n, i) };throw new Error("It should never reach here");}function Yn(e, t, n) {return (t = function (e) {var t = function (e, t) {if ("object" != typeof e || null === e) return e;var n = e[Symbol.toPrimitive];if (void 0 !== n) {var i = n.call(e, t || "default");if ("object" != typeof i) return i;throw new TypeError("@@toPrimitive must return a primitive value.");}return ("string" === t ? String : Number)(e);}(e, "string");return "symbol" == typeof t ? t : String(t);}(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;}function Xn(e, t, n) {return function (e, t, n) {if (t.set) t.set.call(e, n);else {if (!t.writable) throw new TypeError("attempted to set read only private field");t.value = n;}}(e, Jn(e, t, "set"), n), n;}function Jn(e, t, n) {if (!t.has(e)) throw new TypeError("attempted to " + n + " private field on non-instance");return t.get(e);}function Qn(e, t, n) {!function (e, t) {if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");}(e, t), t.set(e, n);}function Kn(e) {return "Invalid specification ".concat(re(e), ". Make sure the specification includes at least one of the following properties: \"mark\", \"layer\", \"facet\", \"hconcat\", \"vconcat\", \"concat\", or \"repeat\".");}const Zn = 'Autosize "fit" only works for single views and layered views.';function ei(e) {return "".concat("width" == e ? "Width" : "Height", " \"container\" only works for single views and layered views.");}function ti(e) {return "".concat("width" == e ? "Width" : "Height", " \"container\" only works well with autosize \"fit\" or \"fit-").concat("width" == e ? "x" : "y", "\".");}function ni(e) {return e ? "Dropping \"fit-".concat(e, "\" because spec has discrete ").concat(mt(e), ".") : 'Dropping "fit" because spec has discrete size.';}function ii(e) {return "Unknown field for ".concat(e, ". Cannot calculate view size.");}function ri(e) {return "Cannot project a selection on encoding channel \"".concat(e, "\", which has no field.");}function oi(e, t) {return "Cannot project a selection on encoding channel \"".concat(e, "\" as it uses an aggregate function (\"").concat(t, "\").");}function ai(e) {return "Selection not supported for ".concat(e, " yet.");}const si = "The same selection must be used to override scale domains in a layered view.";function li(e) {return "The \"columns\" property cannot be used when \"".concat(e, "\" has nested row/column.");}function ci(e, t, n) {return "An ancestor parsed field \"".concat(e, "\" as ").concat(n, " but a child wants to parse the field as ").concat(t, ".");}function ui(e) {return "Config.customFormatTypes is not true, thus custom format type and format for channel ".concat(e, " are dropped.");}function fi(e) {return "".concat(e, "Offset dropped because ").concat(e, " is continuous");}function di(e) {return "Invalid field type \"".concat(e, "\".");}function mi(e, t) {const { fill: n, stroke: i } = t;return "Dropping color ".concat(e, " as the plot also has ").concat(n && i ? "fill and stroke" : n ? "fill" : "stroke", ".");}function pi(e, t) {return "Dropping ".concat(re(e), " from channel \"").concat(t, "\" since it does not contain any data field, datum, value, or signal.");}function gi(e, t, n) {return "".concat(e, " dropped as it is incompatible with \"").concat(t, "\"").concat(n ? " when ".concat(n) : "", ".");}function hi(e) {return "".concat(e, " encoding should be discrete (ordinal / nominal / binned).");}function yi(e) {return "".concat(e, " encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).");}function vi(e, t) {return "Using discrete channel \"".concat(e, "\" to encode \"").concat(t, "\" field can be misleading as it does not encode ").concat("ordinal" === t ? "order" : "magnitude", ".");}function bi(e) {return "Using unaggregated domain with raw field has no effect (".concat(re(e), ").");}function xi(e) {return "Unaggregated domain not applicable for \"".concat(e, "\" since it produces values outside the origin domain of the source data.");}function $i(e) {return "Unaggregated domain is currently unsupported for log scale (".concat(re(e), ").");}function wi(e, t, n) {return "".concat(n, "-scale's \"").concat(t, "\" is dropped as it does not work with ").concat(e, " scale.");}function ki(e) {return "The step for \"".concat(e, "\" is dropped because the ").concat("width" === e ? "x" : "y", " is continuous.");}const Si = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.";function Di(e, t) {return "Invalid ".concat(e, ": ").concat(re(t), ".");}function Fi(e) {return "1D error band does not support ".concat(e, ".");}function zi(e) {return "Channel ".concat(e, " is required for \"binned\" bin.");}const Oi = t.logger(t.Warn);let _i = Oi;function Ni() {_i.warn(...arguments);}function Ci(e) {if (e && t.isObject(e)) for (const t of qi) if (t in e) return !0;return !1;}const Pi = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"],Ai = Pi.map((e) => e.substr(0, 3)),ji = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"],Ti = ji.map((e) => e.substr(0, 3));function Ei(e, n) {const i = [];if (n && void 0 !== e.day && j(e).length > 1 && (Ni(function (e) {return "Dropping day from datetime ".concat(re(e), " as day cannot be combined with other units.");}(e)), delete (e = y(e)).day), void 0 !== e.year ? i.push(e.year) : i.push(2012), void 0 !== e.month) {const r = n ? function (e) {if (te(e) && (e = +e), t.isNumber(e)) return e - 1;{const t = e.toLowerCase(),n = Pi.indexOf(t);if (-1 !== n) return n;const i = t.substr(0, 3),r = Ai.indexOf(i);if (-1 !== r) return r;throw new Error(Di("month", e));}}(e.month) : e.month;i.push(r);} else if (void 0 !== e.quarter) {const r = n ? function (e) {if (te(e) && (e = +e), t.isNumber(e)) return e > 4 && Ni(Di("quarter", e)), e - 1;throw new Error(Di("quarter", e));}(e.quarter) : e.quarter;i.push(t.isNumber(r) ? 3 * r : "".concat(r, "*3"));} else i.push(0);if (void 0 !== e.date) i.push(e.date);else if (void 0 !== e.day) {const r = n ? function (e) {if (te(e) && (e = +e), t.isNumber(e)) return e % 7;{const t = e.toLowerCase(),n = ji.indexOf(t);if (-1 !== n) return n;const i = t.substr(0, 3),r = Ti.indexOf(i);if (-1 !== r) return r;throw new Error(Di("day", e));}}(e.day) : e.day;i.push(t.isNumber(r) ? r + 1 : "".concat(r, "+1"));} else i.push(1);for (const t of ["hours", "minutes", "seconds", "milliseconds"]) {const n = e[t];i.push(void 0 === n ? 0 : n);}return i;}function Mi(e) {const t = Ei(e, !0).join(", ");return e.utc ? "utc(".concat(t, ")") : "datetime(".concat(t, ")");}const Li = { year: 1, quarter: 1, month: 1, week: 1, day: 1, dayofyear: 1, date: 1, hours: 1, minutes: 1, seconds: 1, milliseconds: 1 },qi = j(Li);function Ui(e) {return t.isObject(e) ? e.binned : Ri(e);}function Ri(e) {return e && e.startsWith("binned");}function Wi(e) {return e.startsWith("utc");}const Bi = { "year-month": "%b %Y ", "year-month-date": "%b %d, %Y " };function Ii(e) {return qi.filter((t) => Vi(e, t));}function Hi(e) {const t = Ii(e);return t[t.length - 1];}function Vi(e, t) {const n = e.indexOf(t);return !(n < 0) && !(n > 0 && "seconds" === t && "i" === e.charAt(n - 1)) && !(e.length > n + 3 && "day" === t && "o" === e.charAt(n + 3)) && !(n > 0 && "year" === t && "f" === e.charAt(n - 1));}function Gi(e, t) {let { end: n } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { end: !1 };const i = W(t),r = Wi(e) ? "utc" : "";let o;const a = {};for (const t of qi) Vi(e, t) && (a[t] = "quarter" === (s = t) ? "(".concat(r, "quarter(").concat(i, ")-1)") : "".concat(r).concat(s, "(").concat(i, ")"), o = t);var s;return n && (a[o] += "+1"), function (e) {const t = Ei(e, !1).join(", ");return e.utc ? "utc(".concat(t, ")") : "datetime(".concat(t, ")");}(a);}function Yi(e) {if (!e) return;return "timeUnitSpecifier(".concat(re(Ii(e)), ", ").concat(re(Bi), ")");}function Xi(e) {if (!e) return;let n;return t.isString(e) ? n = Ri(e) ? { unit: e.substring(6), binned: !0 } : { unit: e } : t.isObject(e) && (n = _objectSpread(_objectSpread({}, e), e.unit ? { unit: e.unit } : {})), Wi(n.unit) && (n.utc = !0, n.unit = n.unit.substring(3)), n;}function Ji(e) {let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (e) => e;const n = Xi(e),i = Hi(n.unit);if (i && "day" !== i) {const e = { year: 2001, month: 1, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 },{ step: r, part: o } = Ki(i, n.step);return "".concat(t(Mi(_objectSpread(_objectSpread({}, e), {}, { [o]: +e[o] + r }))), " - ").concat(t(Mi(e)));}}const Qi = { year: 1, month: 1, date: 1, hours: 1, minutes: 1, seconds: 1, milliseconds: 1 };function Ki(e) {let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;if (function (e) {return !!Qi[e];}(e)) return { part: e, step: t };switch (e) {case "day":case "dayofyear":return { part: "date", step: t };case "quarter":return { part: "month", step: 3 * t };case "week":return { part: "date", step: 7 * t };}}function Zi(e) {return !!(e !== null && e !== void 0 && e.field) && void 0 !== e.equal;}function er(e) {return !!(e !== null && e !== void 0 && e.field) && void 0 !== e.lt;}function tr(e) {return !!(e !== null && e !== void 0 && e.field) && void 0 !== e.lte;}function nr(e) {return !!(e !== null && e !== void 0 && e.field) && void 0 !== e.gt;}function ir(e) {return !!(e !== null && e !== void 0 && e.field) && void 0 !== e.gte;}function rr(e) {if (e !== null && e !== void 0 && e.field) {if (t.isArray(e.range) && 2 === e.range.length) return !0;if (Fn(e.range)) return !0;}return !1;}function or(e) {return !!(e !== null && e !== void 0 && e.field) && (t.isArray(e.oneOf) || t.isArray(e.in));}function ar(e) {return or(e) || Zi(e) || rr(e) || er(e) || nr(e) || tr(e) || ir(e);}function sr(e, t) {return Ca(e, { timeUnit: t, wrapTime: !0 });}function lr(e) {let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];const { field: n } = e,i = Xi(e.timeUnit),{ unit: r, binned: o } = i || {},a = pa(e, { expr: "datum" }),s = r ? "time(".concat(o ? a : Gi(r, n), ")") : a;if (Zi(e)) return "".concat(s, "===").concat(sr(e.equal, r));if (er(e)) {return "".concat(s, "<").concat(sr(e.lt, r));}if (nr(e)) {return "".concat(s, ">").concat(sr(e.gt, r));}if (tr(e)) {return "".concat(s, "<=").concat(sr(e.lte, r));}if (ir(e)) {return "".concat(s, ">=").concat(sr(e.gte, r));}if (or(e)) return "indexof([".concat(function (e, t) {return e.map((e) => sr(e, t));}(e.oneOf, r).join(","), "], ").concat(s, ") !== -1");if (function (e) {return !!(e !== null && e !== void 0 && e.field) && void 0 !== e.valid;}(e)) return cr(s, e.valid);if (rr(e)) {const { range: n } = e,i = Fn(n) ? { signal: "".concat(n.signal, "[0]") } : n[0],o = Fn(n) ? { signal: "".concat(n.signal, "[1]") } : n[1];if (null !== i && null !== o && t) return "inrange(" + s + ", [" + sr(i, r) + ", " + sr(o, r) + "])";const a = [];return null !== i && a.push("".concat(s, " >= ").concat(sr(i, r))), null !== o && a.push("".concat(s, " <= ").concat(sr(o, r))), a.length > 0 ? a.join(" && ") : "true";}throw new Error("Invalid field predicate: ".concat(re(e)));}function cr(e) {return !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? "isValid(".concat(e, ") && isFinite(+").concat(e, ")") : "!isValid(".concat(e, ") || !isFinite(+").concat(e, ")");}function ur(e) {return ar(e) && e.timeUnit ? _objectSpread(_objectSpread({}, e), {}, { timeUnit: Xi(e.timeUnit) }) : e;}function fr(e) {return "quantitative" === e || "temporal" === e;}function dr(e) {return "ordinal" === e || "nominal" === e;}const mr = "quantitative",pr = "ordinal",gr = "temporal",hr = "nominal",yr = "geojson";const vr = { LINEAR: "linear", LOG: "log", POW: "pow", SQRT: "sqrt", SYMLOG: "symlog", IDENTITY: "identity", SEQUENTIAL: "sequential", TIME: "time", UTC: "utc", QUANTILE: "quantile", QUANTIZE: "quantize", THRESHOLD: "threshold", BIN_ORDINAL: "bin-ordinal", ORDINAL: "ordinal", POINT: "point", BAND: "band" },br = { linear: "numeric", log: "numeric", pow: "numeric", sqrt: "numeric", symlog: "numeric", identity: "numeric", sequential: "numeric", time: "time", utc: "time", ordinal: "ordinal", "bin-ordinal": "bin-ordinal", point: "ordinal-position", band: "ordinal-position", quantile: "discretizing", quantize: "discretizing", threshold: "discretizing" };function xr(e, t) {const n = br[e],i = br[t];return n === i || "ordinal-position" === n && "time" === i || "ordinal-position" === i && "time" === n;}const $r = { linear: 0, log: 1, pow: 1, sqrt: 1, symlog: 1, identity: 1, sequential: 1, time: 0, utc: 0, point: 10, band: 11, ordinal: 0, "bin-ordinal": 0, quantile: 0, quantize: 0, threshold: 0 };function wr(e) {return $r[e];}const kr = new Set(["linear", "log", "pow", "sqrt", "symlog"]),Sr = new Set([...kr, "time", "utc"]);function Dr(e) {return kr.has(e);}const Fr = new Set(["quantile", "quantize", "threshold"]),zr = new Set([...Sr, ...Fr, "sequential", "identity"]),Or = new Set(["ordinal", "bin-ordinal", "point", "band"]);function _r(e) {return Or.has(e);}function Nr(e) {return zr.has(e);}function Cr(e) {return Sr.has(e);}function Pr(e) {return Fr.has(e);}function Ar(e) {return e === null || e === void 0 ? void 0 : e.param;}const _type$domain$domainMa = { type: 1, domain: 1, domainMax: 1, domainMin: 1, domainMid: 1, domainRaw: 1, align: 1, range: 1, rangeMax: 1, rangeMin: 1, scheme: 1, bins: 1, reverse: 1, round: 1, clamp: 1, nice: 1, base: 1, exponent: 1, constant: 1, interpolate: 1, zero: 1, padding: 1, paddingInner: 1, paddingOuter: 1 },{ type: jr, domain: Tr, range: Er, rangeMax: Mr, rangeMin: Lr, scheme: qr } = _type$domain$domainMa,Ur = _objectWithoutProperties(_type$domain$domainMa, _excluded10),Rr = j(Ur);function Wr(e, t) {switch (t) {case "type":case "domain":case "reverse":case "range":return !0;case "scheme":case "interpolate":return !["point", "band", "identity"].includes(e);case "bins":return !["point", "band", "identity", "ordinal"].includes(e);case "round":return Cr(e) || "band" === e || "point" === e;case "padding":case "rangeMin":case "rangeMax":return Cr(e) || ["point", "band"].includes(e);case "paddingOuter":case "align":return ["point", "band"].includes(e);case "paddingInner":return "band" === e;case "domainMax":case "domainMid":case "domainMin":case "domainRaw":case "clamp":return Cr(e);case "nice":return Cr(e) || "quantize" === e || "threshold" === e;case "exponent":return "pow" === e;case "base":return "log" === e;case "constant":return "symlog" === e;case "zero":return Nr(e) && !k(["log", "time", "utc", "threshold", "quantile"], e);}}function Br(e, t) {switch (t) {case "interpolate":case "scheme":case "domainMid":return Ye(e) ? void 0 : "Cannot use the scale property \"".concat(t, "\" with non-color channel.");case "align":case "type":case "bins":case "domain":case "domainMax":case "domainMin":case "domainRaw":case "range":case "base":case "exponent":case "constant":case "nice":case "padding":case "paddingInner":case "paddingOuter":case "rangeMax":case "rangeMin":case "reverse":case "round":case "clamp":case "zero":return;}}const Ir = { arc: "arc", area: "area", bar: "bar", image: "image", line: "line", point: "point", rect: "rect", rule: "rule", text: "text", tick: "tick", trail: "trail", circle: "circle", square: "square", geoshape: "geoshape" },Hr = Ir.arc,Vr = Ir.area,Gr = Ir.bar,Yr = Ir.image,Xr = Ir.line,Jr = Ir.point,Qr = Ir.rect,Kr = Ir.rule,Zr = Ir.text,eo = Ir.tick,to = Ir.trail,no = Ir.circle,io = Ir.square,ro = Ir.geoshape;function oo(e) {return ["line", "area", "trail"].includes(e);}function ao(e) {return ["rect", "bar", "image", "arc"].includes(e);}const so = new Set(j(Ir));function lo(e) {return e.type;}const co = ["stroke", "strokeWidth", "strokeDash", "strokeDashOffset", "strokeOpacity", "strokeJoin", "strokeMiterLimit", "fill", "fillOpacity"],uo = j({ color: 1, filled: 1, invalid: 1, order: 1, radius2: 1, theta2: 1, timeUnitBandSize: 1, timeUnitBandPosition: 1 }),fo = j({ mark: 1, arc: 1, area: 1, bar: 1, circle: 1, image: 1, line: 1, point: 1, rect: 1, rule: 1, square: 1, text: 1, tick: 1, trail: 1, geoshape: 1 });function mo(e) {return e && null != e.band;}const po = { horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"], vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"] },go = { binSpacing: 1, continuousBandSize: 5, minBandSize: .25, timeUnitBandPosition: .5 },ho = { binSpacing: 0, continuousBandSize: 5, minBandSize: .25, timeUnitBandPosition: .5 };function yo(e) {const { channel: t, channelDef: n, markDef: i, scale: r, config: o } = e,a = wo(e);return ea(n) && !mn(n.aggregate) && r && Cr(r.get("type")) ? function (e) {let { fieldDef: t, channel: n, markDef: i, ref: r, config: o } = e;if (oo(i.type)) return r;const a = Un("invalid", i, o);if (null === a) return [vo(t, n), r];return r;}({ fieldDef: n, channel: t, markDef: i, ref: a, config: o }) : a;}function vo(e, t) {return _objectSpread({ test: bo(e, !0) }, "y" === ut(t) ? { field: { group: "height" } } : { value: 0 });}function bo(e) {let n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];return cr(t.isString(e) ? e : pa(e, { expr: "datum" }), !n);}function xo(e, t, n, i) {const r = {};if (t && (r.scale = t), na(e)) {const { datum: t } = e;Ci(t) ? r.signal = Mi(t) : Fn(t) ? r.signal = t.signal : wn(t) ? r.signal = t.expr : r.value = t;} else r.field = pa(e, n);if (i) {const { offset: e, band: t } = i;e && (r.offset = e), t && (r.band = t);}return r;}function $o(e) {let { scaleName: t, fieldOrDatumDef: n, fieldOrDatumDef2: i, offset: r, startSuffix: o, endSuffix: a = "end", bandPosition: s = .5 } = e;const l = !Fn(s) && 0 < s && s < 1 ? "datum" : void 0,c = pa(n, { expr: l, suffix: o }),u = void 0 !== i ? pa(i, { expr: l }) : pa(n, { suffix: a, expr: l }),f = {};if (0 === s || 1 === s) {f.scale = t;const e = 0 === s ? c : u;f.field = e;} else {const e = Fn(s) ? "(1-".concat(s.signal, ") * ").concat(c, " + ").concat(s.signal, " * ").concat(u) : "".concat(1 - s, " * ").concat(c, " + ").concat(s, " * ").concat(u);f.signal = "scale(\"".concat(t, "\", ").concat(e, ")");}return r && (f.offset = r), f;}function wo(e) {let { channel: n, channelDef: i, channel2Def: r, markDef: o, config: a, scaleName: s, scale: l, stack: c, offset: u, defaultRef: f, bandPosition: d } = e;if (i) {if (aa(i)) {var _ref, _d3;const e = l === null || l === void 0 ? void 0 : l.get("type");if (sa(i)) {var _d2;(_d2 = d) !== null && _d2 !== void 0 ? _d2 : d = Go({ fieldDef: i, fieldDef2: r, markDef: o, config: a });const { bin: t, timeUnit: l, type: f } = i;if (yn(t) || d && l && f === gr) return c !== null && c !== void 0 && c.impute ? xo(i, s, { binSuffix: "mid" }, { offset: u }) : d && !_r(e) ? $o({ scaleName: s, fieldOrDatumDef: i, bandPosition: d, offset: u }) : xo(i, s, Aa(i, n) ? { binSuffix: "range" } : {}, { offset: u });if (vn(t)) {if (ea(r)) return $o({ scaleName: s, fieldOrDatumDef: i, fieldOrDatumDef2: r, bandPosition: d, offset: u });Ni(zi(n === le ? ue : fe));}}return xo(i, s, _r(e) ? { binSuffix: "range" } : {}, { offset: u, band: "band" === e ? (_ref = (_d3 = d) !== null && _d3 !== void 0 ? _d3 : i.bandPosition) !== null && _ref !== void 0 ? _ref : .5 : void 0 });}if (la(i)) {const e = u ? { offset: u } : {};return _objectSpread(_objectSpread({}, ko(n, i.value)), e);}}return t.isFunction(f) && (f = f()), f ? _objectSpread(_objectSpread({}, f), u ? { offset: u } : {}) : f;}function ko(e, t) {return k(["x", "x2"], e) && "width" === t ? { field: { group: "width" } } : k(["y", "y2"], e) && "height" === t ? { field: { group: "height" } } : Tn(t);}function So(e) {return e && "number" !== e && "time" !== e;}function Do(e, t, n) {return "".concat(e, "(").concat(t).concat(n ? ", ".concat(re(n)) : "", ")");}const Fo = " â€“ ";function zo(e) {let { fieldOrDatumDef: n, format: i, formatType: r, expr: o, normalizeStack: a, config: s } = e;if (So(r)) return _o({ fieldOrDatumDef: n, format: i, formatType: r, expr: o, config: s });const l = Oo(n, o, a),c = ta(n);if (void 0 === i && void 0 === r && s.customFormatTypes) {if ("quantitative" === c) {if (a && s.normalizedNumberFormatType) return _o({ fieldOrDatumDef: n, format: s.normalizedNumberFormat, formatType: s.normalizedNumberFormatType, expr: o, config: s });if (s.numberFormatType) return _o({ fieldOrDatumDef: n, format: s.numberFormat, formatType: s.numberFormatType, expr: o, config: s });}if ("temporal" === c && s.timeFormatType && ea(n) && void 0 === n.timeUnit) return _o({ fieldOrDatumDef: n, format: s.timeFormat, formatType: s.timeFormatType, expr: o, config: s });}if (Na(n)) {var _Xi, _n$scale;const e = function (e) {let { field: n, timeUnit: i, format: r, formatType: o, rawTimeFormat: a, isUTCScale: s } = e;return !i || r ? !i && o ? "".concat(o, "(").concat(n, ", '").concat(r, "')") : (r = t.isString(r) ? r : a, "".concat(s ? "utc" : "time", "Format(").concat(n, ", '").concat(r, "')")) : function (e, t, n) {if (!e) return;const i = Yi(e);return "".concat(n || Wi(e) ? "utc" : "time", "Format(").concat(t, ", ").concat(i, ")");}(i, n, s);}({ field: l, timeUnit: ea(n) ? (_Xi = Xi(n.timeUnit)) === null || _Xi === void 0 ? void 0 : _Xi.unit : void 0, format: i, formatType: s.timeFormatType, rawTimeFormat: s.timeFormat, isUTCScale: ca(n) && ((_n$scale = n.scale) === null || _n$scale === void 0 ? void 0 : _n$scale.type) === vr.UTC });return e ? { signal: e } : void 0;}if (i = Po({ type: c, specifiedFormat: i, config: s, normalizeStack: a }), ea(n) && yn(n.bin)) {return { signal: To(l, pa(n, { expr: o, binSuffix: "end" }), i, r, s) };}return i || "quantitative" === ta(n) ? { signal: "".concat(Ao(l, i)) } : { signal: "isValid(".concat(l, ") ? ").concat(l, " : \"\"+").concat(l) };}function Oo(e, t, n) {return ea(e) ? n ? "".concat(pa(e, { expr: t, suffix: "end" }), "-").concat(pa(e, { expr: t, suffix: "start" })) : pa(e, { expr: t }) : function (e) {const { datum: t } = e;return Ci(t) ? Mi(t) : "".concat(re(t));}(e);}function _o(e) {var _s2;let { fieldOrDatumDef: t, format: n, formatType: i, expr: r, normalizeStack: o, config: a, field: s } = e;if ((_s2 = s) !== null && _s2 !== void 0 ? _s2 : s = Oo(t, r, o), "datum.value" !== s && ea(t) && yn(t.bin)) {return { signal: To(s, pa(t, { expr: r, binSuffix: "end" }), n, i, a) };}return { signal: Do(i, s, n) };}function No(e, n, i, r, o, a) {if (!t.isString(r) || !So(r)) {if (void 0 === i && void 0 === r && o.customFormatTypes && "quantitative" === ta(e)) {if (o.normalizedNumberFormatType && ua(e) && "normalize" === e.stack) return;if (o.numberFormatType) return;}if (ua(e) && "normalize" === e.stack && o.normalizedNumberFormat) return Po({ type: "quantitative", config: o, normalizeStack: !0 });if (Na(e)) {var _Xi2;const t = ea(e) ? (_Xi2 = Xi(e.timeUnit)) === null || _Xi2 === void 0 ? void 0 : _Xi2.unit : void 0;if (void 0 === t && o.customFormatTypes && o.timeFormatType) return;return function (e) {let { specifiedFormat: t, timeUnit: n, config: i, omitTimeFormatConfig: r } = e;if (t) return t;if (n) return { signal: Yi(n) };return r ? void 0 : i.timeFormat;}({ specifiedFormat: i, timeUnit: t, config: o, omitTimeFormatConfig: a });}return Po({ type: n, specifiedFormat: i, config: o });}}function Co(e, t, n) {var _Xi3;return e && (Fn(e) || "number" === e || "time" === e) ? e : Na(t) && "time" !== n && "utc" !== n ? ea(t) && (_Xi3 = Xi(t === null || t === void 0 ? void 0 : t.timeUnit)) !== null && _Xi3 !== void 0 && _Xi3.utc ? "utc" : "time" : void 0;}function Po(e) {let { type: n, specifiedFormat: i, config: r, normalizeStack: o } = e;return t.isString(i) ? i : n === mr ? o ? r.normalizedNumberFormat : r.numberFormat : void 0;}function Ao(e, t) {return "format(".concat(e, ", \"").concat(t || "", "\")");}function jo(e, n, i, r) {var _ref2;return So(i) ? Do(i, e, n) : Ao(e, (_ref2 = t.isString(n) ? n : void 0) !== null && _ref2 !== void 0 ? _ref2 : r.numberFormat);}function To(e, t, n, i, r) {if (void 0 === n && void 0 === i && r.customFormatTypes && r.numberFormatType) return To(e, t, r.numberFormat, r.numberFormatType, r);const o = jo(e, n, i, r),a = jo(t, n, i, r);return "".concat(cr(e, !1), " ? \"null\" : ").concat(o, " + \"").concat(Fo, "\" + ").concat(a);}const Eo = "min",Mo = { x: 1, y: 1, color: 1, fill: 1, stroke: 1, strokeWidth: 1, size: 1, shape: 1, fillOpacity: 1, strokeOpacity: 1, opacity: 1, text: 1 };function Lo(e) {return e in Mo;}function qo(e) {return !!(e !== null && e !== void 0 && e.encoding);}function Uo(e) {return e && ("count" === e.op || !!e.field);}function Ro(e) {return e && t.isArray(e);}function Wo(e) {return "row" in e || "column" in e;}function Bo(e) {return !!e && "header" in e;}function Io(e) {return "facet" in e;}function Ho(e) {const { field: t, timeUnit: n, bin: i, aggregate: r } = e;return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, n ? { timeUnit: n } : {}), i ? { bin: i } : {}), r ? { aggregate: r } : {}), {}, { field: t });}function Vo(e) {return "sort" in e;}function Go(e) {let { fieldDef: t, fieldDef2: n, markDef: i, config: r } = e;if (aa(t) && void 0 !== t.bandPosition) return t.bandPosition;if (ea(t)) {const { timeUnit: e, bin: o } = t;if (e && !n) return Rn("timeUnitBandPosition", i, r);if (yn(o)) return .5;}}function Yo(e) {var _o$r$type, _o$r$type2, _o$r$type3;let { channel: t, fieldDef: n, fieldDef2: i, markDef: r, config: o, scaleType: a, useVlSizeChannel: s } = e;const l = mt(t),c = Un(s ? "size" : l, r, o, { vgChannel: l });if (void 0 !== c) return c;if (ea(n)) {const { timeUnit: e, bin: t } = n;if (e && !i) return { band: Rn("timeUnitBandSize", r, o) };if (yn(t) && !_r(a)) return { band: 1 };}return ao(r.type) ? a ? _r(a) ? ((_o$r$type = o[r.type]) === null || _o$r$type === void 0 ? void 0 : _o$r$type.discreteBandSize) || { band: 1 } : (_o$r$type2 = o[r.type]) === null || _o$r$type2 === void 0 ? void 0 : _o$r$type2.continuousBandSize : (_o$r$type3 = o[r.type]) === null || _o$r$type3 === void 0 ? void 0 : _o$r$type3.discreteBandSize : void 0;}function Xo(e, t, n, i) {return !!(yn(e.bin) || e.timeUnit && sa(e) && "temporal" === e.type) && void 0 !== Go({ fieldDef: e, fieldDef2: t, markDef: n, config: i });}function Jo(e) {return e && !!e.sort && !e.field;}function Qo(e) {return e && "condition" in e;}function Ko(e) {const n = e === null || e === void 0 ? void 0 : e.condition;return !!n && !t.isArray(n) && ea(n);}function Zo(e) {const n = e === null || e === void 0 ? void 0 : e.condition;return !!n && !t.isArray(n) && aa(n);}function ea(e) {return e && (!!e.field || "count" === e.aggregate);}function ta(e) {return e === null || e === void 0 ? void 0 : e.type;}function na(e) {return e && "datum" in e;}function ia(e) {return sa(e) && !ga(e) || oa(e);}function ra(e) {return sa(e) && "quantitative" === e.type && !e.bin || oa(e);}function oa(e) {return na(e) && t.isNumber(e.datum);}function aa(e) {return ea(e) || na(e);}function sa(e) {return e && ("field" in e || "count" === e.aggregate) && "type" in e;}function la(e) {return e && "value" in e && "value" in e;}function ca(e) {return e && ("scale" in e || "sort" in e);}function ua(e) {return e && ("axis" in e || "stack" in e || "impute" in e);}function fa(e) {return e && "legend" in e;}function da(e) {return e && ("format" in e || "formatType" in e);}function ma(e) {return x(e, ["legend", "axis", "header", "scale"]);}function pa(e) {let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},n = e.field;const i = t.prefix;let r = t.suffix,o = "";if (function (e) {return "count" === e.aggregate;}(e)) n = K("count");else {let i;if (!t.nofn) if (function (e) {return "op" in e;}(e)) i = e.op;else {var _t$binSuffix, _t$suffix, _t$suffix2;const { bin: a, aggregate: s, timeUnit: l } = e;yn(a) ? (i = hn(a), r = ((_t$binSuffix = t.binSuffix) !== null && _t$binSuffix !== void 0 ? _t$binSuffix : "") + ((_t$suffix = t.suffix) !== null && _t$suffix !== void 0 ? _t$suffix : "")) : s ? un(s) ? (o = "[\"".concat(n, "\"]"), n = "argmax_".concat(s.argmax)) : cn(s) ? (o = "[\"".concat(n, "\"]"), n = "argmin_".concat(s.argmin)) : i = String(s) : l && !Ui(l) && (i = function (e) {const _Xi4 = Xi(e),{ utc: t } = _Xi4,n = _objectWithoutProperties(_Xi4, _excluded11);return n.unit ? (t ? "utc" : "") + j(n).map((e) => L("".concat("unit" === e ? "" : "_".concat(e, "_")).concat(n[e]))).join("") : (t ? "utc" : "") + "timeunit" + j(n).map((e) => L("_".concat(e, "_").concat(n[e]))).join("");}(l), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + ((_t$suffix2 = t.suffix) !== null && _t$suffix2 !== void 0 ? _t$suffix2 : ""));}i && (n = n ? "".concat(i, "_").concat(n) : i);}return r && (n = "".concat(n, "_").concat(r)), i && (n = "".concat(i, "_").concat(n)), t.forAs ? G(n) : t.expr ? B(n, t.expr) + o : H(n) + o;}function ga(e) {switch (e.type) {case "nominal":case "ordinal":case "geojson":return !0;case "quantitative":return ea(e) && !!e.bin;case "temporal":return !1;}throw new Error(di(e.type));}const ha = (e, t) => {switch (t.fieldTitle) {case "plain":return e.field;case "functional":return function (e) {const { aggregate: t, bin: n, timeUnit: i, field: r } = e;if (un(t)) return "".concat(r, " for argmax(").concat(t.argmax, ")");if (cn(t)) return "".concat(r, " for argmin(").concat(t.argmin, ")");const o = i && !Ui(i) ? Xi(i) : void 0,a = t || (o === null || o === void 0 ? void 0 : o.unit) || (o === null || o === void 0 ? void 0 : o.maxbins) && "timeunit" || yn(n) && "bin";return a ? "".concat(a.toUpperCase(), "(").concat(r, ")") : r;}(e);default:return function (e, t) {const { field: n, bin: i, timeUnit: r, aggregate: o } = e;if ("count" === o) return t.countTitle;if (yn(i)) return "".concat(n, " (binned)");if (r && !Ui(r)) {var _Xi5;const e = (_Xi5 = Xi(r)) === null || _Xi5 === void 0 ? void 0 : _Xi5.unit;if (e) return "".concat(n, " (").concat(Ii(e).join("-"), ")");} else if (o) return un(o) ? "".concat(n, " for max ").concat(o.argmax) : cn(o) ? "".concat(n, " for min ").concat(o.argmin) : "".concat(R(o), " of ").concat(n);return n;}(e, t);}};let ya = ha;function va(e) {ya = e;}function ba(e, t, n) {var _xa, _ref3;let { allowDisabling: i, includeDefault: r = !0 } = n;const o = (_xa = xa(e)) === null || _xa === void 0 ? void 0 : _xa.title;if (!ea(e)) return o !== null && o !== void 0 ? o : e.title;const a = e,s = r ? $a(a, t) : void 0;return i ? X(o, a.title, s) : (_ref3 = o !== null && o !== void 0 ? o : a.title) !== null && _ref3 !== void 0 ? _ref3 : s;}function xa(e) {return ua(e) && e.axis ? e.axis : fa(e) && e.legend ? e.legend : Bo(e) && e.header ? e.header : void 0;}function $a(e, t) {return ya(e, t);}function wa(e) {if (da(e)) {const { format: t, formatType: n } = e;return { format: t, formatType: n };}{var _xa2;const t = (_xa2 = xa(e)) !== null && _xa2 !== void 0 ? _xa2 : {},{ format: n, formatType: i } = t;return { format: n, formatType: i };}}function ka(e) {return ea(e) ? e : Ko(e) ? e.condition : void 0;}function Sa(e) {return aa(e) ? e : Zo(e) ? e.condition : void 0;}function Da(e, n, i) {let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};if (t.isString(e) || t.isNumber(e) || t.isBoolean(e)) {return Ni(function (e, t, n) {return "Channel ".concat(e, " is a ").concat(t, ". Converted to {value: ").concat(re(n), "}.");}(n, t.isString(e) ? "string" : t.isNumber(e) ? "number" : "boolean", e)), { value: e };}return aa(e) ? Fa(e, n, i, r) : Zo(e) ? _objectSpread(_objectSpread({}, e), {}, { condition: Fa(e.condition, n, i, r) }) : e;}function Fa(e, n, i, r) {if (da(e)) {const { format: t, formatType: o } = e,a = _objectWithoutProperties(e, _excluded12);if (So(o) && !i.customFormatTypes) return Ni(ui(n)), Fa(a, n, i, r);} else {const t = ua(e) ? "axis" : fa(e) ? "legend" : Bo(e) ? "header" : null;if (t && e[t]) {const _e$t = e[t],{ format: o, formatType: a } = _e$t,s = _objectWithoutProperties(_e$t, _excluded13);if (So(a) && !i.customFormatTypes) return Ni(ui(n)), Fa(_objectSpread(_objectSpread({}, e), {}, { [t]: s }), n, i, r);}}return ea(e) ? za(e, n, r) : function (e) {let n = e.type;if (n) return e;const { datum: i } = e;return n = t.isNumber(i) ? "quantitative" : t.isString(i) ? "nominal" : Ci(i) ? "temporal" : void 0, _objectSpread(_objectSpread({}, e), {}, { type: n });}(e);}function za(e, n) {let { compositeMark: i = !1 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};const { aggregate: r, timeUnit: o, bin: a, field: s } = e,l = _objectSpread({}, e);if (i || !r || fn(r) || un(r) || cn(r) || (Ni(function (e) {return "Invalid aggregation operator \"".concat(e, "\".");}(r)), delete l.aggregate), o && (l.timeUnit = Xi(o)), s && (l.field = "".concat(s)), yn(a) && (l.bin = Oa(a, n)), vn(a) && !Et(n) && Ni(function (e) {return "Channel ".concat(e, " should not be used with \"binned\" bin.");}(n)), sa(l)) {const { type: e } = l,t = function (e) {if (e) switch (e = e.toLowerCase()) {case "q":case mr:return "quantitative";case "t":case gr:return "temporal";case "o":case pr:return "ordinal";case "n":case hr:return "nominal";case yr:return "geojson";}}(e);e !== t && (l.type = t), "quantitative" !== e && mn(r) && (Ni(function (e, t) {return "Invalid field type \"".concat(e, "\" for aggregate: \"").concat(t, "\", using \"quantitative\" instead.");}(e, r)), l.type = "quantitative");} else if (!ct(n)) {const e = function (e, n, _e$scale) {switch (n) {case "latitude":case "longitude":return "quantitative";case "row":case "column":case "facet":case "shape":case "strokeDash":return "nominal";case "order":return "ordinal";}if (Vo(e) && t.isArray(e.sort)) return "ordinal";const { aggregate: i, bin: r, timeUnit: o } = e;if (o) return "temporal";if (r || i && !un(i) && !cn(i)) return "quantitative";if (ca(e) && (_e$scale = e.scale) !== null && _e$scale !== void 0 && _e$scale.type) switch (br[e.scale.type]) {case "numeric":case "discretizing":return "quantitative";case "time":return "temporal";}return "nominal";}(l, n);l.type = e;}if (sa(l)) {const { compatible: e, warning: t } = function (e, t, _i$scale) {const n = e.type;if ("geojson" === n && "shape" !== t) return { compatible: !1, warning: "Channel ".concat(t, " should not be used with a geojson data.") };switch (t) {case oe:case ae:case se:return ga(e) ? _a : { compatible: !1, warning: hi(t) };case le:case ce:case de:case me:case we:case ke:case Se:case Ae:case Te:case Ee:case Me:case Le:case qe:case ze:case he:case pe:case Ue:return _a;case be:case $e:case ve:case xe:return n !== mr ? { compatible: !1, warning: "Channel ".concat(t, " should be used with a quantitative field only, not ").concat(e.type, " field.") } : _a;case Oe:case _e:case Ne:case Ce:case Fe:case ye:case ge:case ue:case fe:return "nominal" !== n || e.sort ? _a : { compatible: !1, warning: "Channel ".concat(t, " should not be used with an unsorted discrete field.") };case De:case Pe:return ga(e) || ca(i = e) && Pr((_i$scale = i.scale) === null || _i$scale === void 0 ? void 0 : _i$scale.type) ? _a : { compatible: !1, warning: yi(t) };case je:return "nominal" !== e.type || "sort" in e ? _a : { compatible: !1, warning: "Channel order is inappropriate for nominal field, which has no inherent order." };}var i;}(l, n) || {};!1 === e && Ni(t);}if (Vo(l) && t.isString(l.sort)) {const { sort: e } = l;if (Lo(e)) return _objectSpread(_objectSpread({}, l), {}, { sort: { encoding: e } });const t = e.substr(1);if ("-" === e.charAt(0) && Lo(t)) return _objectSpread(_objectSpread({}, l), {}, { sort: { encoding: t, order: "descending" } });}if (Bo(l)) {const { header: e } = l;if (e) {const { orient: t } = e,n = _objectWithoutProperties(e, _excluded14);if (t) return _objectSpread(_objectSpread({}, l), {}, { header: _objectSpread(_objectSpread({}, n), {}, { labelOrient: e.labelOrient || t, titleOrient: e.titleOrient || t }) });}}return l;}function Oa(e, n) {return t.isBoolean(e) ? { maxbins: $n(n) } : "binned" === e ? { binned: !0 } : e.maxbins || e.step ? e : _objectSpread(_objectSpread({}, e), {}, { maxbins: $n(n) });}const _a = { compatible: !0 };function Na(e) {const { formatType: t } = wa(e);return "time" === t || !t && (n = e) && ("temporal" === n.type || ea(n) && !!n.timeUnit);var n;}function Ca(e, n) {var _Xi6;let { timeUnit: i, type: r, wrapTime: o, undefinedIfExprNotRequired: a } = n;const s = i && ((_Xi6 = Xi(i)) === null || _Xi6 === void 0 ? void 0 : _Xi6.unit);let l,c = s || "temporal" === r;return wn(e) ? l = e.expr : Fn(e) ? l = e.signal : Ci(e) ? (c = !0, l = Mi(e)) : (t.isString(e) || t.isNumber(e)) && c && (l = "datetime(".concat(re(e), ")"), function (e) {return !!Li[e];}(s) && (t.isNumber(e) && e < 1e4 || t.isString(e) && isNaN(Date.parse(e))) && (l = Mi({ [s]: e }))), l ? o && c ? "time(".concat(l, ")") : l : a ? void 0 : re(e);}function Pa(e, t) {const { type: n } = e;return t.map((t) => {const i = Ca(t, { timeUnit: ea(e) && !Ui(e.timeUnit) ? e.timeUnit : void 0, type: n, undefinedIfExprNotRequired: !0 });return void 0 !== i ? { signal: i } : t;});}function Aa(e, t) {return yn(e.bin) ? en(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1);}const ja = { labelAlign: { part: "labels", vgProp: "align" }, labelBaseline: { part: "labels", vgProp: "baseline" }, labelColor: { part: "labels", vgProp: "fill" }, labelFont: { part: "labels", vgProp: "font" }, labelFontSize: { part: "labels", vgProp: "fontSize" }, labelFontStyle: { part: "labels", vgProp: "fontStyle" }, labelFontWeight: { part: "labels", vgProp: "fontWeight" }, labelOpacity: { part: "labels", vgProp: "opacity" }, labelOffset: null, labelPadding: null, gridColor: { part: "grid", vgProp: "stroke" }, gridDash: { part: "grid", vgProp: "strokeDash" }, gridDashOffset: { part: "grid", vgProp: "strokeDashOffset" }, gridOpacity: { part: "grid", vgProp: "opacity" }, gridWidth: { part: "grid", vgProp: "strokeWidth" }, tickColor: { part: "ticks", vgProp: "stroke" }, tickDash: { part: "ticks", vgProp: "strokeDash" }, tickDashOffset: { part: "ticks", vgProp: "strokeDashOffset" }, tickOpacity: { part: "ticks", vgProp: "opacity" }, tickSize: null, tickWidth: { part: "ticks", vgProp: "strokeWidth" } };function Ta(e) {return e === null || e === void 0 ? void 0 : e.condition;}const Ea = ["domain", "grid", "labels", "ticks", "title"],Ma = { grid: "grid", gridCap: "grid", gridColor: "grid", gridDash: "grid", gridDashOffset: "grid", gridOpacity: "grid", gridScale: "grid", gridWidth: "grid", orient: "main", bandPosition: "both", aria: "main", description: "main", domain: "main", domainCap: "main", domainColor: "main", domainDash: "main", domainDashOffset: "main", domainOpacity: "main", domainWidth: "main", format: "main", formatType: "main", labelAlign: "main", labelAngle: "main", labelBaseline: "main", labelBound: "main", labelColor: "main", labelFlush: "main", labelFlushOffset: "main", labelFont: "main", labelFontSize: "main", labelFontStyle: "main", labelFontWeight: "main", labelLimit: "main", labelLineHeight: "main", labelOffset: "main", labelOpacity: "main", labelOverlap: "main", labelPadding: "main", labels: "main", labelSeparation: "main", maxExtent: "main", minExtent: "main", offset: "both", position: "main", tickCap: "main", tickColor: "main", tickDash: "main", tickDashOffset: "main", tickMinStep: "both", tickOffset: "both", tickOpacity: "main", tickRound: "both", ticks: "main", tickSize: "main", tickWidth: "both", title: "main", titleAlign: "main", titleAnchor: "main", titleAngle: "main", titleBaseline: "main", titleColor: "main", titleFont: "main", titleFontSize: "main", titleFontStyle: "main", titleFontWeight: "main", titleLimit: "main", titleLineHeight: "main", titleOpacity: "main", titlePadding: "main", titleX: "main", titleY: "main", encode: "both", scale: "both", tickBand: "both", tickCount: "both", tickExtra: "both", translate: "both", values: "both", zindex: "both" },La = { orient: 1, aria: 1, bandPosition: 1, description: 1, domain: 1, domainCap: 1, domainColor: 1, domainDash: 1, domainDashOffset: 1, domainOpacity: 1, domainWidth: 1, format: 1, formatType: 1, grid: 1, gridCap: 1, gridColor: 1, gridDash: 1, gridDashOffset: 1, gridOpacity: 1, gridWidth: 1, labelAlign: 1, labelAngle: 1, labelBaseline: 1, labelBound: 1, labelColor: 1, labelFlush: 1, labelFlushOffset: 1, labelFont: 1, labelFontSize: 1, labelFontStyle: 1, labelFontWeight: 1, labelLimit: 1, labelLineHeight: 1, labelOffset: 1, labelOpacity: 1, labelOverlap: 1, labelPadding: 1, labels: 1, labelSeparation: 1, maxExtent: 1, minExtent: 1, offset: 1, position: 1, tickBand: 1, tickCap: 1, tickColor: 1, tickCount: 1, tickDash: 1, tickDashOffset: 1, tickExtra: 1, tickMinStep: 1, tickOffset: 1, tickOpacity: 1, tickRound: 1, ticks: 1, tickSize: 1, tickWidth: 1, title: 1, titleAlign: 1, titleAnchor: 1, titleAngle: 1, titleBaseline: 1, titleColor: 1, titleFont: 1, titleFontSize: 1, titleFontStyle: 1, titleFontWeight: 1, titleLimit: 1, titleLineHeight: 1, titleOpacity: 1, titlePadding: 1, titleX: 1, titleY: 1, translate: 1, values: 1, zindex: 1 },qa = _objectSpread(_objectSpread({}, La), {}, { style: 1, labelExpr: 1, encoding: 1 });function Ua(e) {return !!qa[e];}const Ra = j({ axis: 1, axisBand: 1, axisBottom: 1, axisDiscrete: 1, axisLeft: 1, axisPoint: 1, axisQuantitative: 1, axisRight: 1, axisTemporal: 1, axisTop: 1, axisX: 1, axisXBand: 1, axisXDiscrete: 1, axisXPoint: 1, axisXQuantitative: 1, axisXTemporal: 1, axisY: 1, axisYBand: 1, axisYDiscrete: 1, axisYPoint: 1, axisYQuantitative: 1, axisYTemporal: 1 });function Wa(e) {return "mark" in e;}class Ba {constructor(e, t) {this.name = e, this.run = t;}hasMatchingType(e) {return !!Wa(e) && (lo(t = e.mark) ? t.type : t) === this.name;var t;}}function Ia(e, n) {const i = e && e[n];return !!i && (t.isArray(i) ? S(i, (e) => !!e.field) : ea(i) || Ko(i));}function Ha(e, n) {const i = e && e[n];return !!i && (t.isArray(i) ? S(i, (e) => !!e.field) : ea(i) || na(i) || Zo(i));}function Va(e, t) {if (Et(t)) {const n = e[t];if ((ea(n) || na(n)) && (dr(n.type) || ea(n) && n.timeUnit)) {return Ha(e, gt(t));}}return !1;}function Ga(e) {return S(Ke, (n) => {if (Ia(e, n)) {const i = e[n];if (t.isArray(i)) return S(i, (e) => !!e.aggregate);{const e = ka(i);return e && !!e.aggregate;}}return !1;});}function Ya(e, t) {const n = [],i = [],r = [],o = [],a = {};return Qa(e, (s, l) => {if (ea(s)) {const { field: c, aggregate: u, bin: f, timeUnit: d } = s,m = _objectWithoutProperties(s, _excluded15);if (u || d || f) {const e = xa(s),p = e === null || e === void 0 ? void 0 : e.title;let g = pa(s, { forAs: !0 });const h = _objectSpread(_objectSpread(_objectSpread({}, p ? [] : { title: ba(s, t, { allowDisabling: !0 }) }), m), {}, { field: g });if (u) {let e;if (un(u) ? (e = "argmax", g = pa({ op: "argmax", field: u.argmax }, { forAs: !0 }), h.field = "".concat(g, ".").concat(c)) : cn(u) ? (e = "argmin", g = pa({ op: "argmin", field: u.argmin }, { forAs: !0 }), h.field = "".concat(g, ".").concat(c)) : "boxplot" !== u && "errorbar" !== u && "errorband" !== u && (e = u), e) {const t = { op: e, as: g };c && (t.field = c), o.push(t);}} else if (n.push(g), sa(s) && yn(f)) {if (i.push({ bin: f, field: c, as: g }), n.push(pa(s, { binSuffix: "end" })), Aa(s, l) && n.push(pa(s, { binSuffix: "range" })), Et(l)) {const e = { field: "".concat(g, "_end") };a["".concat(l, "2")] = e;}h.bin = "binned", ct(l) || (h.type = mr);} else if (d && !Ui(d)) {r.push({ timeUnit: d, field: c, as: g });const e = sa(s) && s.type !== gr && "time";e && (l === Ae || l === Me ? h.formatType = e : !function (e) {return !!Pt[e];}(l) ? Et(l) && (h.axis = _objectSpread({ formatType: e }, h.axis)) : h.legend = _objectSpread({ formatType: e }, h.legend));}a[l] = h;} else n.push(c), a[l] = e[l];} else a[l] = e[l];}), { bins: i, timeUnits: r, aggregate: o, groupby: n, encoding: a };}function Xa(e, t, n) {const i = tn(t, n);if (!i) return !1;if ("binned" === i) {const n = e[t === ue ? le : ce];return !!(ea(n) && ea(e[t]) && vn(n.bin));}return !0;}function Ja(e, t) {const n = {};for (const i of j(e)) {const r = Da(e[i], i, t, { compositeMark: !0 });n[i] = r;}return n;}function Qa(e, n, i) {if (e) for (const r of j(e)) {const o = e[r];if (t.isArray(o)) for (const e of o) n.call(i, e, r);else n.call(i, o, r);}}function Ka(e, n) {return j(n).reduce((i, r) => {switch (r) {case le:case ce:case Le:case Ue:case qe:case ue:case fe:case de:case me:case he:case ye:case pe:case ge:case ve:case be:case xe:case $e:case Ae:case De:case ze:case Me:return i;case je:if ("line" === e || "trail" === e) return i;case Te:case Ee:{const e = n[r];if (t.isArray(e) || ea(e)) for (const n of t.array(e)) n.aggregate || i.push(pa(n, {}));return i;}case Fe:if ("trail" === e) return i;case we:case ke:case Se:case Oe:case _e:case Ne:case Pe:case Ce:{const e = ka(n[r]);return e && !e.aggregate && i.push(pa(e, {})), i;}}}, []);}function Za(e, n, i) {let r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];if ("tooltip" in i) return { tooltip: i.tooltip };return { tooltip: [...e.map((e) => {let { fieldPrefix: t, titlePrefix: i } = e;const o = r ? " of ".concat(es(n)) : "";return { field: t + n.field, type: n.type, title: Fn(i) ? { signal: "".concat(i, "\"").concat(escape(o), "\"") } : i + o };}), ...O(function (e) {const n = [];for (const i of j(e)) if (Ia(e, i)) {const r = e[i],o = t.array(r);for (const e of o) ea(e) ? n.push(e) : Ko(e) && n.push(e.condition);}return n;}(i).map(ma), $)] };}function es(e) {const { title: t, field: n } = e;return X(t, n);}function ts(e, n, i, r, o) {const { scale: a, axis: s } = i;return (l) => {let { partName: c, mark: u, positionPrefix: f, endPositionPrefix: d, extraEncoding: m = {} } = l;const p = es(i);return ns(e, c, o, { mark: u, encoding: _objectSpread(_objectSpread(_objectSpread({ [n]: _objectSpread(_objectSpread(_objectSpread({ field: "".concat(f, "_").concat(i.field), type: i.type }, void 0 !== p ? { title: p } : {}), void 0 !== a ? { scale: a } : {}), void 0 !== s ? { axis: s } : {}) }, t.isString(d) ? { ["".concat(n, "2")]: { field: "".concat(d, "_").concat(i.field) } } : {}), r), m) });};}function ns(e, n, i, r) {const { clip: o, color: a, opacity: s } = e,l = e.type;return e[n] || void 0 === e[n] && i[n] ? [_objectSpread(_objectSpread({}, r), {}, { mark: _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, i[n]), o ? { clip: o } : {}), a ? { color: a } : {}), s ? { opacity: s } : {}), lo(r.mark) ? r.mark : { type: r.mark }), {}, { style: "".concat(l, "-").concat(String(n)) }, t.isBoolean(e[n]) ? {} : e[n]) })] : [];}function is(e, t, n) {const { encoding: i } = e,r = "vertical" === t ? "y" : "x",o = i[r],a = i["".concat(r, "2")],s = i["".concat(r, "Error")],l = i["".concat(r, "Error2")];return { continuousAxisChannelDef: rs(o, n), continuousAxisChannelDef2: rs(a, n), continuousAxisChannelDefError: rs(s, n), continuousAxisChannelDefError2: rs(l, n), continuousAxis: r };}function rs(e, t) {if (e !== null && e !== void 0 && e.aggregate) {const { aggregate: n } = e,i = _objectWithoutProperties(e, _excluded16);return n !== t && Ni(function (e, t) {return "Continuous axis should not have customized aggregation function ".concat(e, "; ").concat(t, " already agregates the axis.");}(n, t)), i;}return e;}function os(e, t) {const { mark: n, encoding: i } = e,{ x: r, y: o } = i;if (lo(n) && n.orient) return n.orient;if (ia(r)) {if (ia(o)) {const e = ea(r) && r.aggregate,n = ea(o) && o.aggregate;if (e || n !== t) {if (n || e !== t) {if (e === t && n === t) throw new Error("Both x and y cannot have aggregate");return Na(o) && !Na(r) ? "horizontal" : "vertical";}return "horizontal";}return "vertical";}return "horizontal";}if (ia(o)) return "vertical";throw new Error("Need a valid continuous axis for ".concat(t, "s"));}const as = "boxplot",ss = new Ba(as, cs);function ls(e) {return t.isNumber(e) ? "tukey" : e;}function cs(e, n) {var _c$extent, _l$transform;let { config: i } = n;e = _objectSpread(_objectSpread({}, e), {}, { encoding: Ja(e.encoding, i) });const { mark: r, encoding: o, params: a, projection: s } = e,l = _objectWithoutProperties(e, _excluded17),c = lo(r) ? r : { type: r };a && Ni(ai("boxplot"));const u = (_c$extent = c.extent) !== null && _c$extent !== void 0 ? _c$extent : i.boxplot.extent,f = Un("size", c, i),d = c.invalid,m = ls(u),{ bins: p, timeUnits: g, transform: h, continuousAxisChannelDef: y, continuousAxis: v, groupby: b, aggregate: $, encodingWithoutContinuousAxis: w, ticksOrient: k, boxOrient: S, customTooltipWithoutAggregatedField: D } = function (e, n, i) {const r = os(e, as),{ continuousAxisChannelDef: o, continuousAxis: a } = is(e, r, as),s = o.field,l = ls(n),c = [...us(s), { op: "median", field: s, as: "mid_box_".concat(s) }, { op: "min", field: s, as: ("min-max" === l ? "lower_whisker_" : "min_") + s }, { op: "max", field: s, as: ("min-max" === l ? "upper_whisker_" : "max_") + s }],u = "min-max" === l || "tukey" === l ? [] : [{ calculate: "datum[\"upper_box_".concat(s, "\"] - datum[\"lower_box_").concat(s, "\"]"), as: "iqr_".concat(s) }, { calculate: "min(datum[\"upper_box_".concat(s, "\"] + datum[\"iqr_").concat(s, "\"] * ").concat(n, ", datum[\"max_").concat(s, "\"])"), as: "upper_whisker_".concat(s) }, { calculate: "max(datum[\"lower_box_".concat(s, "\"] - datum[\"iqr_").concat(s, "\"] * ").concat(n, ", datum[\"min_").concat(s, "\"])"), as: "lower_whisker_".concat(s) }],_e$encoding = e.encoding,{ [a]: f } = _e$encoding,d = _objectWithoutProperties(_e$encoding, [a].map(_toPropertyKey)),{ customTooltipWithoutAggregatedField: m, filteredEncoding: p } = function (e) {const { tooltip: n } = e,i = _objectWithoutProperties(e, _excluded18);if (!n) return { filteredEncoding: i };let r, o;if (t.isArray(n)) {for (const e of n) e.aggregate ? (r || (r = []), r.push(e)) : (o || (o = []), o.push(e));r && (i.tooltip = r);} else n.aggregate ? i.tooltip = n : o = n;return t.isArray(o) && 1 === o.length && (o = o[0]), { customTooltipWithoutAggregatedField: o, filteredEncoding: i };}(d),{ bins: g, timeUnits: h, aggregate: y, groupby: v, encoding: b } = Ya(p, i),x = "vertical" === r ? "horizontal" : "vertical",$ = r,w = [...g, ...h, { aggregate: [...y, ...c], groupby: v }, ...u];return { bins: g, timeUnits: h, transform: w, groupby: v, aggregate: y, continuousAxisChannelDef: o, continuousAxis: a, encodingWithoutContinuousAxis: b, ticksOrient: x, boxOrient: $, customTooltipWithoutAggregatedField: m };}(e, u, i),{ color: F, size: z } = w,O = _objectWithoutProperties(w, _excluded19),_ = (e) => ts(c, v, y, e, i.boxplot),N = _(O),C = _(w),P = _(_objectSpread(_objectSpread({}, O), z ? { size: z } : {})),j = Za([{ fieldPrefix: "min-max" === m ? "upper_whisker_" : "max_", titlePrefix: "Max" }, { fieldPrefix: "upper_box_", titlePrefix: "Q3" }, { fieldPrefix: "mid_box_", titlePrefix: "Median" }, { fieldPrefix: "lower_box_", titlePrefix: "Q1" }, { fieldPrefix: "min-max" === m ? "lower_whisker_" : "min_", titlePrefix: "Min" }], y, w),T = { type: "tick", color: "black", opacity: 1, orient: k, invalid: d, aria: !1 },E = "min-max" === m ? j : Za([{ fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" }, { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }], y, w),M = [...N({ partName: "rule", mark: { type: "rule", invalid: d, aria: !1 }, positionPrefix: "lower_whisker", endPositionPrefix: "lower_box", extraEncoding: E }), ...N({ partName: "rule", mark: { type: "rule", invalid: d, aria: !1 }, positionPrefix: "upper_box", endPositionPrefix: "upper_whisker", extraEncoding: E }), ...N({ partName: "ticks", mark: T, positionPrefix: "lower_whisker", extraEncoding: E }), ...N({ partName: "ticks", mark: T, positionPrefix: "upper_whisker", extraEncoding: E })],L = [...("tukey" !== m ? M : []), ...C({ partName: "box", mark: _objectSpread(_objectSpread({ type: "bar" }, f ? { size: f } : {}), {}, { orient: S, invalid: d, ariaRoleDescription: "box" }), positionPrefix: "lower_box", endPositionPrefix: "upper_box", extraEncoding: j }), ...P({ partName: "median", mark: _objectSpread(_objectSpread(_objectSpread({ type: "tick", invalid: d }, t.isObject(i.boxplot.median) && i.boxplot.median.color ? { color: i.boxplot.median.color } : {}), f ? { size: f } : {}), {}, { orient: k, aria: !1 }), positionPrefix: "mid_box", extraEncoding: j })];if ("min-max" === m) return _objectSpread(_objectSpread({}, l), {}, { transform: ((_l$transform = l.transform) !== null && _l$transform !== void 0 ? _l$transform : []).concat(h), layer: L });const q = "datum[\"lower_box_".concat(y.field, "\"]"),U = "datum[\"upper_box_".concat(y.field, "\"]"),R = "(".concat(U, " - ").concat(q, ")"),W = "".concat(q, " - ").concat(u, " * ").concat(R),B = "".concat(U, " + ").concat(u, " * ").concat(R),I = "datum[\"".concat(y.field, "\"]"),H = { joinaggregate: us(y.field), groupby: b },V = { transform: [{ filter: "(".concat(W, " <= ").concat(I, ") && (").concat(I, " <= ").concat(B, ")") }, { aggregate: [{ op: "min", field: y.field, as: "lower_whisker_".concat(y.field) }, { op: "max", field: y.field, as: "upper_whisker_".concat(y.field) }, { op: "min", field: "lower_box_".concat(y.field), as: "lower_box_".concat(y.field) }, { op: "max", field: "upper_box_".concat(y.field), as: "upper_box_".concat(y.field) }, ...$], groupby: b }], layer: M },{ tooltip: G } = O,Y = _objectWithoutProperties(O, _excluded20),{ scale: X, axis: J } = y,Q = es(y),K = x(J, ["title"]),Z = ns(c, "outliers", i.boxplot, { transform: [{ filter: "(".concat(I, " < ").concat(W, ") || (").concat(I, " > ").concat(B, ")") }], mark: "point", encoding: _objectSpread(_objectSpread(_objectSpread({ [v]: _objectSpread(_objectSpread(_objectSpread({ field: y.field, type: y.type }, void 0 !== Q ? { title: Q } : {}), void 0 !== X ? { scale: X } : {}), A(K) ? {} : { axis: K }) }, Y), F ? { color: F } : {}), D ? { tooltip: D } : {}) })[0];let ee;const te = [...p, ...g, H];return Z ? ee = { transform: te, layer: [Z, V] } : (ee = V, ee.transform.unshift(...te)), _objectSpread(_objectSpread({}, l), {}, { layer: [ee, { transform: h, layer: L }] });}function us(e) {return [{ op: "q1", field: e, as: "lower_box_".concat(e) }, { op: "q3", field: e, as: "upper_box_".concat(e) }];}const fs = "errorbar",ds = new Ba(fs, ms);function ms(e, t) {let { config: n } = t;e = _objectSpread(_objectSpread({}, e), {}, { encoding: Ja(e.encoding, n) });const { transform: i, continuousAxisChannelDef: r, continuousAxis: o, encodingWithoutContinuousAxis: a, ticksOrient: s, markDef: l, outerSpec: c, tooltipEncoding: u } = gs(e, fs, n);delete a.size;const f = ts(l, o, r, a, n.errorbar),d = l.thickness,m = l.size,p = _objectSpread(_objectSpread({ type: "tick", orient: s, aria: !1 }, void 0 !== d ? { thickness: d } : {}), void 0 !== m ? { size: m } : {}),g = [...f({ partName: "ticks", mark: p, positionPrefix: "lower", extraEncoding: u }), ...f({ partName: "ticks", mark: p, positionPrefix: "upper", extraEncoding: u }), ...f({ partName: "rule", mark: _objectSpread({ type: "rule", ariaRoleDescription: "errorbar" }, void 0 !== d ? { size: d } : {}), positionPrefix: "lower", endPositionPrefix: "upper", extraEncoding: u })];return _objectSpread(_objectSpread({}, c), {}, { transform: i }, g.length > 1 ? { layer: g } : _objectSpread({}, g[0]));}function ps(e, t) {const { encoding: n } = e;if (function (e) {return (aa(e.x) || aa(e.y)) && !aa(e.x2) && !aa(e.y2) && !aa(e.xError) && !aa(e.xError2) && !aa(e.yError) && !aa(e.yError2);}(n)) return { orient: os(e, t), inputType: "raw" };const i = function (e) {return aa(e.x2) || aa(e.y2);}(n),r = function (e) {return aa(e.xError) || aa(e.xError2) || aa(e.yError) || aa(e.yError2);}(n),o = n.x,a = n.y;if (i) {if (r) throw new Error("".concat(t, " cannot be both type aggregated-upper-lower and aggregated-error"));const e = n.x2,i = n.y2;if (aa(e) && aa(i)) throw new Error("".concat(t, " cannot have both x2 and y2"));if (aa(e)) {if (ia(o)) return { orient: "horizontal", inputType: "aggregated-upper-lower" };throw new Error("Both x and x2 have to be quantitative in ".concat(t));}if (aa(i)) {if (ia(a)) return { orient: "vertical", inputType: "aggregated-upper-lower" };throw new Error("Both y and y2 have to be quantitative in ".concat(t));}throw new Error("No ranged axis");}{const e = n.xError,i = n.xError2,r = n.yError,s = n.yError2;if (aa(i) && !aa(e)) throw new Error("".concat(t, " cannot have xError2 without xError"));if (aa(s) && !aa(r)) throw new Error("".concat(t, " cannot have yError2 without yError"));if (aa(e) && aa(r)) throw new Error("".concat(t, " cannot have both xError and yError with both are quantiative"));if (aa(e)) {if (ia(o)) return { orient: "horizontal", inputType: "aggregated-error" };throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");}if (aa(r)) {if (ia(a)) return { orient: "vertical", inputType: "aggregated-error" };throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");}throw new Error("No ranged axis");}}function gs(e, t, n) {var _s$transform;const { mark: i, encoding: r, params: o, projection: a } = e,s = _objectWithoutProperties(e, _excluded21),l = lo(i) ? i : { type: i };o && Ni(ai(t));const { orient: c, inputType: u } = ps(e, t),{ continuousAxisChannelDef: f, continuousAxisChannelDef2: d, continuousAxisChannelDefError: m, continuousAxisChannelDefError2: p, continuousAxis: g } = is(e, c, t),{ errorBarSpecificAggregate: h, postAggregateCalculates: y, tooltipSummary: v, tooltipTitleWithFieldName: b } = function (e, t, n, i, r, o, a, s) {let l = [],c = [];const u = t.field;let f,d = !1;if ("raw" === o) {const t = e.center ? e.center : e.extent ? "iqr" === e.extent ? "median" : "mean" : s.errorbar.center,n = e.extent ? e.extent : "mean" === t ? "stderr" : "iqr";if ("median" === t != ("iqr" === n) && Ni(function (e, t, n) {return "".concat(e, " is not usually used with ").concat(t, " for ").concat(n, ".");}(t, n, a)), "stderr" === n || "stdev" === n) l = [{ op: n, field: u, as: "extent_".concat(u) }, { op: t, field: u, as: "center_".concat(u) }], c = [{ calculate: "datum[\"center_".concat(u, "\"] + datum[\"extent_").concat(u, "\"]"), as: "upper_".concat(u) }, { calculate: "datum[\"center_".concat(u, "\"] - datum[\"extent_").concat(u, "\"]"), as: "lower_".concat(u) }], f = [{ fieldPrefix: "center_", titlePrefix: R(t) }, { fieldPrefix: "upper_", titlePrefix: hs(t, n, "+") }, { fieldPrefix: "lower_", titlePrefix: hs(t, n, "-") }], d = !0;else {let e, t, i;"ci" === n ? (e = "mean", t = "ci0", i = "ci1") : (e = "median", t = "q1", i = "q3"), l = [{ op: t, field: u, as: "lower_".concat(u) }, { op: i, field: u, as: "upper_".concat(u) }, { op: e, field: u, as: "center_".concat(u) }], f = [{ fieldPrefix: "upper_", titlePrefix: ba({ field: u, aggregate: i, type: "quantitative" }, s, { allowDisabling: !1 }) }, { fieldPrefix: "lower_", titlePrefix: ba({ field: u, aggregate: t, type: "quantitative" }, s, { allowDisabling: !1 }) }, { fieldPrefix: "center_", titlePrefix: ba({ field: u, aggregate: e, type: "quantitative" }, s, { allowDisabling: !1 }) }];}} else {(e.center || e.extent) && Ni((m = e.center, "".concat((p = e.extent) ? "extent " : "").concat(p && m ? "and " : "").concat(m ? "center " : "").concat(p && m ? "are " : "is ", "not needed when data are aggregated."))), "aggregated-upper-lower" === o ? (f = [], c = [{ calculate: "datum[\"".concat(n.field, "\"]"), as: "upper_".concat(u) }, { calculate: "datum[\"".concat(u, "\"]"), as: "lower_".concat(u) }]) : "aggregated-error" === o && (f = [{ fieldPrefix: "", titlePrefix: u }], c = [{ calculate: "datum[\"".concat(u, "\"] + datum[\"").concat(i.field, "\"]"), as: "upper_".concat(u) }], r ? c.push({ calculate: "datum[\"".concat(u, "\"] + datum[\"").concat(r.field, "\"]"), as: "lower_".concat(u) }) : c.push({ calculate: "datum[\"".concat(u, "\"] - datum[\"").concat(i.field, "\"]"), as: "lower_".concat(u) }));for (const e of c) f.push({ fieldPrefix: e.as.substring(0, 6), titlePrefix: V(V(e.calculate, 'datum["', ""), '"]', "") });}var m, p;return { postAggregateCalculates: c, errorBarSpecificAggregate: l, tooltipSummary: f, tooltipTitleWithFieldName: d };}(l, f, d, m, p, u, t, n),_ref4 = "x" === g ? "x2" : "y2",_ref5 = "x" === g ? "xError" : "yError",_ref6 = "x" === g ? "xError2" : "yError2",{ [g]: x, [_ref4]: $, [_ref5]: w, [_ref6]: k } = r,S = _objectWithoutProperties(r, [g, _ref4, _ref5, _ref6].map(_toPropertyKey)),{ bins: D, timeUnits: F, aggregate: z, groupby: O, encoding: _ } = Ya(S, n),N = [...z, ...h],C = "raw" !== u ? [] : O,P = Za(v, f, _, b);return { transform: [...((_s$transform = s.transform) !== null && _s$transform !== void 0 ? _s$transform : []), ...D, ...F, ...(0 === N.length ? [] : [{ aggregate: N, groupby: C }]), ...y], groupby: C, continuousAxisChannelDef: f, continuousAxis: g, encodingWithoutContinuousAxis: _, ticksOrient: "vertical" === c ? "horizontal" : "vertical", markDef: l, outerSpec: s, tooltipEncoding: P };}function hs(e, t, n) {return "".concat(R(e), " ").concat(n, " ").concat(t);}const ys = "errorband",vs = new Ba(ys, bs);function bs(e, t) {let { config: n } = t;e = _objectSpread(_objectSpread({}, e), {}, { encoding: Ja(e.encoding, n) });const { transform: i, continuousAxisChannelDef: r, continuousAxis: o, encodingWithoutContinuousAxis: a, markDef: s, outerSpec: l, tooltipEncoding: c } = gs(e, ys, n),u = s,f = ts(u, o, r, a, n.errorband),d = void 0 !== e.encoding.x && void 0 !== e.encoding.y;let m = { type: d ? "area" : "rect" },p = { type: d ? "line" : "rule" };const g = _objectSpread(_objectSpread({}, u.interpolate ? { interpolate: u.interpolate } : {}), u.tension && u.interpolate ? { tension: u.tension } : {});return d ? (m = _objectSpread(_objectSpread(_objectSpread({}, m), g), {}, { ariaRoleDescription: "errorband" }), p = _objectSpread(_objectSpread(_objectSpread({}, p), g), {}, { aria: !1 })) : u.interpolate ? Ni(Fi("interpolate")) : u.tension && Ni(Fi("tension")), _objectSpread(_objectSpread({}, l), {}, { transform: i, layer: [...f({ partName: "band", mark: m, positionPrefix: "lower", endPositionPrefix: "upper", extraEncoding: c }), ...f({ partName: "borders", mark: p, positionPrefix: "lower", extraEncoding: c }), ...f({ partName: "borders", mark: p, positionPrefix: "upper", extraEncoding: c })] });}const xs = {};function $s(e, t, n) {const i = new Ba(e, t);xs[e] = { normalizer: i, parts: n };}$s(as, cs, ["box", "median", "outliers", "rule", "ticks"]), $s(fs, ms, ["ticks", "rule"]), $s(ys, bs, ["band", "borders"]);const ws = ["gradientHorizontalMaxLength", "gradientHorizontalMinLength", "gradientVerticalMaxLength", "gradientVerticalMinLength", "unselectedOpacity"],ks = { titleAlign: "align", titleAnchor: "anchor", titleAngle: "angle", titleBaseline: "baseline", titleColor: "color", titleFont: "font", titleFontSize: "fontSize", titleFontStyle: "fontStyle", titleFontWeight: "fontWeight", titleLimit: "limit", titleLineHeight: "lineHeight", titleOrient: "orient", titlePadding: "offset" },Ss = { labelAlign: "align", labelAnchor: "anchor", labelAngle: "angle", labelBaseline: "baseline", labelColor: "color", labelFont: "font", labelFontSize: "fontSize", labelFontStyle: "fontStyle", labelFontWeight: "fontWeight", labelLimit: "limit", labelLineHeight: "lineHeight", labelOrient: "orient", labelPadding: "offset" },Ds = j(ks),Fs = j(Ss),zs = j({ header: 1, headerRow: 1, headerColumn: 1, headerFacet: 1 }),Os = ["size", "shape", "fill", "stroke", "strokeDash", "strokeWidth", "opacity"],_s = "_vgsid_",Ns = { point: { on: "click", fields: [_s], toggle: "event.shiftKey", resolve: "global", clear: "dblclick" }, interval: { on: "[pointerdown, window:pointerup] > window:pointermove!", encodings: ["x", "y"], translate: "[pointerdown, window:pointerup] > window:pointermove!", zoom: "wheel!", mark: { fill: "#333", fillOpacity: .125, stroke: "white" }, resolve: "global", clear: "dblclick" } };function Cs(e) {return "legend" === e || !!(e !== null && e !== void 0 && e.legend);}function Ps(e) {return Cs(e) && t.isObject(e);}function As(e) {return !!(e !== null && e !== void 0 && e.select);}function js(e) {const t = [];for (const n of e || []) {if (As(n)) continue;const { expr: e, bind: i } = n,r = _objectWithoutProperties(n, _excluded22);if (i && e) {const n = _objectSpread(_objectSpread({}, r), {}, { bind: i, init: e });t.push(n);} else {const n = _objectSpread(_objectSpread(_objectSpread({}, r), e ? { update: e } : {}), i ? { bind: i } : {});t.push(n);}}return t;}function Ts(e) {return "concat" in e;}function Es(e) {return "vconcat" in e;}function Ms(e) {return "hconcat" in e;}function Ls(e) {var _t$for;let { step: t, offsetIsDiscrete: n } = e;return n ? (_t$for = t.for) !== null && _t$for !== void 0 ? _t$for : "offset" : "position";}function qs(e) {return t.isObject(e) && void 0 !== e.step;}function Us(e) {return e.view || e.width || e.height;}const Rs = j({ align: 1, bounds: 1, center: 1, columns: 1, spacing: 1 });function Ws(e, t) {var _e$t2;return (_e$t2 = e[t]) !== null && _e$t2 !== void 0 ? _e$t2 : e["width" === t ? "continuousWidth" : "continuousHeight"];}function Bs(e, t) {const n = Is(e, t);return qs(n) ? n.step : Hs;}function Is(e, t) {var _e$t3;return X((_e$t3 = e[t]) !== null && _e$t3 !== void 0 ? _e$t3 : e["width" === t ? "discreteWidth" : "discreteHeight"], { step: e.step });}const Hs = 20,Vs = { background: "white", padding: 5, timeFormat: "%b %d, %Y", countTitle: "Count of Records", view: { continuousWidth: 200, continuousHeight: 200, step: Hs }, mark: { color: "#4c78a8", invalid: "filter", timeUnitBandSize: 1 }, arc: {}, area: {}, bar: go, circle: {}, geoshape: {}, image: {}, line: {}, point: {}, rect: ho, rule: { color: "black" }, square: {}, text: { color: "black" }, tick: { thickness: 1 }, trail: {}, boxplot: { size: 14, extent: 1.5, box: {}, median: { color: "white" }, outliers: {}, rule: {}, ticks: null }, errorbar: { center: "mean", rule: !0, ticks: !1 }, errorband: { band: { opacity: .3 }, borders: !1 }, scale: { pointPadding: .5, barBandPaddingInner: .1, rectBandPaddingInner: 0, bandWithNestedOffsetPaddingInner: .2, bandWithNestedOffsetPaddingOuter: .2, minBandSize: 2, minFontSize: 8, maxFontSize: 40, minOpacity: .3, maxOpacity: .8, minSize: 9, minStrokeWidth: 1, maxStrokeWidth: 4, quantileCount: 4, quantizeCount: 4, zero: !0 }, projection: {}, legend: { gradientHorizontalMaxLength: 200, gradientHorizontalMinLength: 100, gradientVerticalMaxLength: 200, gradientVerticalMinLength: 64, unselectedOpacity: .35 }, header: { titlePadding: 10, labelPadding: 10 }, headerColumn: {}, headerRow: {}, headerFacet: {}, selection: Ns, style: {}, title: {}, facet: { spacing: 20 }, concat: { spacing: 20 }, normalizedNumberFormat: ".0%" },Gs = ["#4c78a8", "#f58518", "#e45756", "#72b7b2", "#54a24b", "#eeca3b", "#b279a2", "#ff9da6", "#9d755d", "#bab0ac"],Ys = { text: 11, guideLabel: 10, guideTitle: 11, groupTitle: 13, groupSubtitle: 12 },Xs = { blue: Gs[0], orange: Gs[1], red: Gs[2], teal: Gs[3], green: Gs[4], yellow: Gs[5], purple: Gs[6], pink: Gs[7], brown: Gs[8], gray0: "#000", gray1: "#111", gray2: "#222", gray3: "#333", gray4: "#444", gray5: "#555", gray6: "#666", gray7: "#777", gray8: "#888", gray9: "#999", gray10: "#aaa", gray11: "#bbb", gray12: "#ccc", gray13: "#ddd", gray14: "#eee", gray15: "#fff" };function Js(e) {const t = j(e || {}),n = {};for (const i of t) {const t = e[i];n[i] = Ta(t) ? Pn(t) : An(t);}return n;}const Qs = [...fo, ...Ra, ...zs, "background", "padding", "legend", "lineBreak", "scale", "style", "title", "view"];function Ks() {let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};const { color: n, font: i, fontSize: r, selection: o } = e,a = _objectWithoutProperties(e, _excluded23),s = t.mergeConfig({}, y(Vs), i ? function (e) {return { text: { font: e }, style: { "guide-label": { font: e }, "guide-title": { font: e }, "group-title": { font: e }, "group-subtitle": { font: e } } };}(i) : {}, n ? function () {let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};return { signals: [{ name: "color", value: t.isObject(e) ? _objectSpread(_objectSpread({}, Xs), e) : Xs }], mark: { color: { signal: "color.blue" } }, rule: { color: { signal: "color.gray0" } }, text: { color: { signal: "color.gray0" } }, style: { "guide-label": { fill: { signal: "color.gray0" } }, "guide-title": { fill: { signal: "color.gray0" } }, "group-title": { fill: { signal: "color.gray0" } }, "group-subtitle": { fill: { signal: "color.gray0" } }, cell: { stroke: { signal: "color.gray8" } } }, axis: { domainColor: { signal: "color.gray13" }, gridColor: { signal: "color.gray8" }, tickColor: { signal: "color.gray13" } }, range: { category: [{ signal: "color.blue" }, { signal: "color.orange" }, { signal: "color.red" }, { signal: "color.teal" }, { signal: "color.green" }, { signal: "color.yellow" }, { signal: "color.purple" }, { signal: "color.pink" }, { signal: "color.brown" }, { signal: "color.grey8" }] } };}(n) : {}, r ? function (e) {return { signals: [{ name: "fontSize", value: t.isObject(e) ? _objectSpread(_objectSpread({}, Ys), e) : Ys }], text: { fontSize: { signal: "fontSize.text" } }, style: { "guide-label": { fontSize: { signal: "fontSize.guideLabel" } }, "guide-title": { fontSize: { signal: "fontSize.guideTitle" } }, "group-title": { fontSize: { signal: "fontSize.groupTitle" } }, "group-subtitle": { fontSize: { signal: "fontSize.groupSubtitle" } } } };}(r) : {}, a || {});o && t.writeConfig(s, "selection", o, !0);const l = x(s, Qs);for (const e of ["background", "lineBreak", "padding"]) s[e] && (l[e] = An(s[e]));for (const e of fo) s[e] && (l[e] = kn(s[e]));for (const e of Ra) s[e] && (l[e] = Js(s[e]));for (const e of zs) s[e] && (l[e] = kn(s[e]));return s.legend && (l.legend = kn(s.legend)), s.scale && (l.scale = kn(s.scale)), s.style && (l.style = function (e) {const t = j(e),n = {};for (const i of t) n[i] = Js(e[i]);return n;}(s.style)), s.title && (l.title = kn(s.title)), s.view && (l.view = kn(s.view)), l;}const Zs = new Set(["view", ...so]),el = ["color", "fontSize", "background", "padding", "facet", "concat", "numberFormat", "numberFormatType", "normalizedNumberFormat", "normalizedNumberFormatType", "timeFormat", "countTitle", "header", "axisQuantitative", "axisTemporal", "axisDiscrete", "axisPoint", "axisXBand", "axisXPoint", "axisXDiscrete", "axisXQuantitative", "axisXTemporal", "axisYBand", "axisYPoint", "axisYDiscrete", "axisYQuantitative", "axisYTemporal", "scale", "selection", "overlay"],tl = { view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"], area: ["line", "point"], bar: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"], rect: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"], line: ["point"], tick: ["bandSize", "thickness"] };function nl(e) {e = y(e);for (const t of el) delete e[t];if (e.axis) for (const t in e.axis) Ta(e.axis[t]) && delete e.axis[t];if (e.legend) for (const t of ws) delete e.legend[t];if (e.mark) {for (const t of uo) delete e.mark[t];e.mark.tooltip && t.isObject(e.mark.tooltip) && delete e.mark.tooltip;}e.params && (e.signals = (e.signals || []).concat(js(e.params)), delete e.params);for (const t of Zs) {for (const n of uo) delete e[t][n];const n = tl[t];if (n) for (const i of n) delete e[t][i];il(e, t);}for (const t of j(xs)) delete e[t];!function (e) {const { titleMarkConfig: t, subtitleMarkConfig: n, subtitle: i } = Sn(e.title);A(t) || (e.style["group-title"] = _objectSpread(_objectSpread({}, e.style["group-title"]), t));A(n) || (e.style["group-subtitle"] = _objectSpread(_objectSpread({}, e.style["group-subtitle"]), n));A(i) ? delete e.title : e.title = i;}(e);for (const n in e) t.isObject(e[n]) && A(e[n]) && delete e[n];return A(e) ? void 0 : e;}function il(e, t, n, i) {var _n2, _n3;"view" === t && (n = "cell");const r = _objectSpread(_objectSpread({}, i ? e[t][i] : e[t]), e.style[(_n2 = n) !== null && _n2 !== void 0 ? _n2 : t]);A(r) || (e.style[(_n3 = n) !== null && _n3 !== void 0 ? _n3 : t] = r), i || delete e[t];}function rl(e) {return "layer" in e;}class ol {map(e, t) {return Io(e) ? this.mapFacet(e, t) : function (e) {return "repeat" in e;}(e) ? this.mapRepeat(e, t) : Ms(e) ? this.mapHConcat(e, t) : Es(e) ? this.mapVConcat(e, t) : Ts(e) ? this.mapConcat(e, t) : this.mapLayerOrUnit(e, t);}mapLayerOrUnit(e, t) {if (rl(e)) return this.mapLayer(e, t);if (Wa(e)) return this.mapUnit(e, t);throw new Error(Kn(e));}mapLayer(e, t) {return _objectSpread(_objectSpread({}, e), {}, { layer: e.layer.map((e) => this.mapLayerOrUnit(e, t)) });}mapHConcat(e, t) {return _objectSpread(_objectSpread({}, e), {}, { hconcat: e.hconcat.map((e) => this.map(e, t)) });}mapVConcat(e, t) {return _objectSpread(_objectSpread({}, e), {}, { vconcat: e.vconcat.map((e) => this.map(e, t)) });}mapConcat(e, t) {const { concat: n } = e,i = _objectWithoutProperties(e, _excluded24);return _objectSpread(_objectSpread({}, i), {}, { concat: n.map((e) => this.map(e, t)) });}mapFacet(e, t) {return _objectSpread(_objectSpread({}, e), {}, { spec: this.map(e.spec, t) });}mapRepeat(e, t) {return _objectSpread(_objectSpread({}, e), {}, { spec: this.map(e.spec, t) });}}const al = { zero: 1, center: 1, normalize: 1 };const sl = new Set([Hr, Gr, Vr, Kr, Jr, no, io, Xr, Zr, eo]),ll = new Set([Gr, Vr, Hr]);function cl(e) {return ea(e) && "quantitative" === ta(e) && !e.bin;}function ul(e, t, n) {let { orient: i, type: r } = n;const o = "x" === t ? "y" : "radius",a = "x" === t && ["bar", "area"].includes(r),s = e[t],l = e[o];if (ea(s) && ea(l)) {if (cl(s) && cl(l)) {if (s.stack) return t;if (l.stack) return o;const e = ea(s) && !!s.aggregate;if (e !== (ea(l) && !!l.aggregate)) return e ? t : o;if (a) {if ("vertical" === i) return o;if ("horizontal" === i) return t;}} else {if (cl(s)) return t;if (cl(l)) return o;}} else {if (cl(s)) {if (a && "vertical" === i) return;return t;}if (cl(l)) {if (a && "horizontal" === i) return;return o;}}}function fl(e, n) {var _a$scale, _a$scale2;const i = lo(e) ? e : { type: e },r = i.type;if (!sl.has(r)) return null;const o = ul(n, "x", i) || ul(n, "theta", i);if (!o) return null;const a = n[o],s = ea(a) ? pa(a, {}) : void 0,l = function (e) {switch (e) {case "x":return "y";case "y":return "x";case "theta":return "radius";case "radius":return "theta";}}(o),c = [],u = new Set();if (n[l]) {const e = n[l],t = ea(e) ? pa(e, {}) : void 0;t && t !== s && (c.push(l), u.add(t));}const f = "x" === l ? "xOffset" : "yOffset",d = n[f],m = ea(d) ? pa(d, {}) : void 0;m && m !== s && (c.push(f), u.add(m));const p = At.reduce((e, i) => {if ("tooltip" !== i && Ia(n, i)) {const r = n[i];for (const n of t.array(r)) {const t = ka(n);if (t.aggregate) continue;const r = pa(t, {});r && u.has(r) || e.push({ channel: i, fieldDef: t });}}return e;}, []);let g;return void 0 !== a.stack ? g = t.isBoolean(a.stack) ? a.stack ? "zero" : null : a.stack : ll.has(r) && (g = "zero"), g && g in al ? Ga(n) && 0 === p.length ? null : a !== null && a !== void 0 && (_a$scale = a.scale) !== null && _a$scale !== void 0 && _a$scale.type && (a === null || a === void 0 || (_a$scale2 = a.scale) === null || _a$scale2 === void 0 ? void 0 : _a$scale2.type) !== vr.LINEAR ? (a !== null && a !== void 0 && a.stack && Ni(function (e) {return "Cannot stack non-linear scale (".concat(e, ").");}(a.scale.type)), null) : aa(n[dt(o)]) ? (void 0 !== a.stack && Ni("Cannot stack \"".concat(h = o, "\" if there is already \"").concat(h, "2\".")), null) : (ea(a) && a.aggregate && !pn.has(a.aggregate) && Ni("Stacking is applied even though the aggregate function is non-summative (\"".concat(a.aggregate, "\").")), { groupbyChannels: c, groupbyFields: u, fieldChannel: o, impute: null !== a.impute && oo(r), stackBy: p, offset: g }) : null;var h;}function dl(e, t, n) {const i = kn(e),r = Un("orient", i, n);if (i.orient = function (e, t, n) {switch (e) {case Jr:case no:case io:case Zr:case Qr:case Yr:return;}const { x: i, y: r, x2: o, y2: a } = t;switch (e) {case Gr:if (ea(i) && (vn(i.bin) || ea(r) && r.aggregate && !i.aggregate)) return "vertical";if (ea(r) && (vn(r.bin) || ea(i) && i.aggregate && !r.aggregate)) return "horizontal";if (a || o) {if (n) return n;if (!o) return (ea(i) && i.type === mr && !yn(i.bin) || oa(i)) && ea(r) && vn(r.bin) ? "horizontal" : "vertical";if (!a) return (ea(r) && r.type === mr && !yn(r.bin) || oa(r)) && ea(i) && vn(i.bin) ? "vertical" : "horizontal";}case Kr:if (o && (!ea(i) || !vn(i.bin)) && a && (!ea(r) || !vn(r.bin))) return;case Vr:if (a) return ea(r) && vn(r.bin) ? "horizontal" : "vertical";if (o) return ea(i) && vn(i.bin) ? "vertical" : "horizontal";if (e === Kr) {if (i && !r) return "vertical";if (r && !i) return "horizontal";}case Xr:case eo:{const t = ra(i),o = ra(r);if (n) return n;if (t && !o) return "tick" !== e ? "horizontal" : "vertical";if (!t && o) return "tick" !== e ? "vertical" : "horizontal";if (t && o) return "vertical";{const e = sa(i) && i.type === gr,t = sa(r) && r.type === gr;if (e && !t) return "vertical";if (!e && t) return "horizontal";}return;}}return "vertical";}(i.type, t, r), void 0 !== r && r !== i.orient && Ni("Specified orient \"".concat(i.orient, "\" overridden with \"").concat(r, "\".")), "bar" === i.type && i.orient) {const e = Un("cornerRadiusEnd", i, n);if (void 0 !== e) {const n = "horizontal" === i.orient && t.x2 || "vertical" === i.orient && t.y2 ? ["cornerRadius"] : po[i.orient];for (const t of n) i[t] = e;void 0 !== i.cornerRadiusEnd && delete i.cornerRadiusEnd;}}void 0 === Un("opacity", i, n) && (i.opacity = function (e, t) {if (k([Jr, eo, no, io], e) && !Ga(t)) return .7;return;}(i.type, t));return void 0 === Un("cursor", i, n) && (i.cursor = function (e, t, n) {if (t.href || e.href || Un("href", e, n)) return "pointer";return e.cursor;}(i, t, n)), i;}function ml(e) {const { point: t, line: n } = e,i = _objectWithoutProperties(e, _excluded25);return j(i).length > 1 ? i : i.type;}function pl(e) {for (const t of ["line", "area", "rule", "trail"]) e[t] && (e = _objectSpread(_objectSpread({}, e), {}, { [t]: x(e[t], ["point", "line"]) }));return e;}function gl(e) {let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},i = arguments.length > 2 ? arguments[2] : void 0;return "transparent" === e.point ? { opacity: 0 } : e.point ? t.isObject(e.point) ? e.point : {} : void 0 !== e.point ? null : n.point || i.shape ? t.isObject(n.point) ? n.point : {} : void 0;}function hl(e) {let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};return e.line ? !0 === e.line ? {} : e.line : void 0 !== e.line ? null : t.line ? !0 === t.line ? {} : t.line : void 0;}class yl {constructor() {Yn(this, "name", "path-overlay");}hasMatchingType(e, t) {if (Wa(e)) {const { mark: n, encoding: i } = e,r = lo(n) ? n : { type: n };switch (r.type) {case "line":case "rule":case "trail":return !!gl(r, t[r.type], i);case "area":return !!gl(r, t[r.type], i) || !!hl(r, t[r.type]);}}return !1;}run(e, t, n) {const { config: i } = t,{ params: r, projection: o, mark: a, name: s, encoding: l } = e,c = _objectWithoutProperties(e, _excluded26),u = Ja(l, i),f = lo(a) ? a : { type: a },d = gl(f, i[f.type], u),m = "area" === f.type && hl(f, i[f.type]),p = [_objectSpread(_objectSpread({ name: s }, r ? { params: r } : {}), {}, { mark: ml(_objectSpread(_objectSpread({}, "area" === f.type && void 0 === f.opacity && void 0 === f.fillOpacity ? { opacity: .7 } : {}), f)), encoding: x(u, ["shape"]) })],g = fl(dl(f, u, i), u);let h = u;if (g) {const { fieldChannel: e, offset: t } = g;h = _objectSpread(_objectSpread({}, u), {}, { [e]: _objectSpread(_objectSpread({}, u[e]), t ? { stack: t } : {}) });}return h = x(h, ["y2", "x2"]), m && p.push(_objectSpread(_objectSpread({}, o ? { projection: o } : {}), {}, { mark: _objectSpread(_objectSpread({ type: "line" }, b(f, ["clip", "interpolate", "tension", "tooltip"])), m), encoding: h })), d && p.push(_objectSpread(_objectSpread({}, o ? { projection: o } : {}), {}, { mark: _objectSpread(_objectSpread({ type: "point", opacity: 1, filled: !0 }, b(f, ["clip", "tooltip"])), d), encoding: h })), n(_objectSpread(_objectSpread({}, c), {}, { layer: p }), _objectSpread(_objectSpread({}, t), {}, { config: pl(i) }));}}function vl(e, t) {return t ? Wo(e) ? Sl(e, t) : $l(e, t) : e;}function bl(e, t) {return t ? Sl(e, t) : e;}function xl(e, n, i) {const r = n[e];return (o = r) && !t.isString(o) && "repeat" in o ? r.repeat in i ? _objectSpread(_objectSpread({}, n), {}, { [e]: i[r.repeat] }) : void Ni(function (e) {return "Unknown repeated value \"".concat(e, "\".");}(r.repeat)) : n;var o;}function $l(e, t) {if (void 0 !== (e = xl("field", e, t))) {if (null === e) return null;if (Vo(e) && Uo(e.sort)) {const n = xl("field", e.sort, t);e = _objectSpread(_objectSpread({}, e), n ? { sort: n } : {});}return e;}}function wl(e, t) {if (ea(e)) return $l(e, t);{const n = xl("datum", e, t);return n === e || n.type || (n.type = "nominal"), n;}}function kl(e, t) {if (!aa(e)) {if (Zo(e)) {const n = wl(e.condition, t);if (n) return _objectSpread(_objectSpread({}, e), {}, { condition: n });{const { condition: t } = e,n = _objectWithoutProperties(e, _excluded27);return n;}}return e;}{const n = wl(e, t);if (n) return n;if (Qo(e)) return { condition: e.condition };}}function Sl(e, n) {const i = {};for (const r in e) if (t.hasOwnProperty(e, r)) {const o = e[r];if (t.isArray(o)) i[r] = o.map((e) => kl(e, n)).filter((e) => e);else {const e = kl(o, n);void 0 !== e && (i[r] = e);}}return i;}class Dl {constructor() {Yn(this, "name", "RuleForRangedLine");}hasMatchingType(e) {if (Wa(e)) {const { encoding: t, mark: n } = e;if ("line" === n || lo(n) && "line" === n.type) for (const e of lt) {const n = t[ut(e)];if (t[e] && (ea(n) && !vn(n.bin) || na(n))) return !0;}}return !1;}run(e, n, i) {const { encoding: r, mark: o } = e;var a, s;return Ni((a = !!r.x2, s = !!r.y2, "Line mark is for continuous lines and thus cannot be used with ".concat(a && s ? "x2 and y2" : a ? "x2" : "y2", ". We will use the rule mark (line segments) instead."))), i(_objectSpread(_objectSpread({}, e), {}, { mark: t.isObject(o) ? _objectSpread(_objectSpread({}, o), {}, { type: "rule" }) : "rule" }), n);}}function Fl(e) {let { parentEncoding: n, encoding: i = {}, layer: r } = e,o = {};if (n) {const e = new Set([...j(n), ...j(i)]);for (const a of e) {const e = i[a],s = n[a];if (aa(e)) {const t = _objectSpread(_objectSpread({}, s), e);o[a] = t;} else Zo(e) ? o[a] = _objectSpread(_objectSpread({}, e), {}, { condition: _objectSpread(_objectSpread({}, s), e.condition) }) : e || null === e ? o[a] = e : (r || la(s) || Fn(s) || aa(s) || t.isArray(s)) && (o[a] = s);}} else o = i;return !o || A(o) ? void 0 : o;}function zl(e) {const { parentProjection: t, projection: n } = e;return t && n && Ni(function (e) {const { parentProjection: t, projection: n } = e;return "Layer's shared projection ".concat(re(t), " is overridden by a child projection ").concat(re(n), ".");}({ parentProjection: t, projection: n })), n !== null && n !== void 0 ? n : t;}function Ol(e) {return "filter" in e;}function _l(e) {return "lookup" in e;}function Nl(e) {return "pivot" in e;}function Cl(e) {return "density" in e;}function Pl(e) {return "quantile" in e;}function Al(e) {return "regression" in e;}function jl(e) {return "loess" in e;}function Tl(e) {return "sample" in e;}function El(e) {return "window" in e;}function Ml(e) {return "joinaggregate" in e;}function Ll(e) {return "flatten" in e;}function ql(e) {return "calculate" in e;}function Ul(e) {return "bin" in e;}function Rl(e) {return "impute" in e;}function Wl(e) {return "timeUnit" in e;}function Bl(e) {return "aggregate" in e;}function Il(e) {return "stack" in e;}function Hl(e) {return "fold" in e;}function Vl(e) {return "extent" in e && !("density" in e);}function Gl(e, t) {const { transform: n } = e,i = _objectWithoutProperties(e, _excluded28);if (n) {return _objectSpread(_objectSpread({}, i), {}, { transform: n.map((e) => {if (Ol(e)) return { filter: Jl(e, t) };if (Ul(e) && bn(e.bin)) return _objectSpread(_objectSpread({}, e), {}, { bin: Xl(e.bin) });if (_l(e)) {const _e$from = e.from,{ selection: t } = _e$from,n = _objectWithoutProperties(_e$from, _excluded29);return t ? _objectSpread(_objectSpread({}, e), {}, { from: _objectSpread({ param: t }, n) }) : e;}return e;}) });}return e;}function Yl(e, n) {var _i$scale2;const i = y(e);if (ea(i) && bn(i.bin) && (i.bin = Xl(i.bin)), ca(i) && (_i$scale2 = i.scale) !== null && _i$scale2 !== void 0 && (_i$scale2 = _i$scale2.domain) !== null && _i$scale2 !== void 0 && _i$scale2.selection) {const _i$scale$domain = i.scale.domain,{ selection: e } = _i$scale$domain,t = _objectWithoutProperties(_i$scale$domain, _excluded30);i.scale.domain = _objectSpread(_objectSpread({}, t), e ? { param: e } : {});}if (Qo(i)) if (t.isArray(i.condition)) i.condition = i.condition.map((e) => {const { selection: t, param: i, test: r } = e,o = _objectWithoutProperties(e, _excluded31);return i ? e : _objectSpread(_objectSpread({}, o), {}, { test: Jl(e, n) });});else {const _Yl = Yl(i.condition, n),{ selection: e, param: t, test: r } = _Yl,o = _objectWithoutProperties(_Yl, _excluded32);i.condition = t ? i.condition : _objectSpread(_objectSpread({}, o), {}, { test: Jl(i.condition, n) });}return i;}function Xl(e) {const t = e.extent;if (t !== null && t !== void 0 && t.selection) {const { selection: n } = t,i = _objectWithoutProperties(t, _excluded33);return _objectSpread(_objectSpread({}, e), {}, { extent: _objectSpread(_objectSpread({}, i), {}, { param: n }) });}return e;}function Jl(e, t) {const n = (e) => h(e, (e) => {var _t$emptySelections$e, _t$selectionPredicate, _t$selectionPredicate2;const n = { param: e, empty: (_t$emptySelections$e = t.emptySelections[e]) !== null && _t$emptySelections$e !== void 0 ? _t$emptySelections$e : !0 };return (_t$selectionPredicate2 = (_t$selectionPredicate = t.selectionPredicates)[e]) !== null && _t$selectionPredicate2 !== void 0 ? _t$selectionPredicate2 : _t$selectionPredicate[e] = [], t.selectionPredicates[e].push(n), n;});return e.selection ? n(e.selection) : h(e.test || e.filter, (e) => e.selection ? n(e.selection) : e);}class Ql extends ol {map(e, t) {var _t$selections;const n = (_t$selections = t.selections) !== null && _t$selections !== void 0 ? _t$selections : [];if (e.params && !Wa(e)) {const t = [];for (const i of e.params) As(i) ? n.push(i) : t.push(i);e.params = t;}return t.selections = n, super.map(e, t);}mapUnit(e, n) {var _n$path;const i = n.selections;if (!i || !i.length) return e;const r = ((_n$path = n.path) !== null && _n$path !== void 0 ? _n$path : []).concat(e.name),o = [];for (const n of i) if (n.views && n.views.length) for (const i of n.views) (t.isString(i) && (i === e.name || r.includes(i)) || t.isArray(i) && i.map((e) => r.indexOf(e)).every((e, t, n) => -1 !== e && (0 === t || e > n[t - 1]))) && o.push(n);else o.push(n);return o.length && (e.params = o), e;}}for (const e of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {const t = Ql.prototype[e];Ql.prototype[e] = function (e, n) {return t.call(this, e, Kl(e, n));};}function Kl(e, t) {var _t$path;return e.name ? _objectSpread(_objectSpread({}, t), {}, { path: ((_t$path = t.path) !== null && _t$path !== void 0 ? _t$path : []).concat(e.name) }) : t;}function Zl(e, t) {void 0 === t && (t = Ks(e.config));const n = function (e) {let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};const n = { config: t };return nc.map(ec.map(tc.map(e, n), n), n);}(e, t),{ width: i, height: r } = e,o = function (e, t, n) {let { width: i, height: r } = t;const o = Wa(e) || rl(e),a = {};o ? "container" == i && "container" == r ? (a.type = "fit", a.contains = "padding") : "container" == i ? (a.type = "fit-x", a.contains = "padding") : "container" == r && (a.type = "fit-y", a.contains = "padding") : ("container" == i && (Ni(ei("width")), i = void 0), "container" == r && (Ni(ei("height")), r = void 0));const s = _objectSpread(_objectSpread(_objectSpread({ type: "pad" }, a), n ? ic(n.autosize) : {}), ic(e.autosize));"fit" !== s.type || o || (Ni(Zn), s.type = "pad");"container" == i && "fit" != s.type && "fit-x" != s.type && Ni(ti("width"));"container" == r && "fit" != s.type && "fit-y" != s.type && Ni(ti("height"));if (ie(s, { type: "pad" })) return;return s;}(n, { width: i, height: r, autosize: e.autosize }, t);return _objectSpread(_objectSpread({}, n), o ? { autosize: o } : {});}const ec = new class extends ol {constructor() {super(...arguments), Yn(this, "nonFacetUnitNormalizers", [ss, ds, vs, new yl(), new Dl()]);}map(e, t) {if (Wa(e)) {const n = Ia(e.encoding, oe),i = Ia(e.encoding, ae),r = Ia(e.encoding, se);if (n || i || r) return this.mapFacetedUnit(e, t);}return super.map(e, t);}mapUnit(e, t) {const { parentEncoding: n, parentProjection: i } = t,r = bl(e.encoding, t.repeater),o = _objectSpread(_objectSpread(_objectSpread({}, e), e.name ? { name: [t.repeaterPrefix, e.name].filter((e) => e).join("_") } : {}), r ? { encoding: r } : {});if (n || i) return this.mapUnitWithParentEncodingOrProjection(o, t);const a = this.mapLayerOrUnit.bind(this);for (const e of this.nonFacetUnitNormalizers) if (e.hasMatchingType(o, t.config)) return e.run(o, t, a);return o;}mapRepeat(e, n) {return function (e) {return !t.isArray(e.repeat) && e.repeat.layer;}(e) ? this.mapLayerRepeat(e, n) : this.mapNonLayerRepeat(e, n);}mapLayerRepeat(e, t) {const { repeat: n, spec: i } = e,r = _objectWithoutProperties(e, _excluded34),{ row: o, column: a, layer: s } = n,{ repeater: l = {}, repeaterPrefix: c = "" } = t;return o || a ? this.mapRepeat(_objectSpread(_objectSpread({}, e), {}, { repeat: _objectSpread(_objectSpread({}, o ? { row: o } : {}), a ? { column: a } : {}), spec: { repeat: { layer: s }, spec: i } }), t) : _objectSpread(_objectSpread({}, r), {}, { layer: s.map((e) => {const n = _objectSpread(_objectSpread({}, l), {}, { layer: e }),r = "".concat((i.name ? "".concat(i.name, "_") : "") + c, "child__layer_").concat(L(e)),o = this.mapLayerOrUnit(i, _objectSpread(_objectSpread({}, t), {}, { repeater: n, repeaterPrefix: r }));return o.name = r, o;}) });}mapNonLayerRepeat(e, n) {var _r$data;const { repeat: i, spec: r, data: o } = e,a = _objectWithoutProperties(e, _excluded35);!t.isArray(i) && e.columns && (e = x(e, ["columns"]), Ni(li("repeat")));const s = [],{ repeater: l = {}, repeaterPrefix: c = "" } = n,u = !t.isArray(i) && i.row || [l ? l.row : null],f = !t.isArray(i) && i.column || [l ? l.column : null],d = t.isArray(i) && i || [l ? l.repeat : null];for (const e of d) for (const o of u) for (const a of f) {const u = { repeat: e, row: o, column: a, layer: l.layer },f = (r.name ? "".concat(r.name, "_") : "") + c + "child__" + (t.isArray(i) ? "".concat(L(e)) : (i.row ? "row_".concat(L(o)) : "") + (i.column ? "column_".concat(L(a)) : "")),d = this.map(r, _objectSpread(_objectSpread({}, n), {}, { repeater: u, repeaterPrefix: f }));d.name = f, s.push(x(d, ["data"]));}const m = t.isArray(i) ? e.columns : i.column ? i.column.length : 1;return _objectSpread(_objectSpread({ data: (_r$data = r.data) !== null && _r$data !== void 0 ? _r$data : o, align: "all" }, a), {}, { columns: m, concat: s });}mapFacet(e, t) {const { facet: n } = e;return Wo(n) && e.columns && (e = x(e, ["columns"]), Ni(li("facet"))), super.mapFacet(e, t);}mapUnitWithParentEncodingOrProjection(e, t) {const { encoding: n, projection: i } = e,{ parentEncoding: r, parentProjection: o, config: a } = t,s = zl({ parentProjection: o, projection: i }),l = Fl({ parentEncoding: r, encoding: bl(n, t.repeater) });return this.mapUnit(_objectSpread(_objectSpread(_objectSpread({}, e), s ? { projection: s } : {}), l ? { encoding: l } : {}), { config: a });}mapFacetedUnit(e, t) {const _e$encoding2 = e.encoding,{ row: n, column: i, facet: r } = _e$encoding2,o = _objectWithoutProperties(_e$encoding2, _excluded36),{ mark: a, width: s, projection: l, height: c, view: u, params: f, encoding: d } = e,m = _objectWithoutProperties(e, _excluded37),{ facetMapping: p, layout: g } = this.getFacetMappingAndLayout({ row: n, column: i, facet: r }, t),h = bl(o, t.repeater);return this.mapFacet(_objectSpread(_objectSpread(_objectSpread({}, m), g), {}, { facet: p, spec: _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, s ? { width: s } : {}), c ? { height: c } : {}), u ? { view: u } : {}), l ? { projection: l } : {}), {}, { mark: a, encoding: h }, f ? { params: f } : {}) }), t);}getFacetMappingAndLayout(e, t) {const { row: n, column: i, facet: r } = e;if (n || i) {r && Ni("Facet encoding dropped as ".concat((o = [...(n ? [oe] : []), ...(i ? [ae] : [])]).join(" and "), " ").concat(o.length > 1 ? "are" : "is", " also specified."));const t = {},a = {};for (const n of [oe, ae]) {const i = e[n];if (i) {const { align: e, center: r, spacing: o, columns: s } = i,l = _objectWithoutProperties(i, _excluded38);t[n] = l;for (const e of ["align", "center", "spacing"]) {var _a$e;void 0 !== i[e] && ((_a$e = a[e]) !== null && _a$e !== void 0 ? _a$e : a[e] = {}, a[e][n] = i[e]);}}}return { facetMapping: t, layout: a };}{const { align: e, center: n, spacing: i, columns: o } = r,a = _objectWithoutProperties(r, _excluded39);return { facetMapping: vl(a, t.repeater), layout: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, e ? { align: e } : {}), n ? { center: n } : {}), i ? { spacing: i } : {}), o ? { columns: o } : {}) };}var o;}mapLayer(e, t) {let { parentEncoding: n, parentProjection: i } = t,r = _objectWithoutProperties(t, _excluded40);const { encoding: o, projection: a } = e,s = _objectWithoutProperties(e, _excluded41),l = _objectSpread(_objectSpread({}, r), {}, { parentEncoding: Fl({ parentEncoding: n, encoding: o, layer: !0 }), parentProjection: zl({ parentProjection: i, projection: a }) });return super.mapLayer(_objectSpread(_objectSpread({}, s), e.name ? { name: [l.repeaterPrefix, e.name].filter((e) => e).join("_") } : {}), l);}}(),tc = new class extends ol {map(e, t) {var _t$emptySelections, _t$selectionPredicate3;return (_t$emptySelections = t.emptySelections) !== null && _t$emptySelections !== void 0 ? _t$emptySelections : t.emptySelections = {}, (_t$selectionPredicate3 = t.selectionPredicates) !== null && _t$selectionPredicate3 !== void 0 ? _t$selectionPredicate3 : t.selectionPredicates = {}, e = Gl(e, t), super.map(e, t);}mapLayerOrUnit(e, t) {if ((e = Gl(e, t)).encoding) {const n = {};for (const [i, r] of E(e.encoding)) n[i] = Yl(r, t);e = _objectSpread(_objectSpread({}, e), {}, { encoding: n });}return super.mapLayerOrUnit(e, t);}mapUnit(e, t) {const { selection: n } = e,i = _objectWithoutProperties(e, _excluded42);return n ? _objectSpread(_objectSpread({}, i), {}, { params: E(n).map((e) => {let [n, i] = e;const { init: r, bind: o, empty: a } = i,s = _objectWithoutProperties(i, _excluded43);"single" === s.type ? (s.type = "point", s.toggle = !1) : "multi" === s.type && (s.type = "point"), t.emptySelections[n] = "none" !== a;for (const e of T((_t$selectionPredicate4 = t.selectionPredicates[n]) !== null && _t$selectionPredicate4 !== void 0 ? _t$selectionPredicate4 : {})) {var _t$selectionPredicate4;e.empty = "none" !== a;}return { name: n, value: r, select: s, bind: o };}) }) : e;}}(),nc = new Ql();function ic(e) {return t.isString(e) ? { type: e } : e !== null && e !== void 0 ? e : {};}const rc = ["background", "padding"];function oc(e, t) {const n = {};for (const t of rc) e && void 0 !== e[t] && (n[t] = An(e[t]));return t && (n.params = e.params), n;}class ac {constructor() {let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};this.explicit = e, this.implicit = t;}clone() {return new ac(y(this.explicit), y(this.implicit));}combine() {return _objectSpread(_objectSpread({}, this.explicit), this.implicit);}get(e) {return X(this.explicit[e], this.implicit[e]);}getWithExplicit(e) {return void 0 !== this.explicit[e] ? { explicit: !0, value: this.explicit[e] } : void 0 !== this.implicit[e] ? { explicit: !1, value: this.implicit[e] } : { explicit: !1, value: void 0 };}setWithExplicit(e, t) {let { value: n, explicit: i } = t;void 0 !== n && this.set(e, n, i);}set(e, t, n) {return delete this[n ? "implicit" : "explicit"][e], this[n ? "explicit" : "implicit"][e] = t, this;}copyKeyFromSplit(e, t) {let { explicit: n, implicit: i } = t;void 0 !== n[e] ? this.set(e, n[e], !0) : void 0 !== i[e] && this.set(e, i[e], !1);}copyKeyFromObject(e, t) {void 0 !== t[e] && this.set(e, t[e], !0);}copyAll(e) {for (const t of j(e.combine())) {const n = e.getWithExplicit(t);this.setWithExplicit(t, n);}}}function sc(e) {return { explicit: !0, value: e };}function lc(e) {return { explicit: !1, value: e };}function cc(e) {return (t, n, i, r) => {const o = e(t.value, n.value);return o > 0 ? t : o < 0 ? n : uc(t, n, i, r);};}function uc(e, t, n, i) {return e.explicit && t.explicit && Ni(function (e, t, n, i) {return "Conflicting ".concat(t.toString(), " property \"").concat(e.toString(), "\" (").concat(re(n), " and ").concat(re(i), "). Using ").concat(re(n), ".");}(n, i, e.value, t.value)), e;}function fc(e, t, n, i) {let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : uc;return void 0 === e || void 0 === e.value ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : ie(e.value, t.value) ? e : r(e, t, n, i);}class dc extends ac {constructor() {let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];super(e, t), this.explicit = e, this.implicit = t, this.parseNothing = n;}clone() {const e = super.clone();return e.parseNothing = this.parseNothing, e;}}function mc(e) {return "url" in e;}function pc(e) {return "values" in e;}function gc(e) {return "name" in e && !mc(e) && !pc(e) && !hc(e);}function hc(e) {return e && (yc(e) || vc(e) || bc(e));}function yc(e) {return "sequence" in e;}function vc(e) {return "sphere" in e;}function bc(e) {return "graticule" in e;}let xc = function (e) {return e[e.Raw = 0] = "Raw", e[e.Main = 1] = "Main", e[e.Row = 2] = "Row", e[e.Column = 3] = "Column", e[e.Lookup = 4] = "Lookup", e;}({});function $c(e) {const { signals: t, hasLegend: n, index: i } = e,r = _objectWithoutProperties(e, _excluded44);return r.field = H(r.field), r;}function wc(e) {let n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.identity;if (t.isArray(e)) {const t = e.map((e) => wc(e, n, i));return n ? "[".concat(t.join(", "), "]") : t;}return Ci(e) ? i(n ? Mi(e) : function (e) {const t = Ei(e, !0);return e.utc ? +new Date(Date.UTC(...t)) : +new Date(...t);}(e)) : n ? i(re(e)) : e;}function kc(e, n) {for (const i of T((_e$component$selectio = e.component.selection) !== null && _e$component$selectio !== void 0 ? _e$component$selectio : {})) {var _e$component$selectio;const r = i.name;let o = "".concat(r).concat(Wu, ", ").concat("global" === i.resolve ? "true" : "{unit: ".concat(Vu(e), "}"));for (const t of Hu) t.defined(i) && (t.signals && (n = t.signals(e, i, n)), t.modifyExpr && (o = t.modifyExpr(e, i, o)));n.push({ name: r + Bu, on: [{ events: { signal: i.name + Wu }, update: "modify(".concat(t.stringValue(i.name + Ru), ", ").concat(o, ")") }] });}return Fc(n);}function Sc(e, n) {if (e.component.selection && j(e.component.selection).length) {const i = t.stringValue(e.getName("cell"));n.unshift({ name: "facet", value: {}, on: [{ events: t.parseSelector("pointermove", "scope"), update: "isTuple(facet) ? facet : group(".concat(i, ").datum") }] });}return Fc(n);}function Dc(e, t) {for (const n of T((_e$component$selectio2 = e.component.selection) !== null && _e$component$selectio2 !== void 0 ? _e$component$selectio2 : {})) {var _e$component$selectio2;for (const i of Hu) i.defined(n) && i.marks && (t = i.marks(e, n, t));}return t;}function Fc(e) {return e.map((e) => (e.on && !e.on.length && delete e.on, e));}class zc {constructor(e, t) {this.debugName = t, Yn(this, "_children", []), Yn(this, "_parent", null), Yn(this, "_hash", void 0), e && (this.parent = e);}clone() {throw new Error("Cannot clone node");}get parent() {return this._parent;}set parent(e) {this._parent = e, e && e.addChild(this);}get children() {return this._children;}numChildren() {return this._children.length;}addChild(e, t) {this._children.includes(e) ? Ni("Attempt to add the same child twice.") : void 0 !== t ? this._children.splice(t, 0, e) : this._children.push(e);}removeChild(e) {const t = this._children.indexOf(e);return this._children.splice(t, 1), t;}remove() {let e = this._parent.removeChild(this);for (const t of this._children) t._parent = this._parent, this._parent.addChild(t, e++);}insertAsParentOf(e) {const t = e.parent;t.removeChild(this), this.parent = t, e.parent = this;}swapWithParent() {const e = this._parent,t = e.parent;for (const t of this._children) t.parent = e;this._children = [], e.removeChild(this);const n = e.parent.removeChild(e);this._parent = t, t.addChild(this, n), e.parent = this;}}class Oc extends zc {clone() {const e = new this.constructor();return e.debugName = "clone_".concat(this.debugName), e._source = this._source, e._name = "clone_".concat(this._name), e.type = this.type, e.refCounts = this.refCounts, e.refCounts[e._name] = 0, e;}constructor(e, t, n, i) {super(e, t), this.type = n, this.refCounts = i, Yn(this, "_source", void 0), Yn(this, "_name", void 0), this._source = this._name = t, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0);}dependentFields() {return new Set();}producedFields() {return new Set();}hash() {return void 0 === this._hash && (this._hash = "Output ".concat(Q())), this._hash;}getSource() {return this.refCounts[this._name]++, this._source;}isRequired() {return !!this.refCounts[this._name];}setSource(e) {this._source = e;}}function _c(e) {return void 0 !== e.as;}function Nc(e) {return "".concat(e, "_end");}class Cc extends zc {clone() {return new Cc(null, y(this.timeUnits));}constructor(e, t) {super(e), this.timeUnits = t;}static makeFromEncoding(e, t) {const n = t.reduceFieldDef((e, n, i) => {const { field: r, timeUnit: o } = n;if (o) {let a;if (Ui(o)) {if (_m(t)) {const { mark: e, markDef: i, config: s } = t,l = Go({ fieldDef: n, markDef: i, config: s });(ao(e) || l) && (a = { timeUnit: Xi(o), field: r });}} else a = { as: pa(n, { forAs: !0 }), field: r, timeUnit: o };if (_m(t)) {const { mark: e, markDef: r, config: o } = t,s = Go({ fieldDef: n, markDef: r, config: o });ao(e) && Et(i) && .5 !== s && (a.rectBandPosition = s);}a && (e[$(a)] = a);}return e;}, {});return A(n) ? null : new Cc(e, n);}static makeFromTransform(e, t) {const _t2 = _objectSpread({}, t),{ timeUnit: n } = _t2,i = _objectWithoutProperties(_t2, _excluded45),r = _objectSpread(_objectSpread({}, i), {}, { timeUnit: Xi(n) });return new Cc(e, { [$(r)]: r });}merge(e) {this.timeUnits = _objectSpread({}, this.timeUnits);for (const t in e.timeUnits) this.timeUnits[t] || (this.timeUnits[t] = e.timeUnits[t]);for (const t of e.children) e.removeChild(t), t.parent = this;e.remove();}removeFormulas(e) {const t = {};for (const [n, i] of E(this.timeUnits)) {const r = _c(i) ? i.as : "".concat(i.field, "_end");e.has(r) || (t[n] = i);}this.timeUnits = t;}producedFields() {return new Set(T(this.timeUnits).map((e) => _c(e) ? e.as : Nc(e.field)));}dependentFields() {return new Set(T(this.timeUnits).map((e) => e.field));}hash() {return "TimeUnit ".concat($(this.timeUnits));}assemble() {const e = [];for (const t of T(this.timeUnits)) {const { rectBandPosition: n } = t,i = Xi(t.timeUnit);if (_c(t)) {const { field: r, as: o } = t,{ unit: a, utc: s } = i,l = _objectWithoutProperties(i, _excluded46),c = [o, "".concat(o, "_end")];e.push(_objectSpread(_objectSpread(_objectSpread(_objectSpread({ field: H(r), type: "timeunit" }, a ? { units: Ii(a) } : {}), s ? { timezone: "utc" } : {}), l), {}, { as: c })), e.push(...Tc(c, n, i));} else if (t) {const { field: r } = t,o = r.replaceAll("\\.", "."),a = jc({ timeUnit: i, field: o }),s = Nc(o);e.push({ type: "formula", expr: a, as: s }), e.push(...Tc([o, s], n, i));}}return e;}}const Pc = "offsetted_rect_start",Ac = "offsetted_rect_end";function jc(e) {let { timeUnit: t, field: n, reverse: i } = e;const { unit: r, utc: o } = t,a = Hi(r),{ part: s, step: l } = Ki(a, t.step);return "".concat(o ? "utcOffset" : "timeOffset", "('").concat(s, "', datum['").concat(n, "'], ").concat(i ? -l : l, ")");}function Tc(e, t, n) {let [i, r] = e;if (void 0 !== t && .5 !== t) {const e = "datum['".concat(i, "']"),o = "datum['".concat(r, "']");return [{ type: "formula", expr: Ec([jc({ timeUnit: n, field: i, reverse: !0 }), e], t + .5), as: "".concat(i, "_").concat(Pc) }, { type: "formula", expr: Ec([e, o], t + .5), as: "".concat(i, "_").concat(Ac) }];}return [];}function Ec(e, t) {let [n, i] = e;return "".concat(1 - t, " * ").concat(n, " + ").concat(t, " * ").concat(i);}const Mc = "_tuple_fields";class Lc {constructor() {Yn(this, "hasChannel", void 0), Yn(this, "hasField", void 0), Yn(this, "hasSelectionId", void 0), Yn(this, "timeUnit", void 0), Yn(this, "items", void 0);for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];this.items = t, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1;}}const qc = { defined: () => !0, parse: (e, n, i) => {var _n$project;const r = n.name,o = (_n$project = n.project) !== null && _n$project !== void 0 ? _n$project : n.project = new Lc(),a = {},s = {},l = new Set(),c = (e, t) => {const n = "visual" === t ? e.channel : e.field;let i = L("".concat(r, "_").concat(n));for (let e = 1; l.has(i); e++) i = L("".concat(r, "_").concat(n, "_").concat(e));return l.add(i), { [t]: i };},u = n.type,f = e.config.selection[u],d = void 0 !== i.value ? t.array(i.value) : null;let { fields: m, encodings: p } = t.isObject(i.select) ? i.select : {};if (!m && !p && d) for (const e of d) if (t.isObject(e)) for (const t of j(e)) {var _m2;at[t] ? (p || (p = [])).push(t) : "interval" === u ? (Ni('Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.'), p = f.encodings) : ((_m2 = m) !== null && _m2 !== void 0 ? _m2 : m = []).push(t);}m || p || (p = f.encodings, "fields" in f && (m = f.fields));for (const t of (_p2 = p) !== null && _p2 !== void 0 ? _p2 : []) {var _p2;const n = e.fieldDef(t);if (n) {let i = n.field;if (n.aggregate) {Ni(oi(t, n.aggregate));continue;}if (!i) {Ni(ri(t));continue;}if (n.timeUnit && !Ui(n.timeUnit)) {i = e.vgField(t);const r = { timeUnit: n.timeUnit, as: i, field: n.field };s[$(r)] = r;}if (!a[i]) {const r = { field: i, channel: t, type: "interval" === u && en(t) && Nr(e.getScaleComponent(t).get("type")) ? "R" : n.bin ? "R-RE" : "E", index: o.items.length };r.signals = _objectSpread(_objectSpread({}, c(r, "data")), c(r, "visual")), o.items.push(a[i] = r), o.hasField[i] = a[i], o.hasSelectionId = o.hasSelectionId || i === _s, He(t) ? (r.geoChannel = t, r.channel = Ie(t), o.hasChannel[r.channel] = a[i]) : o.hasChannel[t] = a[i];}} else Ni(ri(t));}for (const e of (_m3 = m) !== null && _m3 !== void 0 ? _m3 : []) {var _m3;if (o.hasField[e]) continue;const t = { type: "E", field: e, index: o.items.length };t.signals = _objectSpread({}, c(t, "data")), o.items.push(t), o.hasField[e] = t, o.hasSelectionId = o.hasSelectionId || e === _s;}d && (n.init = d.map((e) => o.items.map((n) => t.isObject(e) ? void 0 !== e[n.geoChannel || n.channel] ? e[n.geoChannel || n.channel] : e[n.field] : e))), A(s) || (o.timeUnit = new Cc(null, s));}, signals: (e, t, n) => {const i = t.name + Mc;return n.filter((e) => e.name === i).length > 0 || t.project.hasSelectionId ? n : n.concat({ name: i, value: t.project.items.map($c) });} },Uc = { defined: (e) => "interval" === e.type && "global" === e.resolve && e.bind && "scales" === e.bind, parse: (e, t) => {const n = t.scales = [];for (const i of t.project.items) {const r = i.channel;if (!en(r)) continue;const o = e.getScaleComponent(r),a = o ? o.get("type") : void 0;o && Nr(a) ? (o.set("selectionExtent", { param: t.name, field: i.field }, !0), n.push(i)) : Ni("Scale bindings are currently only supported for scales with unbinned, continuous domains.");}}, topLevelSignals: (e, n, i) => {const r = n.scales.filter((e) => 0 === i.filter((t) => t.name === e.signals.data).length);if (!e.parent || Wc(e) || 0 === r.length) return i;const o = i.filter((e) => e.name === n.name)[0];let a = o.update;if (a.indexOf(Iu) >= 0) o.update = "{".concat(r.map((e) => "".concat(t.stringValue(H(e.field)), ": ").concat(e.signals.data)).join(", "), "}");else {for (const e of r) {const n = "".concat(t.stringValue(H(e.field)), ": ").concat(e.signals.data);a.includes(n) || (a = "".concat(a.substring(0, a.length - 1), ", ").concat(n, "}"));}o.update = a;}return i.concat(r.map((e) => ({ name: e.signals.data })));}, signals: (e, t, n) => {if (e.parent && !Wc(e)) for (const e of t.scales) {const t = n.filter((t) => t.name === e.signals.data)[0];t.push = "outer", delete t.value, delete t.update;}return n;} };function Rc(e, n) {return "domain(".concat(t.stringValue(e.scaleName(n)), ")");}function Wc(e) {var _e$parent$parent;return e.parent && Pm(e.parent) && ((_e$parent$parent = !e.parent.parent) !== null && _e$parent$parent !== void 0 ? _e$parent$parent : Wc(e.parent.parent));}const Bc = "_brush",Ic = "_scale_trigger",Hc = "geo_interval_init_tick",Vc = "_init",Gc = { defined: (e) => "interval" === e.type, parse: (e, n, i) => {if (e.hasProjection) {const e = _objectSpread({}, t.isObject(i.select) ? i.select : {});e.fields = [_s], e.encodings || (e.encodings = i.value ? j(i.value) : [be, ve]), i.select = _objectSpread({ type: "interval" }, e);}if (n.translate && !Uc.defined(n)) {const e = "!event.item || event.item.mark.name !== ".concat(t.stringValue(n.name + Bc));for (const i of n.events) {var _i$between$, _i$between$$filter;if (!i.between) {Ni("".concat(i, " is not an ordered event stream for interval selections."));continue;}const n = t.array((_i$between$$filter = (_i$between$ = i.between[0]).filter) !== null && _i$between$$filter !== void 0 ? _i$between$$filter : _i$between$.filter = []);n.indexOf(e) < 0 && n.push(e);}}}, signals: (e, n, i) => {const r = n.name,o = r + Wu,a = T(n.project.hasChannel).filter((e) => e.channel === le || e.channel === ce),s = n.init ? n.init[0] : null;if (i.push(...a.reduce((i, r) => i.concat(function (e, n, i, r) {const o = !e.hasProjection,a = i.channel,s = i.signals.visual,l = t.stringValue(o ? e.scaleName(a) : e.projectionName()),c = (e) => "scale(".concat(l, ", ").concat(e, ")"),u = e.getSizeSignalRef(a === le ? "width" : "height").signal,f = "".concat(a, "(unit)"),d = n.events.reduce((e, t) => [...e, { events: t.between[0], update: "[".concat(f, ", ").concat(f, "]") }, { events: t, update: "[".concat(s, "[0], clamp(").concat(f, ", 0, ").concat(u, ")]") }], []);if (o) {const t = i.signals.data,o = Uc.defined(n),u = e.getScaleComponent(a),f = u ? u.get("type") : void 0,m = r ? { init: wc(r, !0, c) } : { value: [] };return d.push({ events: { signal: n.name + Ic }, update: Nr(f) ? "[".concat(c("".concat(t, "[0]")), ", ").concat(c("".concat(t, "[1]")), "]") : "[0, 0]" }), o ? [{ name: t, on: [] }] : [_objectSpread(_objectSpread({ name: s }, m), {}, { on: d }), _objectSpread(_objectSpread({ name: t }, r ? { init: wc(r) } : {}), {}, { on: [{ events: { signal: s }, update: "".concat(s, "[0] === ").concat(s, "[1] ? null : invert(").concat(l, ", ").concat(s, ")") }] })];}{const e = a === le ? 0 : 1,t = n.name + Vc;return [_objectSpread(_objectSpread({ name: s }, r ? { init: "[".concat(t, "[0][").concat(e, "], ").concat(t, "[1][").concat(e, "]]") } : { value: [] }), {}, { on: d })];}}(e, n, r, s && s[r.index])), [])), e.hasProjection) {const l = t.stringValue(e.projectionName()),c = e.projectionName() + "_center",{ x: u, y: f } = n.project.hasChannel,d = u && u.signals.visual,m = f && f.signals.visual,p = u ? s && s[u.index] : "".concat(c, "[0]"),g = f ? s && s[f.index] : "".concat(c, "[1]"),h = (t) => e.getSizeSignalRef(t).signal,y = "[[".concat(d ? d + "[0]" : "0", ", ").concat(m ? m + "[0]" : "0", "],[").concat(d ? d + "[1]" : h("width"), ", ").concat(m ? m + "[1]" : h("height"), "]]");if (s && (i.unshift({ name: r + Vc, init: "[scale(".concat(l, ", [").concat(u ? p[0] : p, ", ").concat(f ? g[0] : g, "]), scale(").concat(l, ", [").concat(u ? p[1] : p, ", ").concat(f ? g[1] : g, "])]") }), !u || !f)) {i.find((e) => e.name === c) || i.unshift({ name: c, update: "invert(".concat(l, ", [").concat(h("width"), "/2, ").concat(h("height"), "/2])") });}const v = "vlSelectionTuples(".concat("intersect(".concat(y, ", {markname: ").concat(t.stringValue(e.getName("marks")), "}, unit.mark)"), ", ", "{unit: ".concat(Vu(e), "}"), ")"),b = a.map((e) => e.signals.visual);return i.concat({ name: o, on: [{ events: [...(b.length ? [{ signal: b.join(" || ") }] : []), ...(s ? [{ signal: Hc }] : [])], update: v }] });}{if (!Uc.defined(n)) {const n = r + Ic,o = a.map((n) => {const i = n.channel,{ data: r, visual: o } = n.signals,a = t.stringValue(e.scaleName(i)),s = Nr(e.getScaleComponent(i).get("type")) ? "+" : "";return "(!isArray(".concat(r, ") || (").concat(s, "invert(").concat(a, ", ").concat(o, ")[0] === ").concat(s).concat(r, "[0] && ").concat(s, "invert(").concat(a, ", ").concat(o, ")[1] === ").concat(s).concat(r, "[1]))");});o.length && i.push({ name: n, value: {}, on: [{ events: a.map((t) => ({ scale: e.scaleName(t.channel) })), update: o.join(" && ") + " ? ".concat(n, " : {}") }] });}const l = a.map((e) => e.signals.data),c = "unit: ".concat(Vu(e), ", fields: ").concat(r + Mc, ", values");return i.concat(_objectSpread(_objectSpread({ name: o }, s ? { init: "{".concat(c, ": ").concat(wc(s), "}") } : {}), l.length ? { on: [{ events: [{ signal: l.join(" || ") }], update: "".concat(l.join(" && "), " ? {").concat(c, ": [").concat(l, "]} : null") }] } : {}));}}, topLevelSignals: (e, t, n) => {if (_m(e) && e.hasProjection && t.init) {n.filter((e) => e.name === Hc).length || n.unshift({ name: Hc, value: null, on: [{ events: "timer{1}", update: "".concat(Hc, " === null ? {} : ").concat(Hc) }] });}return n;}, marks: (e, n, i) => {const r = n.name,{ x: o, y: a } = n.project.hasChannel,s = o === null || o === void 0 ? void 0 : o.signals.visual,l = a === null || a === void 0 ? void 0 : a.signals.visual,c = "data(".concat(t.stringValue(n.name + Ru), ")");if (Uc.defined(n) || !o && !a) return i;const u = { x: void 0 !== o ? { signal: "".concat(s, "[0]") } : { value: 0 }, y: void 0 !== a ? { signal: "".concat(l, "[0]") } : { value: 0 }, x2: void 0 !== o ? { signal: "".concat(s, "[1]") } : { field: { group: "width" } }, y2: void 0 !== a ? { signal: "".concat(l, "[1]") } : { field: { group: "height" } } };if ("global" === n.resolve) for (const t of j(u)) u[t] = [_objectSpread({ test: "".concat(c, ".length && ").concat(c, "[0].unit === ").concat(Vu(e)) }, u[t]), { value: 0 }];const _n$mark = n.mark,{ fill: f, fillOpacity: d, cursor: m } = _n$mark,p = _objectWithoutProperties(_n$mark, _excluded47),g = j(p).reduce((e, t) => (e[t] = [{ test: [void 0 !== o && "".concat(s, "[0] !== ").concat(s, "[1]"), void 0 !== a && "".concat(l, "[0] !== ").concat(l, "[1]")].filter((e) => e).join(" && "), value: p[t] }, { value: null }], e), {});return [{ name: "".concat(r + Bc, "_bg"), type: "rect", clip: !0, encode: { enter: { fill: { value: f }, fillOpacity: { value: d } }, update: u } }, ...i, { name: r + Bc, type: "rect", clip: !0, encode: { enter: _objectSpread(_objectSpread({}, m ? { cursor: { value: m } } : {}), {}, { fill: { value: "transparent" } }), update: _objectSpread(_objectSpread({}, u), g) } }];} };const Yc = { defined: (e) => "point" === e.type, signals: (e, n, i) => {var _e$component$selectio3;const r = n.name,o = r + Mc,a = n.project,s = "(item().isVoronoi ? datum.datum : datum)",l = T((_e$component$selectio3 = e.component.selection) !== null && _e$component$selectio3 !== void 0 ? _e$component$selectio3 : {}).reduce((e, t) => "interval" === t.type ? e.concat(t.name + Bc) : e, []).map((e) => "indexof(item().mark.name, '".concat(e, "') < 0")).join(" && "),c = "datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0" + (l ? " && ".concat(l) : "");let u = "unit: ".concat(Vu(e), ", ");if (n.project.hasSelectionId) u += "".concat(_s, ": ").concat(s, "[").concat(t.stringValue(_s), "]");else {u += "fields: ".concat(o, ", values: [").concat(a.items.map((n) => {const i = e.fieldDef(n.channel);return i !== null && i !== void 0 && i.bin ? "[".concat(s, "[").concat(t.stringValue(e.vgField(n.channel, {})), "], ").concat(s, "[").concat(t.stringValue(e.vgField(n.channel, { binSuffix: "end" })), "]]") : "".concat(s, "[").concat(t.stringValue(n.field), "]");}).join(", "), "]");}const f = n.events;return i.concat([{ name: r + Wu, on: f ? [{ events: f, update: "".concat(c, " ? {").concat(u, "} : null"), force: !0 }] : [] }]);} };function Xc(e, n, i, r) {const o = Qo(n) && n.condition,a = r(n);if (o) {return { [i]: [...t.array(o).map((t) => {const n = r(t);if (function (e) {return e.param;}(t)) {const { param: i, empty: r } = t;return _objectSpread({ test: Zu(e, { param: i, empty: r }) }, n);}return _objectSpread({ test: tf(e, t.test) }, n);}), ...(void 0 !== a ? [a] : [])] };}return void 0 !== a ? { [i]: a } : {};}function Jc(e) {let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "text";const n = e.encoding[t];return Xc(e, n, t, (t) => Qc(t, e.config));}function Qc(e, t) {let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "datum";if (e) {if (la(e)) return Tn(e.value);if (aa(e)) {const { format: i, formatType: r } = wa(e);return zo({ fieldOrDatumDef: e, format: i, formatType: r, expr: n, config: t });}}}function Kc(e) {let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};const { encoding: i, markDef: r, config: o, stack: a } = e,s = i.tooltip;if (t.isArray(s)) return { tooltip: eu({ tooltip: s }, a, o, n) };{const l = n.reactiveGeom ? "datum.datum" : "datum";return Xc(e, s, "tooltip", (e) => {const s = Qc(e, o, l);if (s) return s;if (null === e) return;let c = Un("tooltip", r, o);return !0 === c && (c = { content: "encoding" }), t.isString(c) ? { value: c } : t.isObject(c) ? Fn(c) ? c : "encoding" === c.content ? eu(i, a, o, n) : { signal: l } : void 0;});}}function Zc(e, n, i) {let { reactiveGeom: r } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};const o = _objectSpread(_objectSpread({}, i), i.tooltipFormat),a = {},s = r ? "datum.datum" : "datum",l = [];function c(i, r) {var _m4;const c = ut(r),u = sa(i) ? i : _objectSpread(_objectSpread({}, i), {}, { type: e[c].type }),f = u.title || $a(u, o),d = t.array(f).join(", ").replaceAll(/"/g, '\\"');let m;if (Et(r)) {const t = "x" === r ? "x2" : "y2",n = ka(e[t]);if (vn(u.bin) && n) {const e = pa(u, { expr: s }),i = pa(n, { expr: s }),{ format: r, formatType: l } = wa(u);m = To(e, i, r, l, o), a[t] = !0;}}if ((Et(r) || r === he || r === pe) && n && n.fieldChannel === r && "normalize" === n.offset) {const { format: e, formatType: t } = wa(u);m = zo({ fieldOrDatumDef: u, format: e, formatType: t, expr: s, config: o, normalizeStack: !0 }).signal;}(_m4 = m) !== null && _m4 !== void 0 ? _m4 : m = Qc(u, o, s).signal, l.push({ channel: r, key: d, value: m });}Qa(e, (e, t) => {ea(e) ? c(e, t) : Ko(e) && c(e.condition, t);});const u = {};for (const { channel: e, key: t, value: n } of l) a[e] || u[t] || (u[t] = n);return u;}function eu(e, t, n) {let { reactiveGeom: i } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};const r = Zc(e, t, n, { reactiveGeom: i }),o = E(r).map((e) => {let [t, n] = e;return "\"".concat(t, "\": ").concat(n);});return o.length > 0 ? { signal: "{".concat(o.join(", "), "}") } : void 0;}function tu(e) {const { markDef: t, config: n } = e,i = Un("aria", t, n);return !1 === i ? {} : _objectSpread(_objectSpread(_objectSpread({}, i ? { aria: i } : {}), nu(e)), iu(e));}function nu(e) {const { mark: t, markDef: n, config: i } = e;if (!1 === i.aria) return {};const r = Un("ariaRoleDescription", n, i);return null != r ? { ariaRoleDescription: { value: r } } : t in Nn ? {} : { ariaRoleDescription: { value: t } };}function iu(e) {const { encoding: t, markDef: n, config: i, stack: r } = e,o = t.description;if (o) return Xc(e, o, "description", (t) => Qc(t, e.config));const a = Un("description", n, i);if (null != a) return { description: Tn(a) };if (!1 === i.aria) return {};const s = Zc(t, r, i);return A(s) ? void 0 : { description: { signal: E(s).map((e, t) => {let [n, i] = e;return "\"".concat(t > 0 ? "; " : "").concat(n, ": \" + (").concat(i, ")");}).join(" + ") } };}function ru(e, t) {var _l2;let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};const { markDef: i, encoding: r, config: o } = t,{ vgChannel: a } = n;let { defaultRef: s, defaultValue: l } = n;void 0 === s && ((_l2 = l) !== null && _l2 !== void 0 ? _l2 : l = Un(e, i, o, { vgChannel: a, ignoreVgConfig: !0 }), void 0 !== l && (s = Tn(l)));const c = r[e];return Xc(t, c, a !== null && a !== void 0 ? a : e, (n) => wo({ channel: e, channelDef: n, markDef: i, config: o, scaleName: t.scaleName(e), scale: t.getScaleComponent(e), stack: null, defaultRef: s }));}function ou(e) {var _t$filled, _ref7, _Un, _Un2;let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { filled: void 0 };const { markDef: n, encoding: i, config: r } = e,{ type: o } = n,a = (_t$filled = t.filled) !== null && _t$filled !== void 0 ? _t$filled : Un("filled", n, r),s = k(["bar", "point", "circle", "square", "geoshape"], o) ? "transparent" : void 0,l = (_ref7 = (_Un = Un(!0 === a ? "color" : void 0, n, r, { vgChannel: "fill" })) !== null && _Un !== void 0 ? _Un : r.mark[!0 === a && "color"]) !== null && _ref7 !== void 0 ? _ref7 : s,c = (_Un2 = Un(!1 === a ? "color" : void 0, n, r, { vgChannel: "stroke" })) !== null && _Un2 !== void 0 ? _Un2 : r.mark[!1 === a && "color"],u = a ? "fill" : "stroke",f = _objectSpread(_objectSpread({}, l ? { fill: Tn(l) } : {}), c ? { stroke: Tn(c) } : {});return n.color && (a ? n.fill : n.stroke) && Ni(mi("property", { fill: "fill" in n, stroke: "stroke" in n })), _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, f), ru("color", e, { vgChannel: u, defaultValue: a ? l : c })), ru("fill", e, { defaultValue: i.fill ? l : void 0 })), ru("stroke", e, { defaultValue: i.stroke ? c : void 0 }));}function au(e) {const { encoding: t, mark: n } = e,i = t.order;return !oo(n) && la(i) ? Xc(e, i, "zindex", (e) => Tn(e.value)) : {};}function su(e) {let { channel: t, markDef: n, encoding: i = {}, model: r, bandPosition: o } = e;const a = "".concat(t, "Offset"),s = n[a],l = i[a];if (("xOffset" === a || "yOffset" === a) && l) {return { offsetType: "encoding", offset: wo({ channel: a, channelDef: l, markDef: n, config: r === null || r === void 0 ? void 0 : r.config, scaleName: r.scaleName(a), scale: r.getScaleComponent(a), stack: null, defaultRef: Tn(s), bandPosition: o }) };}const c = n[a];return c ? { offsetType: "visual", offset: c } : {};}function lu(e, t, n) {let { defaultPos: i, vgChannel: r } = n;const { encoding: o, markDef: a, config: s, stack: l } = t,c = o[e],u = o[dt(e)],f = t.scaleName(e),d = t.getScaleComponent(e),{ offset: m, offsetType: p } = su({ channel: e, markDef: a, encoding: o, model: t, bandPosition: .5 }),g = cu({ model: t, defaultPos: i, channel: e, scaleName: f, scale: d }),h = !c && Et(e) && (o.latitude || o.longitude) ? { field: t.getName(e) } : function (e) {const { channel: t, channelDef: n, scaleName: i, stack: r, offset: o, markDef: a } = e;if (aa(n) && r && t === r.fieldChannel) {if (ea(n)) {let e = n.bandPosition;if (void 0 !== e || "text" !== a.type || "radius" !== t && "theta" !== t || (e = .5), void 0 !== e) return $o({ scaleName: i, fieldOrDatumDef: n, startSuffix: "start", bandPosition: e, offset: o });}return xo(n, i, { suffix: "end" }, { offset: o });}return yo(e);}({ channel: e, channelDef: c, channel2Def: u, markDef: a, config: s, scaleName: f, scale: d, stack: l, offset: m, defaultRef: g, bandPosition: "encoding" === p ? 0 : void 0 });return h ? { [r || e]: h } : void 0;}function cu(e) {let { model: t, defaultPos: n, channel: i, scaleName: r, scale: o } = e;const { markDef: a, config: s } = t;return () => {const e = ut(i),l = ft(i),c = Un(i, a, s, { vgChannel: l });if (void 0 !== c) return ko(i, c);switch (n) {case "zeroOrMin":case "zeroOrMax":if (r) {const e = o.get("type");if (k([vr.LOG, vr.TIME, vr.UTC], e)) ;else if (o.domainDefinitelyIncludesZero()) return { scale: r, value: 0 };}if ("zeroOrMin" === n) return "y" === e ? { field: { group: "height" } } : { value: 0 };switch (e) {case "radius":return { signal: "min(".concat(t.width.signal, ",").concat(t.height.signal, ")/2") };case "theta":return { signal: "2*PI" };case "x":return { field: { group: "width" } };case "y":return { value: 0 };}break;case "mid":return _objectSpread(_objectSpread({}, t[mt(i)]), {}, { mult: .5 });}};}const uu = { left: "x", center: "xc", right: "x2" },fu = { top: "y", middle: "yc", bottom: "y2" };function du(e, t, n) {let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "middle";if ("radius" === e || "theta" === e) return ft(e);const r = "x" === e ? "align" : "baseline",o = Un(r, t, n);let a;return Fn(o) ? (Ni(function (e) {return "The ".concat(e, " for range marks cannot be an expression");}(r)), a = void 0) : a = o, "x" === e ? uu[a || ("top" === i ? "left" : "center")] : fu[a || i];}function mu(e, t, n) {let { defaultPos: i, defaultPos2: r, range: o } = n;return o ? pu(e, t, { defaultPos: i, defaultPos2: r }) : lu(e, t, { defaultPos: i });}function pu(e, t, n) {let { defaultPos: i, defaultPos2: r } = n;const { markDef: o, config: a } = t,s = dt(e),l = mt(e),c = function (e, t, n) {const { encoding: i, mark: r, markDef: o, stack: a, config: s } = e,l = ut(n),c = mt(n),u = ft(n),f = i[l],d = e.scaleName(l),m = e.getScaleComponent(l),{ offset: p } = su(n in i || n in o ? { channel: n, markDef: o, encoding: i, model: e } : { channel: l, markDef: o, encoding: i, model: e });if (!f && ("x2" === n || "y2" === n) && (i.latitude || i.longitude)) {const t = mt(n),i = e.markDef[t];return null != i ? { [t]: { value: i } } : { [u]: { field: e.getName(n) } };}const g = function (e) {let { channel: t, channelDef: n, channel2Def: i, markDef: r, config: o, scaleName: a, scale: s, stack: l, offset: c, defaultRef: u } = e;if (aa(n) && l && t.charAt(0) === l.fieldChannel.charAt(0)) return xo(n, a, { suffix: "start" }, { offset: c });return yo({ channel: t, channelDef: i, scaleName: a, scale: s, stack: l, markDef: r, config: o, offset: c, defaultRef: u });}({ channel: n, channelDef: f, channel2Def: i[n], markDef: o, config: s, scaleName: d, scale: m, stack: a, offset: p, defaultRef: void 0 });if (void 0 !== g) return { [u]: g };return gu(n, o) || gu(n, { [n]: Wn(n, o, s.style), [c]: Wn(c, o, s.style) }) || gu(n, s[r]) || gu(n, s.mark) || { [u]: cu({ model: e, defaultPos: t, channel: n, scaleName: d, scale: m })() };}(t, r, s);return _objectSpread(_objectSpread({}, lu(e, t, { defaultPos: i, vgChannel: c[l] ? du(e, o, a) : ft(e) })), c);}function gu(e, t) {const n = mt(e),i = ft(e);if (void 0 !== t[i]) return { [i]: ko(e, t[i]) };if (void 0 !== t[e]) return { [i]: ko(e, t[e]) };if (t[n]) {const i = t[n];if (!mo(i)) return { [n]: ko(e, i) };Ni(function (e) {return "Position range does not support relative band size for ".concat(e, ".");}(n));}}function hu(e, n) {var _ref8, _r$l;const { config: i, encoding: r, markDef: o } = e,a = o.type,s = dt(n),l = mt(n),c = r[n],u = r[s],f = e.getScaleComponent(n),d = f ? f.get("type") : void 0,m = o.orient,p = (_ref8 = (_r$l = r[l]) !== null && _r$l !== void 0 ? _r$l : r.size) !== null && _ref8 !== void 0 ? _ref8 : Un("size", o, i, { vgChannel: l }),g = pt(n),h = "bar" === a && ("x" === n ? "vertical" === m : "horizontal" === m);return !ea(c) || !(yn(c.bin) || vn(c.bin) || c.timeUnit && !u) || p && !mo(p) || r[g] || _r(d) ? (aa(c) && _r(d) || h) && !u ? function (e, n, i, _ref9, _ref10) {const { markDef: r, encoding: o, config: a, stack: s } = i,l = r.orient,c = i.scaleName(n),u = i.getScaleComponent(n),f = mt(n),d = dt(n),m = pt(n),p = i.scaleName(m),g = i.getScaleComponent(gt(n)),h = "horizontal" === l && "y" === n || "vertical" === l && "x" === n;let y;(o.size || r.size) && (h ? y = ru("size", i, { vgChannel: f, defaultRef: Tn(r.size) }) : Ni(function (e) {return "Cannot apply size to non-oriented mark \"".concat(e, "\".");}(r.type)));const v = !!y,b = Yo({ channel: n, fieldDef: e, markDef: r, config: a, scaleType: (_ref9 = u || g) === null || _ref9 === void 0 ? void 0 : _ref9.get("type"), useVlSizeChannel: h });y = y || { [f]: yu(f, p || c, g || u, a, b, !!e, r.type) };const x = "band" === ((_ref10 = u || g) === null || _ref10 === void 0 ? void 0 : _ref10.get("type")) && mo(b) && !v ? "top" : "middle",$ = du(n, r, a, x),w = "xc" === $ || "yc" === $,{ offset: k, offsetType: S } = su({ channel: n, markDef: r, encoding: o, model: i, bandPosition: w ? .5 : 0 }),D = yo({ channel: n, channelDef: e, markDef: r, config: a, scaleName: c, scale: u, stack: s, offset: k, defaultRef: cu({ model: i, defaultPos: "mid", channel: n, scaleName: c, scale: u }), bandPosition: w ? "encoding" === S ? 0 : .5 : Fn(b) ? { signal: "(1-".concat(b, ")/2") } : mo(b) ? (1 - b.band) / 2 : 0 });if (f) return _objectSpread({ [$]: D }, y);{const e = ft(d),n = y[f],i = k ? _objectSpread(_objectSpread({}, n), {}, { offset: k }) : n;return { [$]: D, [e]: t.isArray(D) ? [D[0], _objectSpread(_objectSpread({}, D[1]), {}, { offset: i })] : _objectSpread(_objectSpread({}, D), {}, { offset: i }) };}}(c, n, e) : pu(n, e, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" }) : function (e, _r$component$axes$i, _m$get, _Un3) {let { fieldDef: t, fieldDef2: n, channel: i, model: r } = e;const { config: o, markDef: a, encoding: s } = r,l = r.getScaleComponent(i),c = r.scaleName(i),u = l ? l.get("type") : void 0,f = l.get("reverse"),d = Yo({ channel: i, fieldDef: t, markDef: a, config: o, scaleType: u }),m = (_r$component$axes$i = r.component.axes[i]) === null || _r$component$axes$i === void 0 ? void 0 : _r$component$axes$i[0],p = (_m$get = m === null || m === void 0 ? void 0 : m.get("translate")) !== null && _m$get !== void 0 ? _m$get : .5,g = Et(i) ? (_Un3 = Un("binSpacing", a, o)) !== null && _Un3 !== void 0 ? _Un3 : 0 : 0,h = dt(i),y = ft(i),v = ft(h),b = Rn("minBandSize", a, o),{ offset: x } = su({ channel: i, markDef: a, encoding: s, model: r, bandPosition: 0 }),{ offset: $ } = su({ channel: h, markDef: a, encoding: s, model: r, bandPosition: 0 }),w = function (e) {let { scaleName: t, fieldDef: n } = e;const i = pa(n, { expr: "datum" });return "abs(scale(\"".concat(t, "\", ").concat(pa(n, { expr: "datum", suffix: "end" }), ") - scale(\"").concat(t, "\", ").concat(i, "))");}({ fieldDef: t, scaleName: c }),k = vu(i, g, f, p, x, b, w),S = vu(h, g, f, p, $ !== null && $ !== void 0 ? $ : x, b, w),D = Fn(d) ? { signal: "(1-".concat(d.signal, ")/2") } : mo(d) ? (1 - d.band) / 2 : .5,F = Go({ fieldDef: t, fieldDef2: n, markDef: a, config: o });if (yn(t.bin) || t.timeUnit) {const e = t.timeUnit && .5 !== F;return { [v]: bu({ fieldDef: t, scaleName: c, bandPosition: D, offset: S, useRectOffsetField: e }), [y]: bu({ fieldDef: t, scaleName: c, bandPosition: Fn(D) ? { signal: "1-".concat(D.signal) } : 1 - D, offset: k, useRectOffsetField: e }) };}if (vn(t.bin)) {const e = xo(t, c, {}, { offset: S });if (ea(n)) return { [v]: e, [y]: xo(n, c, {}, { offset: k }) };if (bn(t.bin) && t.bin.step) return { [v]: e, [y]: { signal: "scale(\"".concat(c, "\", ").concat(pa(t, { expr: "datum" }), " + ").concat(t.bin.step, ")"), offset: k } };}return void Ni(zi(h));}({ fieldDef: c, fieldDef2: u, channel: n, model: e });}function yu(e, n, i, r, o, a, s) {if (mo(o)) {if (!i) return { mult: o.band, field: { group: e } };{const e = i.get("type");if ("band" === e) {let e = "bandwidth('".concat(n, "')");1 !== o.band && (e = "".concat(o.band, " * ").concat(e));const t = Rn("minBandSize", { type: s }, r);return { signal: t ? "max(".concat(Mn(t), ", ").concat(e, ")") : e };}1 !== o.band && (Ni(function (e) {return "Cannot use the relative band size with ".concat(e, " scale.");}(e)), o = void 0);}} else {if (Fn(o)) return o;if (o) return { value: o };}if (i) {const e = i.get("range");if (zn(e) && t.isNumber(e.step)) return { value: e.step - 2 };}if (!a) {const { bandPaddingInner: n, barBandPaddingInner: i, rectBandPaddingInner: o } = r.scale,a = X(n, "bar" === s ? i : o);if (Fn(a)) return { signal: "(1 - (".concat(a.signal, ")) * ").concat(e) };if (t.isNumber(a)) return { signal: "".concat(1 - a, " * ").concat(e) };}return { value: Bs(r.view, e) - 2 };}function vu(e, t, n, i, r, o, a) {if (We(e)) return 0;const s = "x" === e || "y2" === e,l = s ? -t / 2 : t / 2;if (Fn(n) || Fn(r) || Fn(i) || o) {const e = Mn(n),t = Mn(r),c = Mn(i),u = Mn(o),f = o ? "(".concat(a, " < ").concat(u, " ? ").concat(s ? "" : "-", "0.5 * (").concat(u, " - (").concat(a, ")) : ").concat(l, ")") : l;return { signal: (c ? "".concat(c, " + ") : "") + (e ? "(".concat(e, " ? -1 : 1) * ") : "") + (t ? "(".concat(t, " + ").concat(f, ")") : f) };}return r = r || 0, i + (n ? -r - l : +r + l);}function bu(e) {let { fieldDef: t, scaleName: n, bandPosition: i, offset: r, useRectOffsetField: o } = e;return $o(_objectSpread({ scaleName: n, fieldOrDatumDef: t, bandPosition: i, offset: r }, o ? { startSuffix: Pc, endSuffix: Ac } : {}));}const xu = new Set(["aria", "width", "height"]);function $u(e, t) {const { fill: n, stroke: i } = "include" === t.color ? ou(e) : {};return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, ku(e.markDef, t)), wu(e, "fill", n)), wu(e, "stroke", i)), ru("opacity", e)), ru("fillOpacity", e)), ru("strokeOpacity", e)), ru("strokeWidth", e)), ru("strokeDash", e)), au(e)), Kc(e)), Jc(e, "href")), tu(e));}function wu(e, n, i) {const { config: r, mark: o, markDef: a } = e;if ("hide" === Un("invalid", a, r) && i && !oo(o)) {const r = function (e, t) {let { invalid: n = !1, channels: i } = t;const r = i.reduce((t, n) => {const i = e.getScaleComponent(n);if (i) {const r = i.get("type"),o = e.vgField(n, { expr: "datum" });o && Nr(r) && (t[o] = !0);}return t;}, {}),o = j(r);if (o.length > 0) {const e = n ? "||" : "&&";return o.map((e) => bo(e, n)).join(" ".concat(e, " "));}return;}(e, { invalid: !0, channels: Zt });if (r) return { [n]: [{ test: r, value: null }, ...t.array(i)] };}return i ? { [n]: i } : {};}function ku(e, t) {return _n.reduce((n, i) => (xu.has(i) || void 0 === e[i] || "ignore" === t[i] || (n[i] = Tn(e[i])), n), {});}function Su(e) {const { config: t, markDef: n } = e;if (Un("invalid", n, t)) {const t = function (e, t) {let { invalid: n = !1, channels: i } = t;const r = i.reduce((t, n) => {const i = e.getScaleComponent(n);if (i) {var _e$stack;const r = i.get("type"),o = e.vgField(n, { expr: "datum", binSuffix: (_e$stack = e.stack) !== null && _e$stack !== void 0 && _e$stack.impute ? "mid" : void 0 });o && Nr(r) && (t[o] = !0);}return t;}, {}),o = j(r);if (o.length > 0) {const e = n ? "||" : "&&";return o.map((e) => bo(e, n)).join(" ".concat(e, " "));}return;}(e, { channels: Tt });if (t) return { defined: { signal: t } };}return {};}function Du(e, t) {if (void 0 !== t) return { [e]: Tn(t) };}const Fu = "voronoi",zu = { defined: (e) => "point" === e.type && e.nearest, parse: (e, t) => {if (t.events) for (const n of t.events) n.markname = e.getName(Fu);}, marks: (e, t, n) => {const { x: i, y: r } = t.project.hasChannel,o = e.mark;if (oo(o)) return Ni("The \"nearest\" transform is not supported for ".concat(o, " marks.")), n;const a = { name: e.getName(Fu), type: "path", interactive: !0, from: { data: e.getName("marks") }, encode: { update: _objectSpread({ fill: { value: "transparent" }, strokeWidth: { value: .35 }, stroke: { value: "transparent" }, isVoronoi: { value: !0 } }, Kc(e, { reactiveGeom: !0 })) }, transform: [{ type: "voronoi", x: { expr: i || !r ? "datum.datum.x || 0" : "0" }, y: { expr: r || !i ? "datum.datum.y || 0" : "0" }, size: [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] }] };let s = 0,l = !1;return n.forEach((t, n) => {var _t$name;const i = (_t$name = t.name) !== null && _t$name !== void 0 ? _t$name : "";i === e.component.mark[0].name ? s = n : i.indexOf(Fu) >= 0 && (l = !0);}), l || n.splice(s + 1, 0, a), n;} },Ou = { defined: (e) => "point" === e.type && "global" === e.resolve && e.bind && "scales" !== e.bind && !Cs(e.bind), parse: (e, t, n) => Yu(t, n), topLevelSignals: (e, n, i) => {const r = n.name,o = n.project,a = n.bind,s = n.init && n.init[0],l = zu.defined(n) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";return o.items.forEach((e, o) => {var _ref11, _a$e$field;const c = L("".concat(r, "_").concat(e.field));i.filter((e) => e.name === c).length || i.unshift(_objectSpread(_objectSpread({ name: c }, s ? { init: wc(s[o]) } : { value: null }), {}, { on: n.events ? [{ events: n.events, update: "datum && item().mark.marktype !== 'group' ? ".concat(l, "[").concat(t.stringValue(e.field), "] : null") }] : [], bind: (_ref11 = (_a$e$field = a[e.field]) !== null && _a$e$field !== void 0 ? _a$e$field : a[e.channel]) !== null && _ref11 !== void 0 ? _ref11 : a }));}), i;}, signals: (e, t, n) => {const i = t.name,r = t.project,o = n.filter((e) => e.name === i + Wu)[0],a = i + Mc,s = r.items.map((e) => L("".concat(i, "_").concat(e.field))),l = s.map((e) => "".concat(e, " !== null")).join(" && ");return s.length && (o.update = "".concat(l, " ? {fields: ").concat(a, ", values: [").concat(s.join(", "), "]} : null")), delete o.value, delete o.on, n;} },_u = "_toggle",Nu = { defined: (e) => "point" === e.type && !!e.toggle, signals: (e, t, n) => n.concat({ name: t.name + _u, value: !1, on: [{ events: t.events, update: t.toggle }] }), modifyExpr: (e, t) => {const n = t.name + Wu,i = t.name + _u;return "".concat(i, " ? null : ").concat(n, ", ") + ("global" === t.resolve ? "".concat(i, " ? null : true, ") : "".concat(i, " ? null : {unit: ").concat(Vu(e), "}, ")) + "".concat(i, " ? ").concat(n, " : null");} },Cu = { defined: (e) => void 0 !== e.clear && !1 !== e.clear, parse: (e, n) => {n.clear && (n.clear = t.isString(n.clear) ? t.parseSelector(n.clear, "view") : n.clear);}, topLevelSignals: (e, t, n) => {if (Ou.defined(t)) for (const e of t.project.items) {const i = n.findIndex((n) => n.name === L("".concat(t.name, "_").concat(e.field)));-1 !== i && n[i].on.push({ events: t.clear, update: "null" });}return n;}, signals: (e, t, n) => {function i(e, i) {-1 !== e && n[e].on && n[e].on.push({ events: t.clear, update: i });}if ("interval" === t.type) for (const e of t.project.items) {const t = n.findIndex((t) => t.name === e.signals.visual);if (i(t, "[0, 0]"), -1 === t) {i(n.findIndex((t) => t.name === e.signals.data), "null");}} else {let e = n.findIndex((e) => e.name === t.name + Wu);i(e, "null"), Nu.defined(t) && (e = n.findIndex((e) => e.name === t.name + _u), i(e, "false"));}return n;} },Pu = { defined: (e) => {const t = "global" === e.resolve && e.bind && Cs(e.bind),n = 1 === e.project.items.length && e.project.items[0].field !== _s;return t && !n && Ni("Legend bindings are only supported for selections over an individual field or encoding channel."), t && n;}, parse: (e, n, i) => {const r = y(i);if (r.select = t.isString(r.select) ? { type: r.select, toggle: n.toggle } : _objectSpread(_objectSpread({}, r.select), {}, { toggle: n.toggle }), Yu(n, r), t.isObject(i.select) && (i.select.on || i.select.clear)) {const e = 'event.item && indexof(event.item.mark.role, "legend") < 0';for (const i of n.events) {var _i$filter;i.filter = t.array((_i$filter = i.filter) !== null && _i$filter !== void 0 ? _i$filter : []), i.filter.includes(e) || i.filter.push(e);}}const o = Ps(n.bind) ? n.bind.legend : "click",a = t.isString(o) ? t.parseSelector(o, "view") : t.array(o);n.bind = { legend: { merge: a } };}, topLevelSignals: (e, t, n) => {const i = t.name,r = Ps(t.bind) && t.bind.legend,o = (e) => (t) => {const n = y(t);return n.markname = e, n;};for (const e of t.project.items) {if (!e.hasLegend) continue;const a = "".concat(L(e.field), "_legend"),s = "".concat(i, "_").concat(a);if (0 === n.filter((e) => e.name === s).length) {const e = r.merge.map(o("".concat(a, "_symbols"))).concat(r.merge.map(o("".concat(a, "_labels")))).concat(r.merge.map(o("".concat(a, "_entries"))));n.unshift(_objectSpread(_objectSpread({ name: s }, t.init ? {} : { value: null }), {}, { on: [{ events: e, update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value", force: !0 }, { events: r.merge, update: "!event.item || !datum ? null : ".concat(s), force: !0 }] }));}}return n;}, signals: (e, t, n) => {const i = t.name,r = t.project,o = n.find((e) => e.name === i + Wu),a = i + Mc,s = r.items.filter((e) => e.hasLegend).map((e) => L("".concat(i, "_").concat(L(e.field), "_legend"))),l = "".concat(s.map((e) => "".concat(e, " !== null")).join(" && "), " ? {fields: ").concat(a, ", values: [").concat(s.join(", "), "]} : null");t.events && s.length > 0 ? o.on.push({ events: s.map((e) => ({ signal: e })), update: l }) : s.length > 0 && (o.update = l, delete o.value, delete o.on);const c = n.find((e) => e.name === i + _u),u = Ps(t.bind) && t.bind.legend;return c && (t.events ? c.on.push(_objectSpread(_objectSpread({}, c.on[0]), {}, { events: u })) : c.on[0].events = u), n;} };const Au = "_translate_anchor",ju = "_translate_delta",Tu = { defined: (e) => "interval" === e.type && e.translate, signals: (e, n, i) => {const r = n.name,o = Uc.defined(n),a = r + Au,{ x: s, y: l } = n.project.hasChannel;let c = t.parseSelector(n.translate, "scope");return o || (c = c.map((e) => (e.between[0].markname = r + Bc, e))), i.push({ name: a, value: {}, on: [{ events: c.map((e) => e.between[0]), update: "{x: x(unit), y: y(unit)" + (void 0 !== s ? ", extent_x: ".concat(o ? Rc(e, le) : "slice(".concat(s.signals.visual, ")")) : "") + (void 0 !== l ? ", extent_y: ".concat(o ? Rc(e, ce) : "slice(".concat(l.signals.visual, ")")) : "") + "}" }] }, { name: r + ju, value: {}, on: [{ events: c, update: "{x: ".concat(a, ".x - x(unit), y: ").concat(a, ".y - y(unit)}") }] }), void 0 !== s && Eu(e, n, s, "width", i), void 0 !== l && Eu(e, n, l, "height", i), i;} };function Eu(e, t, n, i, r) {var _d$get, _d$get2;const o = t.name,a = o + Au,s = o + ju,l = n.channel,c = Uc.defined(t),u = r.filter((e) => e.name === n.signals[c ? "data" : "visual"])[0],f = e.getSizeSignalRef(i).signal,d = e.getScaleComponent(l),m = d && d.get("type"),p = d && d.get("reverse"),g = "".concat(a, ".extent_").concat(l),h = "".concat(c && d ? "log" === m ? "panLog" : "symlog" === m ? "panSymlog" : "pow" === m ? "panPow" : "panLinear" : "panLinear", "(").concat(g, ", ", "".concat(c ? l === le ? p ? "" : "-" : p ? "-" : "" : "").concat(s, ".").concat(l, " / ").concat(c ? "".concat(f) : "span(".concat(g, ")"))).concat(c ? "pow" === m ? ", ".concat((_d$get = d.get("exponent")) !== null && _d$get !== void 0 ? _d$get : 1) : "symlog" === m ? ", ".concat((_d$get2 = d.get("constant")) !== null && _d$get2 !== void 0 ? _d$get2 : 1) : "" : "", ")");u.on.push({ events: { signal: s }, update: c ? h : "clampRange(".concat(h, ", 0, ").concat(f, ")") });}const Mu = "_zoom_anchor",Lu = "_zoom_delta",qu = { defined: (e) => "interval" === e.type && e.zoom, signals: (e, n, i) => {const r = n.name,o = Uc.defined(n),a = r + Lu,{ x: s, y: l } = n.project.hasChannel,c = t.stringValue(e.scaleName(le)),u = t.stringValue(e.scaleName(ce));let f = t.parseSelector(n.zoom, "scope");return o || (f = f.map((e) => (e.markname = r + Bc, e))), i.push({ name: r + Mu, on: [{ events: f, update: o ? "{" + [c ? "x: invert(".concat(c, ", x(unit))") : "", u ? "y: invert(".concat(u, ", y(unit))") : ""].filter((e) => e).join(", ") + "}" : "{x: x(unit), y: y(unit)}" }] }, { name: a, on: [{ events: f, force: !0, update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))" }] }), void 0 !== s && Uu(e, n, s, "width", i), void 0 !== l && Uu(e, n, l, "height", i), i;} };function Uu(e, t, n, i, r) {var _u$get, _u$get2;const o = t.name,a = n.channel,s = Uc.defined(t),l = r.filter((e) => e.name === n.signals[s ? "data" : "visual"])[0],c = e.getSizeSignalRef(i).signal,u = e.getScaleComponent(a),f = u && u.get("type"),d = s ? Rc(e, a) : l.name,m = o + Lu,p = "".concat(s && u ? "log" === f ? "zoomLog" : "symlog" === f ? "zoomSymlog" : "pow" === f ? "zoomPow" : "zoomLinear" : "zoomLinear", "(").concat(d, ", ", "".concat(o).concat(Mu, ".").concat(a), ", ").concat(m).concat(s ? "pow" === f ? ", ".concat((_u$get = u.get("exponent")) !== null && _u$get !== void 0 ? _u$get : 1) : "symlog" === f ? ", ".concat((_u$get2 = u.get("constant")) !== null && _u$get2 !== void 0 ? _u$get2 : 1) : "" : "", ")");l.on.push({ events: { signal: m }, update: s ? p : "clampRange(".concat(p, ", 0, ").concat(c, ")") });}const Ru = "_store",Wu = "_tuple",Bu = "_modify",Iu = "vlSelectionResolve",Hu = [Yc, Gc, qc, Nu, Ou, Uc, Pu, Cu, Tu, qu, zu];function Vu(e) {let { escape: n } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { escape: !0 },i = n ? t.stringValue(e.name) : e.name;const r = function (e) {let t = e.parent;for (; t && !Nm(t);) t = t.parent;return t;}(e);if (r) {const { facet: e } = r;for (const n of Je) e[n] && (i += " + '__facet_".concat(n, "_' + (facet[").concat(t.stringValue(r.vgField(n)), "])"));}return i;}function Gu(e) {var _e$component$selectio4;return T((_e$component$selectio4 = e.component.selection) !== null && _e$component$selectio4 !== void 0 ? _e$component$selectio4 : {}).reduce((e, t) => e || t.project.hasSelectionId, !1);}function Yu(e, n) {!t.isString(n.select) && n.select.on || delete e.events, !t.isString(n.select) && n.select.clear || delete e.clear, !t.isString(n.select) && n.select.toggle || delete e.toggle;}function Xu(e) {const t = [];return "Identifier" === e.type ? [e.name] : "Literal" === e.type ? [e.value] : ("MemberExpression" === e.type && (t.push(...Xu(e.object)), t.push(...Xu(e.property))), t);}function Ju(e) {return "MemberExpression" === e.object.type ? Ju(e.object) : "datum" === e.object.name;}function Qu(e) {const n = t.parseExpression(e),i = new Set();return n.visit((e) => {"MemberExpression" === e.type && Ju(e) && i.add(Xu(e).slice(1).join("."));}), i;}class Ku extends zc {clone() {return new Ku(null, this.model, y(this.filter));}constructor(e, t, n) {super(e), this.model = t, this.filter = n, Yn(this, "expr", void 0), Yn(this, "_dependentFields", void 0), this.expr = tf(this.model, this.filter, this), this._dependentFields = Qu(this.expr);}dependentFields() {return this._dependentFields;}producedFields() {return new Set();}assemble() {return { type: "filter", expr: this.expr };}hash() {return "Filter ".concat(this.expr);}}function Zu(e, n, i) {let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "datum";const o = t.isString(n) ? n : n.param,a = L(o),s = t.stringValue(a + Ru);let l;try {l = e.getSelectionComponent(a, o);} catch (e) {return "!!".concat(a);}if (l.project.timeUnit) {const t = i !== null && i !== void 0 ? i : e.component.data.raw,n = l.project.timeUnit.clone();t.parent ? n.insertAsParentOf(t) : t.parent = n;}const c = "".concat(l.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(").concat(s, ", ").concat(r).concat("global" === l.resolve ? ")" : ", ".concat(t.stringValue(l.resolve), ")")),u = "length(data(".concat(s, "))");return !1 === n.empty ? "".concat(u, " && ").concat(c) : "!".concat(u, " || ").concat(c);}function ef(e, n, i) {const r = L(n),o = i.encoding;let a,s = i.field;try {a = e.getSelectionComponent(r, n);} catch (e) {return r;}if (o || s) {if (o && !s) {const e = a.project.items.filter((e) => e.channel === o);!e.length || e.length > 1 ? (s = a.project.items[0].field, Ni((e.length ? "Multiple " : "No ") + "matching ".concat(t.stringValue(o), " encoding found for selection ").concat(t.stringValue(i.param), ". ") + "Using \"field\": ".concat(t.stringValue(s), "."))) : s = e[0].field;}} else s = a.project.items[0].field, a.project.items.length > 1 && Ni("A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. Using \"field\": ".concat(t.stringValue(s), "."));return "".concat(a.name, "[").concat(t.stringValue(H(s)), "]");}function tf(e, n, i) {return q(n, (n) => t.isString(n) ? n : function (e) {return e === null || e === void 0 ? void 0 : e.param;}(n) ? Zu(e, n, i) : lr(n));}function nf(e, t, n, i) {var _e$encode, _e$encode2, _e$encode2$t, _e$encode$t, _e$encode$t$update;(_e$encode = e.encode) !== null && _e$encode !== void 0 ? _e$encode : e.encode = {}, (_e$encode2$t = (_e$encode2 = e.encode)[t]) !== null && _e$encode2$t !== void 0 ? _e$encode2$t : _e$encode2[t] = {}, (_e$encode$t$update = (_e$encode$t = e.encode[t]).update) !== null && _e$encode$t$update !== void 0 ? _e$encode$t$update : _e$encode$t.update = {}, e.encode[t].update[n] = i;}function rf(e, n, i) {let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : { header: !1 };const _e$combine = e.combine(),{ disable: o, orient: a, scale: s, labelExpr: l, title: c, zindex: u } = _e$combine,f = _objectWithoutProperties(_e$combine, _excluded48);if (!o) {for (const e in f) {const i = Ma[e],r = f[e];if (i && i !== n && "both" !== i) delete f[e];else if (Ta(r)) {const { condition: n } = r,i = _objectWithoutProperties(r, _excluded49),o = t.array(n),a = ja[e];if (a) {const { vgProp: t, part: n } = a;nf(f, n, t, [...o.map((e) => {const { test: t } = e,n = _objectWithoutProperties(e, _excluded50);return _objectSpread({ test: tf(null, t) }, n);}), i]), delete f[e];} else if (null === a) {const t = { signal: o.map((e) => {const { test: t } = e,n = _objectWithoutProperties(e, _excluded51);return "".concat(tf(null, t), " ? ").concat(En(n), " : ");}).join("") + En(i) };f[e] = t;}} else if (Fn(r)) {const t = ja[e];if (t) {const { vgProp: n, part: i } = t;nf(f, i, n, r), delete f[e];}}k(["labelAlign", "labelBaseline"], e) && null === f[e] && delete f[e];}if ("grid" === n) {if (!f.grid) return;if (f.encode) {const { grid: e } = f.encode;f.encode = _objectSpread({}, e ? { grid: e } : {}), A(f.encode) && delete f.encode;}return _objectSpread(_objectSpread({ scale: s, orient: a }, f), {}, { domain: !1, labels: !1, aria: !1, maxExtent: 0, minExtent: 0, ticks: !1, zindex: X(u, 0) });}{if (!r.header && e.mainExtracted) return;if (void 0 !== l) {var _f$encode;let e = l;(_f$encode = f.encode) !== null && _f$encode !== void 0 && (_f$encode = _f$encode.labels) !== null && _f$encode !== void 0 && _f$encode.update && Fn(f.encode.labels.update.text) && (e = V(l, "datum.label", f.encode.labels.update.text.signal)), nf(f, "labels", "text", { signal: e });}if (null === f.labelAlign && delete f.labelAlign, f.encode) {for (const t of Ea) e.hasAxisPart(t) || delete f.encode[t];A(f.encode) && delete f.encode;}const n = function (e, n) {if (e) return t.isArray(e) && !Dn(e) ? e.map((e) => $a(e, n)).join(", ") : e;}(c, i);return _objectSpread(_objectSpread(_objectSpread(_objectSpread({ scale: s, orient: a, grid: !1 }, n ? { title: n } : {}), f), !1 === i.aria ? { aria: !1 } : {}), {}, { zindex: X(u, 0) });}}}function of(e) {const { axes: t } = e.component,n = [];for (const i of Tt) if (t[i]) for (const r of t[i]) if (!r.get("disable") && !r.get("gridScale")) {const t = "x" === i ? "height" : "width",r = e.getSizeSignalRef(t).signal;t !== r && n.push({ name: t, update: r });}return n;}function af(e, t, n, i) {return Object.assign.apply(null, [{}, ...e.map((e) => {if ("axisOrient" === e) {const e = "x" === n ? "bottom" : "left",r = t["x" === n ? "axisBottom" : "axisLeft"] || {},o = t["x" === n ? "axisTop" : "axisRight"] || {},a = new Set([...j(r), ...j(o)]),s = {};for (const t of a.values()) s[t] = { signal: "".concat(i.signal, " === \"").concat(e, "\" ? ").concat(Mn(r[t]), " : ").concat(Mn(o[t])) };return s;}return t[e];})]);}function sf(e, n) {const i = [{}];for (const r of e) {var _n$r;let e = (_n$r = n[r]) === null || _n$r === void 0 ? void 0 : _n$r.style;if (e) {e = t.array(e);for (const t of e) i.push(n.style[t]);}}return Object.assign.apply(null, i);}function lf(e, t, n) {let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};const r = Bn(e, n, t);if (void 0 !== r) return { configFrom: "style", configValue: r };for (const t of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {var _i$t;if (void 0 !== ((_i$t = i[t]) === null || _i$t === void 0 ? void 0 : _i$t[e])) return { configFrom: t, configValue: i[t][e] };}return {};}const cf = { scale: (e) => {let { model: t, channel: n } = e;return t.scaleName(n);}, format: (e) => {let { format: t } = e;return t;}, formatType: (e) => {let { formatType: t } = e;return t;}, grid: (e) => {var _n$grid;let { fieldOrDatumDef: t, axis: n, scaleType: i } = e;return (_n$grid = n.grid) !== null && _n$grid !== void 0 ? _n$grid : function (e, t) {return !_r(e) && ea(t) && !yn(t === null || t === void 0 ? void 0 : t.bin) && !vn(t === null || t === void 0 ? void 0 : t.bin);}(i, t);}, gridScale: (e) => {let { model: t, channel: n } = e;return function (e, t) {const n = "x" === t ? "y" : "x";if (e.getScaleComponent(n)) return e.scaleName(n);return;}(t, n);}, labelAlign: (e) => {let { axis: t, labelAngle: n, orient: i, channel: r } = e;return t.labelAlign || df(n, i, r);}, labelAngle: (e) => {let { labelAngle: t } = e;return t;}, labelBaseline: (e) => {let { axis: t, labelAngle: n, orient: i, channel: r } = e;return t.labelBaseline || ff(n, i, r);}, labelFlush: (e) => {var _t$labelFlush;let { axis: t, fieldOrDatumDef: n, channel: i } = e;return (_t$labelFlush = t.labelFlush) !== null && _t$labelFlush !== void 0 ? _t$labelFlush : function (e, t) {if ("x" === t && k(["quantitative", "temporal"], e)) return !0;return;}(n.type, i);}, labelOverlap: (e) => {var _n$labelOverlap;let { axis: n, fieldOrDatumDef: i, scaleType: r } = e;return (_n$labelOverlap = n.labelOverlap) !== null && _n$labelOverlap !== void 0 ? _n$labelOverlap : function (e, n, i, r) {if (i && !t.isObject(r) || "nominal" !== e && "ordinal" !== e) return "log" !== n && "symlog" !== n || "greedy";return;}(i.type, r, ea(i) && !!i.timeUnit, ea(i) ? i.sort : void 0);}, orient: (e) => {let { orient: t } = e;return t;}, tickCount: (e) => {var _i$tickCount;let { channel: t, model: n, axis: i, fieldOrDatumDef: r, scaleType: o } = e;const a = "x" === t ? "width" : "y" === t ? "height" : void 0,s = a ? n.getSizeSignalRef(a) : void 0;return (_i$tickCount = i.tickCount) !== null && _i$tickCount !== void 0 ? _i$tickCount : function (e) {let { fieldOrDatumDef: t, scaleType: n, size: i, values: r } = e;if (!r && !_r(n) && "log" !== n) {if (ea(t)) {var _Xi7;if (yn(t.bin)) return { signal: "ceil(".concat(i.signal, "/10)") };if (t.timeUnit && k(["month", "hours", "day", "quarter"], (_Xi7 = Xi(t.timeUnit)) === null || _Xi7 === void 0 ? void 0 : _Xi7.unit)) return;}return { signal: "ceil(".concat(i.signal, "/40)") };}return;}({ fieldOrDatumDef: r, scaleType: o, size: s, values: i.values });}, tickMinStep: function tickMinStep(e) {let { format: t, fieldOrDatumDef: n } = e;if ("d" === t) return 1;if (ea(n)) {const { timeUnit: e } = n;if (e) {const t = Ji(e);if (t) return { signal: t };}}return;}, title: (e) => {let { axis: t, model: n, channel: i } = e;if (void 0 !== t.title) return t.title;const r = mf(n, i);if (void 0 !== r) return r;const o = n.typedFieldDef(i),a = "x" === i ? "x2" : "y2",s = n.fieldDef(a);return Hn(o ? [Ho(o)] : [], ea(s) ? [Ho(s)] : []);}, values: (e) => {let { axis: n, fieldOrDatumDef: i } = e;return function (e, n) {const i = e.values;if (t.isArray(i)) return Pa(n, i);if (Fn(i)) return i;return;}(n, i);}, zindex: (e) => {var _t$zindex;let { axis: t, fieldOrDatumDef: n, mark: i } = e;return (_t$zindex = t.zindex) !== null && _t$zindex !== void 0 ? _t$zindex : function (e, t) {if ("rect" === e && ga(t)) return 1;return 0;}(i, n);} };function uf(e) {return "(((".concat(e.signal, " % 360) + 360) % 360)");}function ff(e, t, n, i) {if (void 0 !== e) {if ("x" === n) {if (Fn(e)) {const n = uf(e);return { signal: "(45 < ".concat(n, " && ").concat(n, " < 135) || (225 < ").concat(n, " && ").concat(n, " < 315) ? \"middle\" :(").concat(n, " <= 45 || 315 <= ").concat(n, ") === ").concat(Fn(t) ? "(".concat(t.signal, " === \"top\")") : "top" === t, " ? \"bottom\" : \"top\"") };}if (45 < e && e < 135 || 225 < e && e < 315) return "middle";if (Fn(t)) {const n = e <= 45 || 315 <= e ? "===" : "!==";return { signal: "".concat(t.signal, " ").concat(n, " \"top\" ? \"bottom\" : \"top\"") };}return (e <= 45 || 315 <= e) == ("top" === t) ? "bottom" : "top";}if (Fn(e)) {const n = uf(e);return { signal: "".concat(n, " <= 45 || 315 <= ").concat(n, " || (135 <= ").concat(n, " && ").concat(n, " <= 225) ? ").concat(i ? '"middle"' : "null", " : (45 <= ").concat(n, " && ").concat(n, " <= 135) === ").concat(Fn(t) ? "(".concat(t.signal, " === \"left\")") : "left" === t, " ? \"top\" : \"bottom\"") };}if (e <= 45 || 315 <= e || 135 <= e && e <= 225) return i ? "middle" : null;if (Fn(t)) {const n = 45 <= e && e <= 135 ? "===" : "!==";return { signal: "".concat(t.signal, " ").concat(n, " \"left\" ? \"top\" : \"bottom\"") };}return (45 <= e && e <= 135) == ("left" === t) ? "top" : "bottom";}}function df(e, t, n) {if (void 0 === e) return;const i = "x" === n,r = i ? 0 : 90,o = i ? "bottom" : "left";if (Fn(e)) {const n = uf(e);return { signal: "(".concat(r ? "(".concat(n, " + 90)") : n, " % 180 === 0) ? ").concat(i ? null : '"center"', " :(").concat(r, " < ").concat(n, " && ").concat(n, " < ").concat(180 + r, ") === ").concat(Fn(t) ? "(".concat(t.signal, " === \"").concat(o, "\")") : t === o, " ? \"left\" : \"right\"") };}if ((e + r) % 180 == 0) return i ? null : "center";if (Fn(t)) {const n = r < e && e < 180 + r ? "===" : "!==";return { signal: "".concat("".concat(t.signal, " ").concat(n, " \"").concat(o, "\""), " ? \"left\" : \"right\"") };}return (r < e && e < 180 + r) == (t === o) ? "left" : "right";}function mf(e, t) {const n = "x" === t ? "x2" : "y2",i = e.fieldDef(t),r = e.fieldDef(n),o = i ? i.title : void 0,a = r ? r.title : void 0;return o && a ? Vn(o, a) : o || a || (void 0 !== o ? o : void 0 !== a ? a : void 0);}class pf extends zc {clone() {return new pf(null, y(this.transform));}constructor(e, t) {super(e), this.transform = t, Yn(this, "_dependentFields", void 0), this._dependentFields = Qu(this.transform.calculate);}static parseAllForSortIndex(e, t) {return t.forEachFieldDef((t, n) => {if (ca(t) && Ro(t.sort)) {const { field: i, timeUnit: r } = t,o = t.sort,a = o.map((e, t) => "".concat(lr({ field: i, timeUnit: r, equal: e }), " ? ").concat(t, " : ")).join("") + o.length;e = new pf(e, { calculate: a, as: gf(t, n, { forAs: !0 }) });}}), e;}producedFields() {return new Set([this.transform.as]);}dependentFields() {return this._dependentFields;}assemble() {return { type: "formula", expr: this.transform.calculate, as: this.transform.as };}hash() {return "Calculate ".concat($(this.transform));}}function gf(e, t, n) {return pa(e, _objectSpread({ prefix: t, suffix: "sort_index" }, n !== null && n !== void 0 ? n : {}));}function hf(e, t) {return k(["top", "bottom"], t) ? "column" : k(["left", "right"], t) || "row" === e ? "row" : "column";}function yf(e, t, n, i) {const r = "row" === i ? n.headerRow : "column" === i ? n.headerColumn : n.headerFacet;return X((t || {})[e], r[e], n.header[e]);}function vf(e, t, n, i) {const r = {};for (const o of e) {const e = yf(o, t || {}, n, i);void 0 !== e && (r[o] = e);}return r;}const bf = ["row", "column"],xf = ["header", "footer"];function $f(e, t) {const n = e.component.layoutHeaders[t].title,i = e.config ? e.config : void 0,r = e.component.layoutHeaders[t].facetFieldDef ? e.component.layoutHeaders[t].facetFieldDef : void 0,{ titleAnchor: o, titleAngle: a, titleOrient: s } = vf(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, t),l = hf(t, s),c = ee(a);return { name: "".concat(t, "-title"), type: "group", role: "".concat(l, "-title"), title: _objectSpread(_objectSpread(_objectSpread(_objectSpread({ text: n }, "row" === t ? { orient: "left" } : {}), {}, { style: "guide-title" }, kf(c, l)), wf(l, c, o)), Nf(i, r, t, Ds, ks)) };}function wf(e, t) {switch (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "middle") {case "start":return { align: "left" };case "end":return { align: "right" };}const n = df(t, "row" === e ? "left" : "top", "row" === e ? "y" : "x");return n ? { align: n } : {};}function kf(e, t) {const n = ff(e, "row" === t ? "left" : "top", "row" === t ? "y" : "x", !0);return n ? { baseline: n } : {};}function Sf(e, t) {const n = e.component.layoutHeaders[t],i = [];for (const r of xf) if (n[r]) for (const o of n[r]) {const a = zf(e, t, r, n, o);null != a && i.push(a);}return i;}function Df(e, n) {var _i$order;const { sort: i } = e;return Uo(i) ? { field: pa(i, { expr: "datum" }), order: (_i$order = i.order) !== null && _i$order !== void 0 ? _i$order : "ascending" } : t.isArray(i) ? { field: gf(e, n, { expr: "datum" }), order: "ascending" } : { field: pa(e, { expr: "datum" }), order: i !== null && i !== void 0 ? i : "ascending" };}function Ff(e, t, n) {const { format: i, formatType: r, labelAngle: o, labelAnchor: a, labelOrient: s, labelExpr: l } = vf(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t),c = zo({ fieldOrDatumDef: e, format: i, formatType: r, expr: "parent", config: n }).signal,u = hf(t, s);return _objectSpread(_objectSpread(_objectSpread(_objectSpread({ text: { signal: l ? V(V(l, "datum.label", c), "datum.value", pa(e, { expr: "parent" })) : c } }, "row" === t ? { orient: "left" } : {}), {}, { style: "guide-label", frame: "group" }, kf(o, u)), wf(u, o, a)), Nf(n, e, t, Fs, Ss));}function zf(e, t, n, i, r) {if (r) {let o = null;const { facetFieldDef: a } = i,s = e.config ? e.config : void 0;if (a && r.labels) {const { labelOrient: e } = vf(["labelOrient"], a.header, s, t);("row" === t && !k(["top", "bottom"], e) || "column" === t && !k(["left", "right"], e)) && (o = Ff(a, t, s));}const l = Nm(e) && !Wo(e.facet),c = r.axes,u = (c === null || c === void 0 ? void 0 : c.length) > 0;if (o || u) {const s = "row" === t ? "height" : "width";return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({ name: e.getName("".concat(t, "_").concat(n)), type: "group", role: "".concat(t, "-").concat(n) }, i.facetFieldDef ? { from: { data: e.getName("".concat(t, "_domain")) }, sort: Df(a, t) } : {}), u && l ? { from: { data: e.getName("facet_domain_".concat(t)) } } : {}), o ? { title: o } : {}), r.sizeSignal ? { encode: { update: { [s]: r.sizeSignal } } } : {}), u ? { axes: c } : {});}}return null;}const Of = { column: { start: 0, end: 1 }, row: { start: 1, end: 0 } };function _f(e, t) {return Of[t][e];}function Nf(e, t, n, i, r) {const o = {};for (const a of i) {if (!r[a]) continue;const i = yf(a, t === null || t === void 0 ? void 0 : t.header, e, n);void 0 !== i && (o[r[a]] = i);}return o;}function Cf(e) {return [...Pf(e, "width"), ...Pf(e, "height"), ...Pf(e, "childWidth"), ...Pf(e, "childHeight")];}function Pf(e, t) {const n = "width" === t ? "x" : "y",i = e.component.layoutSize.get(t);if (!i || "merged" === i) return [];const r = e.getSizeSignalRef(t).signal;if ("step" === i) {const t = e.getScaleComponent(n);if (t) {const i = t.get("type"),o = t.get("range");if (_r(i) && zn(o)) {const i = e.scaleName(n);if (Nm(e.parent)) {if ("independent" === e.parent.component.resolve.scale[n]) return [Af(i, o)];}return [Af(i, o), { name: r, update: jf(i, t, "domain('".concat(i, "').length")) }];}}throw new Error("layout size is step although width/height is not step.");}if ("container" == i) {const t = r.endsWith("width"),n = t ? "containerSize()[0]" : "containerSize()[1]",i = "isFinite(".concat(n, ") ? ").concat(n, " : ").concat(Ws(e.config.view, t ? "width" : "height"));return [{ name: r, init: i, on: [{ update: i, events: "window:resize" }] }];}return [{ name: r, value: i }];}function Af(e, t) {const n = "".concat(e, "_step");return Fn(t.step) ? { name: n, update: t.step.signal } : { name: n, value: t.step };}function jf(e, t, n) {const i = t.get("type"),r = t.get("padding"),o = X(t.get("paddingOuter"), r);let a = t.get("paddingInner");return a = "band" === i ? void 0 !== a ? a : r : 1, "bandspace(".concat(n, ", ").concat(Mn(a), ", ").concat(Mn(o), ") * ").concat(e, "_step");}function Tf(e) {return "childWidth" === e ? "width" : "childHeight" === e ? "height" : e;}function Ef(e, t) {return j(e).reduce((n, i) => {const r = e[i];return _objectSpread(_objectSpread({}, n), Xc(t, r, i, (e) => Tn(e.value)));}, {});}function Mf(e, t) {if (Nm(t)) return "theta" === e ? "independent" : "shared";if (Pm(t)) return "shared";if (Cm(t)) return Et(e) || "theta" === e || "radius" === e ? "independent" : "shared";throw new Error("invalid model type for resolve");}function Lf(e, t) {const n = e.scale[t],i = Et(t) ? "axis" : "legend";return "independent" === n ? ("shared" === e[i][t] && Ni(function (e) {return "Setting the scale to be independent for \"".concat(e, "\" means we also have to set the guide (axis or legend) to be independent.");}(t)), "independent") : e[i][t] || "shared";}const qf = j({ aria: 1, clipHeight: 1, columnPadding: 1, columns: 1, cornerRadius: 1, description: 1, direction: 1, fillColor: 1, format: 1, formatType: 1, gradientLength: 1, gradientOpacity: 1, gradientStrokeColor: 1, gradientStrokeWidth: 1, gradientThickness: 1, gridAlign: 1, labelAlign: 1, labelBaseline: 1, labelColor: 1, labelFont: 1, labelFontSize: 1, labelFontStyle: 1, labelFontWeight: 1, labelLimit: 1, labelOffset: 1, labelOpacity: 1, labelOverlap: 1, labelPadding: 1, labelSeparation: 1, legendX: 1, legendY: 1, offset: 1, orient: 1, padding: 1, rowPadding: 1, strokeColor: 1, symbolDash: 1, symbolDashOffset: 1, symbolFillColor: 1, symbolLimit: 1, symbolOffset: 1, symbolOpacity: 1, symbolSize: 1, symbolStrokeColor: 1, symbolStrokeWidth: 1, symbolType: 1, tickCount: 1, tickMinStep: 1, title: 1, titleAlign: 1, titleAnchor: 1, titleBaseline: 1, titleColor: 1, titleFont: 1, titleFontSize: 1, titleFontStyle: 1, titleFontWeight: 1, titleLimit: 1, titleLineHeight: 1, titleOpacity: 1, titleOrient: 1, titlePadding: 1, type: 1, values: 1, zindex: 1, disable: 1, labelExpr: 1, selections: 1, opacity: 1, shape: 1, stroke: 1, fill: 1, size: 1, strokeWidth: 1, strokeDash: 1, encode: 1 });class Uf extends ac {}const Rf = { symbols: function symbols(e, n) {var _a$get, _a$get2, _a$get3, _Wf, _u$legend$symbolBaseF;let { fieldOrDatumDef: i, model: r, channel: o, legendCmpt: a, legendType: s } = n;if ("symbol" !== s) return;const { markDef: l, encoding: c, config: u, mark: f } = r,d = l.filled && "trail" !== f;let m = _objectSpread(_objectSpread({}, Ln({}, r, co)), ou(r, { filled: d }));const p = (_a$get = a.get("symbolOpacity")) !== null && _a$get !== void 0 ? _a$get : u.legend.symbolOpacity,g = (_a$get2 = a.get("symbolFillColor")) !== null && _a$get2 !== void 0 ? _a$get2 : u.legend.symbolFillColor,h = (_a$get3 = a.get("symbolStrokeColor")) !== null && _a$get3 !== void 0 ? _a$get3 : u.legend.symbolStrokeColor,y = void 0 === p ? (_Wf = Wf(c.opacity)) !== null && _Wf !== void 0 ? _Wf : l.opacity : void 0;if (m.fill) if ("fill" === o || d && o === we) delete m.fill;else if (m.fill.field) g ? delete m.fill : (m.fill = Tn((_u$legend$symbolBaseF = u.legend.symbolBaseFillColor) !== null && _u$legend$symbolBaseF !== void 0 ? _u$legend$symbolBaseF : "black"), m.fillOpacity = Tn(y !== null && y !== void 0 ? y : 1));else if (t.isArray(m.fill)) {var _ref12, _Bf, _c$fill;const e = (_ref12 = (_Bf = Bf((_c$fill = c.fill) !== null && _c$fill !== void 0 ? _c$fill : c.color)) !== null && _Bf !== void 0 ? _Bf : l.fill) !== null && _ref12 !== void 0 ? _ref12 : d && l.color;e && (m.fill = Tn(e));}if (m.stroke) if ("stroke" === o || !d && o === we) delete m.stroke;else if (m.stroke.field || h) delete m.stroke;else if (t.isArray(m.stroke)) {const e = X(Bf(c.stroke || c.color), l.stroke, d ? l.color : void 0);e && (m.stroke = { value: e });}if (o !== Oe) {const e = ea(i) && Hf(r, a, i);e ? m.opacity = [_objectSpread({ test: e }, Tn(y !== null && y !== void 0 ? y : 1)), Tn(u.legend.unselectedOpacity)] : y && (m.opacity = Tn(y));}return m = _objectSpread(_objectSpread({}, m), e), A(m) ? void 0 : m;}, gradient: function gradient(e, t) {var _r$get;let { model: n, legendType: i, legendCmpt: r } = t;if ("gradient" !== i) return;const { config: o, markDef: a, encoding: s } = n;let l = {};const c = void 0 === ((_r$get = r.get("gradientOpacity")) !== null && _r$get !== void 0 ? _r$get : o.legend.gradientOpacity) ? Wf(s.opacity) || a.opacity : void 0;c && (l.opacity = Tn(c));return l = _objectSpread(_objectSpread({}, l), e), A(l) ? void 0 : l;}, labels: function labels(e, t) {let { fieldOrDatumDef: n, model: i, channel: r, legendCmpt: o } = t;const a = i.legend(r) || {},s = i.config,l = ea(n) ? Hf(i, o, n) : void 0,c = l ? [{ test: l, value: 1 }, { value: s.legend.unselectedOpacity }] : void 0,{ format: u, formatType: f } = a;let d;So(f) ? d = _o({ fieldOrDatumDef: n, field: "datum.value", format: u, formatType: f, config: s }) : void 0 === u && void 0 === f && s.customFormatTypes && ("quantitative" === n.type && s.numberFormatType ? d = _o({ fieldOrDatumDef: n, field: "datum.value", format: s.numberFormat, formatType: s.numberFormatType, config: s }) : "temporal" === n.type && s.timeFormatType && ea(n) && void 0 === n.timeUnit && (d = _o({ fieldOrDatumDef: n, field: "datum.value", format: s.timeFormat, formatType: s.timeFormatType, config: s })));const m = _objectSpread(_objectSpread(_objectSpread({}, c ? { opacity: c } : {}), d ? { text: d } : {}), e);return A(m) ? void 0 : m;}, entries: function entries(e, t) {let { legendCmpt: n } = t;const i = n.get("selections");return i !== null && i !== void 0 && i.length ? _objectSpread(_objectSpread({}, e), {}, { fill: { value: "transparent" } }) : e;} };function Wf(e) {return If(e, (e, t) => Math.max(e, t.value));}function Bf(e) {return If(e, (e, t) => X(e, t.value));}function If(e, n) {return function (e) {const n = e === null || e === void 0 ? void 0 : e.condition;return !!n && (t.isArray(n) || la(n));}(e) ? t.array(e.condition).reduce(n, e.value) : la(e) ? e.value : void 0;}function Hf(e, n, i) {const r = n.get("selections");if (!(r !== null && r !== void 0 && r.length)) return;const o = t.stringValue(i.field);return r.map((e) => "(!length(data(".concat(t.stringValue(L(e) + Ru), ")) || (").concat(e, "[").concat(o, "] && indexof(").concat(e, "[").concat(o, "], datum.value) >= 0))")).join(" || ");}const Vf = { direction: (e) => {let { direction: t } = e;return t;}, format: (e) => {let { fieldOrDatumDef: t, legend: n, config: i } = e;const { format: r, formatType: o } = n;return No(t, t.type, r, o, i, !1);}, formatType: (e) => {let { legend: t, fieldOrDatumDef: n, scaleType: i } = e;const { formatType: r } = t;return Co(r, n, i);}, gradientLength: (e) => {var _ref13, _t$gradientLength;const { legend: t, legendConfig: n } = e;return (_ref13 = (_t$gradientLength = t.gradientLength) !== null && _t$gradientLength !== void 0 ? _t$gradientLength : n.gradientLength) !== null && _ref13 !== void 0 ? _ref13 : function (e) {let { legendConfig: t, model: n, direction: i, orient: r, scaleType: o } = e;const { gradientHorizontalMaxLength: a, gradientHorizontalMinLength: s, gradientVerticalMaxLength: l, gradientVerticalMinLength: c } = t;if (Cr(o)) return "horizontal" === i ? "top" === r || "bottom" === r ? Xf(n, "width", s, a) : s : Xf(n, "height", c, l);return;}(e);}, labelOverlap: (e) => {var _ref14, _t$labelOverlap;let { legend: t, legendConfig: n, scaleType: i } = e;return (_ref14 = (_t$labelOverlap = t.labelOverlap) !== null && _t$labelOverlap !== void 0 ? _t$labelOverlap : n.labelOverlap) !== null && _ref14 !== void 0 ? _ref14 : function (e) {if (k(["quantile", "threshold", "log", "symlog"], e)) return "greedy";return;}(i);}, symbolType: (e) => {var _t$symbolType;let { legend: t, markDef: n, channel: i, encoding: r } = e;return (_t$symbolType = t.symbolType) !== null && _t$symbolType !== void 0 ? _t$symbolType : function (e, t, n, i) {if ("shape" !== t) {var _Bf2;const e = (_Bf2 = Bf(n)) !== null && _Bf2 !== void 0 ? _Bf2 : i;if (e) return e;}switch (e) {case "bar":case "rect":case "image":case "square":return "square";case "line":case "trail":case "rule":return "stroke";case "arc":case "point":case "circle":case "tick":case "geoshape":case "area":case "text":return "circle";}}(n.type, i, r.shape, n.shape);}, title: (e) => {let { fieldOrDatumDef: t, config: n } = e;return ba(t, n, { allowDisabling: !0 });}, type: (e) => {let { legendType: t, scaleType: n, channel: i } = e;if (Ye(i) && Cr(n)) {if ("gradient" === t) return;} else if ("symbol" === t) return;return t;}, values: (e) => {let { fieldOrDatumDef: n, legend: i } = e;return function (e, n) {const i = e.values;if (t.isArray(i)) return Pa(n, i);if (Fn(i)) return i;return;}(i, n);} };function Gf(e) {const { legend: t } = e;return X(t.type, function (e) {let { channel: t, timeUnit: n, scaleType: i } = e;if (Ye(t)) {if (k(["quarter", "month", "day"], n)) return "symbol";if (Cr(i)) return "gradient";}return "symbol";}(e));}function Yf(e) {var _ref15, _r$direction;let { legendConfig: t, legendType: n, orient: i, legend: r } = e;return (_ref15 = (_r$direction = r.direction) !== null && _r$direction !== void 0 ? _r$direction : t[n ? "gradientDirection" : "symbolDirection"]) !== null && _ref15 !== void 0 ? _ref15 : function (e, t) {switch (e) {case "top":case "bottom":return "horizontal";case "left":case "right":case "none":case void 0:return;default:return "gradient" === t ? "horizontal" : void 0;}}(i, n);}function Xf(e, t, n, i) {return { signal: "clamp(".concat(e.getSizeSignalRef(t).signal, ", ").concat(n, ", ").concat(i, ")") };}function Jf(e) {const t = _m(e) ? function (e) {const { encoding: t } = e,n = {};for (const i of [we, ...Os]) {const r = Sa(t[i]);r && e.getScaleComponent(i) && (i === De && ea(r) && r.type === yr || (n[i] = Kf(e, i)));}return n;}(e) : function (e) {const { legends: t, resolve: n } = e.component;for (const i of e.children) {Jf(i);for (const r of j(i.component.legends)) n.legend[r] = Lf(e.component.resolve, r), "shared" === n.legend[r] && (t[r] = Zf(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]));}for (const i of j(t)) for (const t of e.children) t.component.legends[i] && "shared" === n.legend[i] && delete t.component.legends[i];return t;}(e);return e.component.legends = t, t;}function Qf(e, t, n, i) {switch (t) {case "disable":return void 0 !== n;case "values":return !!(n !== null && n !== void 0 && n.values);case "title":if ("title" === t && e === (i === null || i === void 0 ? void 0 : i.title)) return !0;}return e === (n || {})[t];}function Kf(e, t) {var _Xi8, _n$encoding, _n4, _n5;let n = e.legend(t);const { markDef: i, encoding: r, config: o } = e,a = o.legend,s = new Uf({}, function (e, t) {const n = e.scaleName(t);if ("trail" === e.mark) {if ("color" === t) return { stroke: n };if ("size" === t) return { strokeWidth: n };}return "color" === t ? e.markDef.filled ? { fill: n } : { stroke: n } : { [t]: n };}(e, t));!function (e, t, n, _e$fieldDef) {const i = (_e$fieldDef = e.fieldDef(t)) === null || _e$fieldDef === void 0 ? void 0 : _e$fieldDef.field;for (const r of T((_e$component$selectio5 = e.component.selection) !== null && _e$component$selectio5 !== void 0 ? _e$component$selectio5 : {})) {var _e$component$selectio5, _r$project$hasField$i;const e = (_r$project$hasField$i = r.project.hasField[i]) !== null && _r$project$hasField$i !== void 0 ? _r$project$hasField$i : r.project.hasChannel[t];if (e && Pu.defined(r)) {var _n$get;const t = (_n$get = n.get("selections")) !== null && _n$get !== void 0 ? _n$get : [];t.push(r.name), n.set("selections", t, !1), e.hasLegend = !0;}}}(e, t, s);const l = void 0 !== n ? !n : a.disable;if (s.set("disable", l, void 0 !== n), l) return s;n = n || {};const c = e.getScaleComponent(t).get("type"),u = Sa(r[t]),f = ea(u) ? (_Xi8 = Xi(u.timeUnit)) === null || _Xi8 === void 0 ? void 0 : _Xi8.unit : void 0,d = n.orient || o.legend.orient || "right",m = Gf({ legend: n, channel: t, timeUnit: f, scaleType: c }),p = { legend: n, channel: t, model: e, markDef: i, encoding: r, fieldOrDatumDef: u, legendConfig: a, config: o, scaleType: c, orient: d, legendType: m, direction: Yf({ legend: n, legendType: m, orient: d, legendConfig: a }) };for (const i of qf) {if ("gradient" === m && i.startsWith("symbol") || "symbol" === m && i.startsWith("gradient")) continue;const r = i in Vf ? Vf[i](p) : n[i];if (void 0 !== r) {const a = Qf(r, i, n, e.fieldDef(t));(a || void 0 === o.legend[i]) && s.set(i, r, a);}}const g = (_n$encoding = (_n4 = n) === null || _n4 === void 0 ? void 0 : _n4.encoding) !== null && _n$encoding !== void 0 ? _n$encoding : {},h = s.get("selections"),y = {},v = { fieldOrDatumDef: u, model: e, channel: t, legendCmpt: s, legendType: m };for (const t of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {var _g$t;const n = Ef((_g$t = g[t]) !== null && _g$t !== void 0 ? _g$t : {}, e),i = t in Rf ? Rf[t](n, v) : n;void 0 === i || A(i) || (y[t] = _objectSpread(_objectSpread(_objectSpread({}, h !== null && h !== void 0 && h.length && ea(u) ? { name: "".concat(L(u.field), "_legend_").concat(t) } : {}), h !== null && h !== void 0 && h.length ? { interactive: !!h } : {}), {}, { update: i }));}return A(y) || s.set("encode", y, !!((_n5 = n) !== null && _n5 !== void 0 && _n5.encoding)), s;}function Zf(e, t) {var _e$implicit, _e$explicit;if (!e) return t.clone();const n = e.getWithExplicit("orient"),i = t.getWithExplicit("orient");if (n.explicit && i.explicit && n.value !== i.value) return;let r = !1;for (const n of qf) {const i = fc(e.getWithExplicit(n), t.getWithExplicit(n), n, "legend", (e, t) => {switch (n) {case "symbolType":return ed(e, t);case "title":return Gn(e, t);case "type":return r = !0, lc("symbol");}return uc(e, t, n, "legend");});e.setWithExplicit(n, i);}return r && ((_e$implicit = e.implicit) !== null && _e$implicit !== void 0 && (_e$implicit = _e$implicit.encode) !== null && _e$implicit !== void 0 && _e$implicit.gradient && U(e.implicit, ["encode", "gradient"]), (_e$explicit = e.explicit) !== null && _e$explicit !== void 0 && (_e$explicit = _e$explicit.encode) !== null && _e$explicit !== void 0 && _e$explicit.gradient && U(e.explicit, ["encode", "gradient"])), e;}function ed(e, t) {return "circle" === t.value ? t : e;}function td(e) {const t = e.component.legends,n = {};for (const i of j(t)) {const r = re(e.getScaleComponent(i).get("domains"));if (n[r]) for (const e of n[r]) {Zf(e, t[i]) || n[r].push(t[i]);} else n[r] = [t[i].clone()];}return T(n).flat().map((t) => function (e, t, _o$encode) {const _e$combine2 = e.combine(),{ disable: n, labelExpr: i, selections: r } = _e$combine2,o = _objectWithoutProperties(_e$combine2, _excluded52);if (n) return;!1 === t.aria && null == o.aria && (o.aria = !1);if ((_o$encode = o.encode) !== null && _o$encode !== void 0 && _o$encode.symbols) {const e = o.encode.symbols.update;!e.fill || "transparent" === e.fill.value || e.stroke || o.stroke || (e.stroke = { value: "transparent" });for (const t of Os) o[t] && delete e[t];}o.title || delete o.title;if (void 0 !== i) {var _o$encode2;let e = i;(_o$encode2 = o.encode) !== null && _o$encode2 !== void 0 && (_o$encode2 = _o$encode2.labels) !== null && _o$encode2 !== void 0 && _o$encode2.update && Fn(o.encode.labels.update.text) && (e = V(i, "datum.label", o.encode.labels.update.text.signal)), function (e, t, n, i, _e$encode3, _e$encode4, _e$encode4$t, _e$encode$t2, _e$encode$t2$update) {(_e$encode3 = e.encode) !== null && _e$encode3 !== void 0 ? _e$encode3 : e.encode = {}, (_e$encode4$t = (_e$encode4 = e.encode)[t]) !== null && _e$encode4$t !== void 0 ? _e$encode4$t : _e$encode4[t] = {}, (_e$encode$t2$update = (_e$encode$t2 = e.encode[t]).update) !== null && _e$encode$t2$update !== void 0 ? _e$encode$t2$update : _e$encode$t2.update = {}, e.encode[t].update[n] = i;}(o, "labels", "text", { signal: e });}return o;}(t, e.config)).filter((e) => void 0 !== e);}function nd(e) {return Pm(e) || Cm(e) ? function (e) {return e.children.reduce((e, t) => e.concat(t.assembleProjections()), id(e));}(e) : id(e);}function id(e) {const t = e.component.projection;if (!t || t.merged) return [];const n = t.combine(),{ name: i } = n;if (t.data) {const r = { signal: "[".concat(t.size.map((e) => e.signal).join(", "), "]") },o = t.data.reduce((t, n) => {const i = Fn(n) ? n.signal : "data('".concat(e.lookupDataSource(n), "')");return k(t, i) || t.push(i), t;}, []);if (o.length <= 0) throw new Error("Projection's fit didn't find any data sources");return [_objectSpread({ name: i, size: r, fit: { signal: o.length > 1 ? "[".concat(o.join(", "), "]") : o[0] } }, n)];}return [_objectSpread({ name: i, translate: { signal: "[width / 2, height / 2]" } }, n)];}const rd = ["type", "clipAngle", "clipExtent", "center", "rotate", "precision", "reflectX", "reflectY", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];class od extends ac {constructor(e, t, n, i) {super(_objectSpread({}, t), { name: e }), this.specifiedProjection = t, this.size = n, this.data = i, Yn(this, "merged", !1);}get isFit() {return !!this.data;}}function ad(e) {e.component.projection = _m(e) ? function (e) {if (e.hasProjection) {var _kn;const t = kn(e.specifiedProjection),n = !(t && (null != t.scale || null != t.translate)),i = n ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0,r = n ? function (e) {const t = [],{ encoding: n } = e;for (const i of [[be, ve], [$e, xe]]) (Sa(n[i[0]]) || Sa(n[i[1]])) && t.push({ signal: e.getName("geojson_".concat(t.length)) });e.channelHasField(De) && e.typedFieldDef(De).type === yr && t.push({ signal: e.getName("geojson_".concat(t.length)) });0 === t.length && t.push(e.requestDataName(xc.Main));return t;}(e) : void 0,o = new od(e.projectionName(!0), _objectSpread(_objectSpread({}, (_kn = kn(e.config.projection)) !== null && _kn !== void 0 ? _kn : {}), t !== null && t !== void 0 ? t : {}), i, r);return o.get("type") || o.set("type", "equalEarth", !1), o;}return;}(e) : function (e) {if (0 === e.children.length) return;let n;for (const t of e.children) ad(t);const i = D(e.children, (e) => {const i = e.component.projection;if (i) {if (n) {const e = function (e, n) {const i = D(rd, (i) => !t.hasOwnProperty(e.explicit, i) && !t.hasOwnProperty(n.explicit, i) || !!(t.hasOwnProperty(e.explicit, i) && t.hasOwnProperty(n.explicit, i) && ie(e.get(i), n.get(i))));if (ie(e.size, n.size)) {if (i) return e;if (ie(e.explicit, {})) return n;if (ie(n.explicit, {})) return e;}return null;}(n, i);return e && (n = e), !!e;}return n = i, !0;}return !0;});if (n && i) {const t = e.projectionName(!0),i = new od(t, n.specifiedProjection, n.size, y(n.data));for (const n of e.children) {const e = n.component.projection;e && (e.isFit && i.data.push(...n.component.projection.data), n.renameProjection(e.get("name"), t), e.merged = !0);}return i;}return;}(e);}function sd(e, t, n, i) {if (Aa(t, n)) {var _ref16, _e$axis;const r = _m(e) ? (_ref16 = (_e$axis = e.axis(n)) !== null && _e$axis !== void 0 ? _e$axis : e.legend(n)) !== null && _ref16 !== void 0 ? _ref16 : {} : {},o = pa(t, { expr: "datum" }),a = pa(t, { expr: "datum", binSuffix: "end" });return { formulaAs: pa(t, { binSuffix: "range", forAs: !0 }), formula: To(o, a, r.format, r.formatType, i) };}return {};}function ld(e, t) {return "".concat(hn(e), "_").concat(t);}function cd(e, t, n) {var _Oa;const i = ld((_Oa = Oa(n, void 0)) !== null && _Oa !== void 0 ? _Oa : {}, t);return e.getName("".concat(i, "_bins"));}function ud(e, n, i) {let r, o;r = function (e) {return "as" in e;}(e) ? t.isString(e.as) ? [e.as, "".concat(e.as, "_end")] : [e.as[0], e.as[1]] : [pa(e, { forAs: !0 }), pa(e, { binSuffix: "end", forAs: !0 })];const a = _objectSpread({}, Oa(n, void 0)),s = ld(a, e.field),{ signal: l, extentSignal: c } = function (e, t) {return { signal: e.getName("".concat(t, "_bins")), extentSignal: e.getName("".concat(t, "_extent")) };}(i, s);if (xn(a.extent)) {const e = a.extent;o = ef(i, e.param, e), delete a.extent;}return { key: s, binComponent: _objectSpread(_objectSpread(_objectSpread({ bin: a, field: e.field, as: [r] }, l ? { signal: l } : {}), c ? { extentSignal: c } : {}), o ? { span: o } : {}) };}class fd extends zc {clone() {return new fd(null, y(this.bins));}constructor(e, t) {super(e), this.bins = t;}static makeFromEncoding(e, t) {const n = t.reduceFieldDef((e, n, i) => {if (sa(n) && yn(n.bin)) {const { key: r, binComponent: o } = ud(n, n.bin, t);e[r] = _objectSpread(_objectSpread(_objectSpread({}, o), e[r]), sd(t, n, i, t.config));}return e;}, {});return A(n) ? null : new fd(e, n);}static makeFromTransform(e, t, n) {const { key: i, binComponent: r } = ud(t, t.bin, n);return new fd(e, { [i]: r });}merge(e, t) {for (const n of j(e.bins)) n in this.bins ? (t(e.bins[n].signal, this.bins[n].signal), this.bins[n].as = O([...this.bins[n].as, ...e.bins[n].as], $)) : this.bins[n] = e.bins[n];for (const t of e.children) e.removeChild(t), t.parent = this;e.remove();}producedFields() {return new Set(T(this.bins).map((e) => e.as).flat(2));}dependentFields() {return new Set(T(this.bins).map((e) => e.field));}hash() {return "Bin ".concat($(this.bins));}assemble() {return T(this.bins).flatMap((e) => {const t = [],[n, ...i] = e.as,_e$bin = e.bin,{ extent: r } = _e$bin,o = _objectWithoutProperties(_e$bin, _excluded53),a = _objectSpread(_objectSpread(_objectSpread({ type: "bin", field: H(e.field), as: n, signal: e.signal }, xn(r) ? { extent: null } : { extent: r }), e.span ? { span: { signal: "span(".concat(e.span, ")") } } : {}), o);!r && e.extentSignal && (t.push({ type: "extent", field: H(e.field), signal: e.extentSignal }), a.extent = { signal: e.extentSignal }), t.push(a);for (const e of i) for (let i = 0; i < 2; i++) t.push({ type: "formula", expr: pa({ field: n[i] }, { expr: "datum" }), as: e[i] });return e.formula && t.push({ type: "formula", expr: e.formula, as: e.formulaAs }), t;});}}function dd(e, n, i, r) {var _i$scale3;const o = _m(r) ? r.encoding[dt(n)] : void 0;if (sa(i) && _m(r) && Xo(i, o, r.markDef, r.config)) {e.add(pa(i, {})), e.add(pa(i, { suffix: "end" }));const { mark: t, markDef: o, config: a } = r,s = Go({ fieldDef: i, markDef: o, config: a });ao(t) && .5 !== s && Et(n) && (e.add(pa(i, { suffix: Pc })), e.add(pa(i, { suffix: Ac }))), i.bin && Aa(i, n) && e.add(pa(i, { binSuffix: "range" }));} else if (He(n)) {const t = Ie(n);e.add(r.getName(t));} else e.add(pa(i));return ca(i) && function (e) {return t.isObject(e) && "field" in e;}((_i$scale3 = i.scale) === null || _i$scale3 === void 0 ? void 0 : _i$scale3.range) && e.add(i.scale.range.field), e;}class md extends zc {clone() {return new md(null, new Set(this.dimensions), y(this.measures));}constructor(e, t, n) {super(e), this.dimensions = t, this.measures = n;}get groupBy() {return this.dimensions;}static makeFromEncoding(e, t) {let n = !1;t.forEachFieldDef((e) => {e.aggregate && (n = !0);});const i = {},r = new Set();return n ? (t.forEachFieldDef((e, n) => {var _2, _i$_;const { aggregate: o, field: a } = e;if (o) {if ("count" === o) (_i$_ = i[_2 = "*"]) !== null && _i$_ !== void 0 ? _i$_ : i[_2] = {}, i["*"].count = new Set([pa(e, { forAs: !0 })]);else {var _i$a, _i$a2;if (cn(o) || un(o)) {var _i$t2;const e = cn(o) ? "argmin" : "argmax",t = o[e];(_i$t2 = i[t]) !== null && _i$t2 !== void 0 ? _i$t2 : i[t] = {}, i[t][e] = new Set([pa({ op: e, field: t }, { forAs: !0 })]);} else (_i$a = i[a]) !== null && _i$a !== void 0 ? _i$a : i[a] = {}, i[a][o] = new Set([pa(e, { forAs: !0 })]);en(n) && "unaggregated" === t.scaleDomain(n) && ((_i$a2 = i[a]) !== null && _i$a2 !== void 0 ? _i$a2 : i[a] = {}, i[a].min = new Set([pa({ field: a, aggregate: "min" }, { forAs: !0 })]), i[a].max = new Set([pa({ field: a, aggregate: "max" }, { forAs: !0 })]));}} else dd(r, n, e, t);}), r.size + j(i).length === 0 ? null : new md(e, r, i)) : null;}static makeFromTransform(e, t) {const n = new Set(),i = {};for (const e of t.aggregate) {var _3, _i$_2, _i$n;const { op: t, field: n, as: r } = e;t && ("count" === t ? ((_i$_2 = i[_3 = "*"]) !== null && _i$_2 !== void 0 ? _i$_2 : i[_3] = {}, i["*"].count = new Set([r || pa(e, { forAs: !0 })])) : ((_i$n = i[n]) !== null && _i$n !== void 0 ? _i$n : i[n] = {}, i[n][t] = new Set([r || pa(e, { forAs: !0 })])));}for (const e of (_t$groupby = t.groupby) !== null && _t$groupby !== void 0 ? _t$groupby : []) {var _t$groupby;n.add(e);}return n.size + j(i).length === 0 ? null : new md(e, n, i);}merge(e) {return _(this.dimensions, e.dimensions) ? (function (e, t) {for (const n of j(t)) {const i = t[n];for (const t of j(i)) {var _e$n$t;n in e ? e[n][t] = new Set([...((_e$n$t = e[n][t]) !== null && _e$n$t !== void 0 ? _e$n$t : []), ...i[t]]) : e[n] = { [t]: i[t] };}}}(this.measures, e.measures), !0) : (function () {_i.debug(...arguments);}("different dimensions, cannot merge"), !1);}addDimensions(e) {e.forEach(this.dimensions.add, this.dimensions);}dependentFields() {return new Set([...this.dimensions, ...j(this.measures)]);}producedFields() {const e = new Set();for (const t of j(this.measures)) for (const n of j(this.measures[t])) {const i = this.measures[t][n];0 === i.size ? e.add("".concat(n, "_").concat(t)) : i.forEach(e.add, e);}return e;}hash() {return "Aggregate ".concat($({ dimensions: this.dimensions, measures: this.measures }));}assemble() {const e = [],t = [],n = [];for (const i of j(this.measures)) for (const r of j(this.measures[i])) for (const o of this.measures[i][r]) n.push(o), e.push(r), t.push("*" === i ? null : H(i));return { type: "aggregate", groupby: [...this.dimensions].map(H), ops: e, fields: t, as: n };}}class pd extends zc {constructor(e, n, i, r) {super(e), this.model = n, this.name = i, this.data = r, Yn(this, "column", void 0), Yn(this, "row", void 0), Yn(this, "facet", void 0), Yn(this, "childModel", void 0);for (const e of Je) {const i = n.facet[e];if (i) {const { bin: r, sort: o } = i;this[e] = _objectSpread({ name: n.getName("".concat(e, "_domain")), fields: [pa(i), ...(yn(r) ? [pa(i, { binSuffix: "end" })] : [])] }, Uo(o) ? { sortField: o } : t.isArray(o) ? { sortIndexField: gf(i, e) } : {});}}this.childModel = n.child;}hash() {let e = "Facet";for (const t of Je) this[t] && (e += " ".concat(t.charAt(0), ":").concat($(this[t])));return e;}get fields() {const e = [];for (const t of Je) {var _this$t;((_this$t = this[t]) === null || _this$t === void 0 ? void 0 : _this$t.fields) && e.push(...this[t].fields);}return e;}dependentFields() {const e = new Set(this.fields);for (const t of Je) this[t] && (this[t].sortField && e.add(this[t].sortField.field), this[t].sortIndexField && e.add(this[t].sortIndexField));return e;}producedFields() {return new Set();}getSource() {return this.name;}getChildIndependentFieldsWithStep() {const e = {};for (const t of Tt) {const n = this.childModel.component.scales[t];if (n && !n.merged) {const i = n.get("type"),r = n.get("range");if (_r(i) && zn(r)) {const n = om(am(this.childModel, t));n ? e[t] = n : Ni(ii(t));}}}return e;}assembleRowColumnHeaderData(e, t, n) {const i = { row: "y", column: "x", facet: void 0 }[e],r = [],o = [],a = [];i && n && n[i] && (t ? (r.push("distinct_".concat(n[i])), o.push("max")) : (r.push(n[i]), o.push("distinct")), a.push("distinct_".concat(n[i])));const { sortField: s, sortIndexField: l } = this[e];if (s) {const { op: e = Eo, field: t } = s;r.push(t), o.push(e), a.push(pa(s, { forAs: !0 }));} else l && (r.push(l), o.push("max"), a.push(l));return { name: this[e].name, source: t !== null && t !== void 0 ? t : this.data, transform: [_objectSpread({ type: "aggregate", groupby: this[e].fields }, r.length ? { fields: r, ops: o, as: a } : {})] };}assembleFacetHeaderData(e) {const { columns: t } = this.model.layout,{ layoutHeaders: n } = this.model.component,i = [],r = {};for (const e of bf) {for (const t of xf) {var _ref17;const i = (_ref17 = n[e] && n[e][t]) !== null && _ref17 !== void 0 ? _ref17 : [];for (const t of i) {var _t$axes;if (((_t$axes = t.axes) === null || _t$axes === void 0 ? void 0 : _t$axes.length) > 0) {r[e] = !0;break;}}}if (r[e]) {const n = "length(data(\"".concat(this.facet.name, "\"))"),r = "row" === e ? t ? { signal: "ceil(".concat(n, " / ").concat(t, ")") } : 1 : t ? { signal: "min(".concat(n, ", ").concat(t, ")") } : { signal: n };i.push({ name: "".concat(this.facet.name, "_").concat(e), transform: [{ type: "sequence", start: 0, stop: r }] });}}const { row: o, column: a } = r;return (o || a) && i.unshift(this.assembleRowColumnHeaderData("facet", null, e)), i;}assemble() {const e = [];let t = null;const n = this.getChildIndependentFieldsWithStep(),{ column: i, row: r, facet: o } = this;if (i && r && (n.x || n.y)) {var _n$x, _n$y;t = "cross_".concat(this.column.name, "_").concat(this.row.name);const i = [].concat((_n$x = n.x) !== null && _n$x !== void 0 ? _n$x : [], (_n$y = n.y) !== null && _n$y !== void 0 ? _n$y : []),r = i.map(() => "distinct");e.push({ name: t, source: this.data, transform: [{ type: "aggregate", groupby: this.fields, fields: i, ops: r }] });}for (const i of [ae, oe]) this[i] && e.push(this.assembleRowColumnHeaderData(i, t, n));if (o) {const t = this.assembleFacetHeaderData(n);t && e.push(...t);}return e;}}function gd(e) {return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"') ? e.slice(1, -1) : e;}function hd(e) {const n = {};return g(e.filter, (e) => {if (ar(e)) {var _e$oneOf;let i = null;Zi(e) ? i = An(e.equal) : tr(e) ? i = An(e.lte) : er(e) ? i = An(e.lt) : nr(e) ? i = An(e.gt) : ir(e) ? i = An(e.gte) : rr(e) ? i = e.range[0] : or(e) && (i = ((_e$oneOf = e.oneOf) !== null && _e$oneOf !== void 0 ? _e$oneOf : e.in)[0]), i && (Ci(i) ? n[e.field] = "date" : t.isNumber(i) ? n[e.field] = "number" : t.isString(i) && (n[e.field] = "string")), e.timeUnit && (n[e.field] = "date");}}), n;}function yd(e) {const n = {};function i(e) {var i;Na(e) ? n[e.field] = "date" : "quantitative" === e.type && (i = e.aggregate, t.isString(i) && k(["min", "max"], i)) ? n[e.field] = "number" : Y(e.field) > 1 ? e.field in n || (n[e.field] = "flatten") : ca(e) && Uo(e.sort) && Y(e.sort.field) > 1 && (e.sort.field in n || (n[e.sort.field] = "flatten"));}if ((_m(e) || Nm(e)) && e.forEachFieldDef((t, n) => {if (sa(t)) i(t);else {const r = ut(n),o = e.fieldDef(r);i(_objectSpread(_objectSpread({}, t), {}, { type: o.type }));}}), _m(e)) {const { mark: t, markDef: i, encoding: r } = e;if (oo(t) && !e.encoding.order) {const e = r["horizontal" === i.orient ? "y" : "x"];ea(e) && "quantitative" === e.type && !(e.field in n) && (n[e.field] = "number");}}return n;}class vd extends zc {clone() {return new vd(null, y(this._parse));}constructor(e, t) {super(e), Yn(this, "_parse", void 0), this._parse = t;}hash() {return "Parse ".concat($(this._parse));}static makeExplicit(e, t, n) {var _r$format;let i = {};const r = t.data;return !hc(r) && r !== null && r !== void 0 && (_r$format = r.format) !== null && _r$format !== void 0 && _r$format.parse && (i = r.format.parse), this.makeWithAncestors(e, i, {}, n);}static makeWithAncestors(e, t, n, i) {for (const e of j(n)) {const t = i.getWithExplicit(e);void 0 !== t.value && (t.explicit || t.value === n[e] || "derived" === t.value || "flatten" === n[e] ? delete n[e] : Ni(ci(e, n[e], t.value)));}for (const e of j(t)) {const n = i.get(e);void 0 !== n && (n === t[e] ? delete t[e] : Ni(ci(e, t[e], n)));}const r = new ac(t, n);i.copyAll(r);const o = {};for (const e of j(r.combine())) {const t = r.get(e);null !== t && (o[e] = t);}return 0 === j(o).length || i.parseNothing ? null : new vd(e, o);}get parse() {return this._parse;}merge(e) {this._parse = _objectSpread(_objectSpread({}, this._parse), e.parse), e.remove();}assembleFormatParse() {const e = {};for (const t of j(this._parse)) {const n = this._parse[t];1 === Y(t) && (e[t] = n);}return e;}producedFields() {return new Set(j(this._parse));}dependentFields() {return new Set(j(this._parse));}assembleTransforms() {let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];return j(this._parse).filter((t) => !e || Y(t) > 1).map((e) => {const t = function (e, t) {const n = W(e);if ("number" === t) return "toNumber(".concat(n, ")");if ("boolean" === t) return "toBoolean(".concat(n, ")");if ("string" === t) return "toString(".concat(n, ")");if ("date" === t) return "toDate(".concat(n, ")");if ("flatten" === t) return n;if (t.startsWith("date:")) return "timeParse(".concat(n, ",'").concat(gd(t.slice(5, t.length)), "')");if (t.startsWith("utc:")) return "utcParse(".concat(n, ",'").concat(gd(t.slice(4, t.length)), "')");return Ni("Unrecognized parse \"".concat(t, "\".")), null;}(e, this._parse[e]);if (!t) return null;return { type: "formula", expr: t, as: G(e) };}).filter((e) => null !== e);}}class bd extends zc {clone() {return new bd(null);}constructor(e) {super(e);}dependentFields() {return new Set();}producedFields() {return new Set([_s]);}hash() {return "Identifier";}assemble() {return { type: "identifier", as: _s };}}class xd extends zc {clone() {return new xd(null, this.params);}constructor(e, t) {super(e), this.params = t;}dependentFields() {return new Set();}producedFields() {}hash() {return "Graticule ".concat($(this.params));}assemble() {return _objectSpread({ type: "graticule" }, !0 === this.params ? {} : this.params);}}class $d extends zc {clone() {return new $d(null, this.params);}constructor(e, t) {super(e), this.params = t;}dependentFields() {return new Set();}producedFields() {var _this$params$as;return new Set([(_this$params$as = this.params.as) !== null && _this$params$as !== void 0 ? _this$params$as : "data"]);}hash() {return "Hash ".concat($(this.params));}assemble() {return _objectSpread({ type: "sequence" }, this.params);}}class wd extends zc {constructor(e) {var _e2;let t;if (super(null), Yn(this, "_data", void 0), Yn(this, "_name", void 0), Yn(this, "_generator", void 0), (_e2 = e) !== null && _e2 !== void 0 ? _e2 : e = { name: "source" }, hc(e) || (t = e.format ? _objectSpread({}, x(e.format, ["parse"])) : {}), pc(e)) this._data = { values: e.values };else if (mc(e)) {if (this._data = { url: e.url }, !t.type) {let n = /(?:\.([^.]+))?$/.exec(e.url)[1];k(["json", "csv", "tsv", "dsv", "topojson"], n) || (n = "json"), t.type = n;}} else vc(e) ? this._data = { values: [{ type: "Sphere" }] } : (gc(e) || hc(e)) && (this._data = {});this._generator = hc(e), e.name && (this._name = e.name), t && !A(t) && (this._data.format = t);}dependentFields() {return new Set();}producedFields() {}get data() {return this._data;}hasName() {return !!this._name;}get isGenerator() {return this._generator;}get dataName() {return this._name;}set dataName(e) {this._name = e;}set parent(e) {throw new Error("Source nodes have to be roots.");}remove() {throw new Error("Source nodes are roots and cannot be removed.");}hash() {throw new Error("Cannot hash sources");}assemble() {return _objectSpread(_objectSpread({ name: this._name }, this._data), {}, { transform: [] });}}function kd(e) {return e instanceof wd || e instanceof xd || e instanceof $d;}var Sd = new WeakMap();class Dd {constructor() {Qn(this, Sd, { writable: !0, value: void 0 }), Xn(this, Sd, !1);}setModified() {Xn(this, Sd, !0);}get modifiedFlag() {return function (e, t) {return t.get ? t.get.call(e) : t.value;}(e = this, Jn(e, Sd, "get"));var e;}}class Fd extends Dd {getNodeDepths(e, t, n) {n.set(e, t);for (const i of e.children) this.getNodeDepths(i, t + 1, n);return n;}optimize(e) {const t = [...this.getNodeDepths(e, 0, new Map()).entries()].sort((e, t) => t[1] - e[1]);for (const e of t) this.run(e[0]);return this.modifiedFlag;}}class zd extends Dd {optimize(e) {this.run(e);for (const t of e.children) this.optimize(t);return this.modifiedFlag;}}class Od extends zd {mergeNodes(e, t) {const n = t.shift();for (const i of t) e.removeChild(i), i.parent = n, i.remove();}run(e) {const t = e.children.map((e) => e.hash()),n = {};for (let i = 0; i < t.length; i++) void 0 === n[t[i]] ? n[t[i]] = [e.children[i]] : n[t[i]].push(e.children[i]);for (const t of j(n)) n[t].length > 1 && (this.setModified(), this.mergeNodes(e, n[t]));}}class _d extends zd {constructor(e) {super(), Yn(this, "requiresSelectionId", void 0), this.requiresSelectionId = e && Gu(e);}run(e) {e instanceof bd && (this.requiresSelectionId && (kd(e.parent) || e.parent instanceof md || e.parent instanceof vd) || (this.setModified(), e.remove()));}}class Nd extends Dd {optimize(e) {return this.run(e, new Set()), this.modifiedFlag;}run(e, t) {let n = new Set();e instanceof Cc && (n = e.producedFields(), N(n, t) && (this.setModified(), e.removeFormulas(t), 0 === e.producedFields.length && e.remove()));for (const i of e.children) this.run(i, new Set([...t, ...n]));}}class Cd extends zd {constructor() {super();}run(e) {e instanceof Oc && !e.isRequired() && (this.setModified(), e.remove());}}class Pd extends Fd {run(e) {if (!(kd(e) || e.numChildren() > 1)) for (const t of e.children) if (t instanceof vd) if (e instanceof vd) this.setModified(), e.merge(t);else {if (P(e.producedFields(), t.dependentFields())) continue;this.setModified(), t.swapWithParent();}}}class Ad extends Fd {run(e) {const t = [...e.children],n = e.children.filter((e) => e instanceof vd);if (e.numChildren() > 1 && n.length >= 1) {const i = {},r = new Set();for (const e of n) {const t = e.parse;for (const e of j(t)) e in i ? i[e] !== t[e] && r.add(e) : i[e] = t[e];}for (const e of r) delete i[e];if (!A(i)) {this.setModified();const n = new vd(e, i);for (const r of t) {if (r instanceof vd) for (const e of j(i)) delete r.parse[e];e.removeChild(r), r.parent = n, r instanceof vd && 0 === j(r.parse).length && r.remove();}}}}}class jd extends Fd {run(e) {e instanceof Oc || e.numChildren() > 0 || e instanceof pd || e instanceof wd || (this.setModified(), e.remove());}}class Td extends Fd {run(e) {const t = e.children.filter((e) => e instanceof Cc),n = t.pop();for (const e of t) this.setModified(), n.merge(e);}}class Ed extends Fd {run(e) {const t = e.children.filter((e) => e instanceof md),n = {};for (const e of t) {const t = $(e.groupBy);t in n || (n[t] = []), n[t].push(e);}for (const t of j(n)) {const i = n[t];if (i.length > 1) {const t = i.pop();for (const n of i) t.merge(n) && (e.removeChild(n), n.parent = t, n.remove(), this.setModified());}}}}class Md extends Fd {constructor(e) {super(), this.model = e;}run(e) {const t = !(kd(e) || e instanceof Ku || e instanceof vd || e instanceof bd),n = [],i = [];for (const r of e.children) r instanceof fd && (t && !P(e.producedFields(), r.dependentFields()) ? n.push(r) : i.push(r));if (n.length > 0) {const t = n.pop();for (const e of n) t.merge(e, this.model.renameSignal.bind(this.model));this.setModified(), e instanceof fd ? e.merge(t, this.model.renameSignal.bind(this.model)) : t.swapWithParent();}if (i.length > 1) {const e = i.pop();for (const t of i) e.merge(t, this.model.renameSignal.bind(this.model));this.setModified();}}}class Ld extends Fd {run(e) {const t = [...e.children];if (!S(t, (e) => e instanceof Oc) || e.numChildren() <= 1) return;const n = [];let i;for (const r of t) if (r instanceof Oc) {let t = r;for (; 1 === t.numChildren();) {const [e] = t.children;if (!(e instanceof Oc)) break;t = e;}n.push(...t.children), i ? (e.removeChild(r), r.parent = i.parent, i.parent.removeChild(i), i.parent = t, this.setModified()) : i = t;} else n.push(r);if (n.length) {this.setModified();for (const e of n) e.parent.removeChild(e), e.parent = i;}}}class qd extends zc {clone() {return new qd(null, y(this.transform));}constructor(e, t) {super(e), this.transform = t;}addDimensions(e) {this.transform.groupby = O(this.transform.groupby.concat(e), (e) => e);}dependentFields() {const e = new Set();return this.transform.groupby && this.transform.groupby.forEach(e.add, e), this.transform.joinaggregate.map((e) => e.field).filter((e) => void 0 !== e).forEach(e.add, e), e;}producedFields() {return new Set(this.transform.joinaggregate.map(this.getDefaultName));}getDefaultName(e) {var _e$as;return (_e$as = e.as) !== null && _e$as !== void 0 ? _e$as : pa(e);}hash() {return "JoinAggregateTransform ".concat($(this.transform));}assemble() {const e = [],t = [],n = [];for (const i of this.transform.joinaggregate) t.push(i.op), n.push(this.getDefaultName(i)), e.push(void 0 === i.field ? null : i.field);const i = this.transform.groupby;return _objectSpread({ type: "joinaggregate", as: n, ops: t, fields: e }, void 0 !== i ? { groupby: i } : {});}}class Ud extends zc {clone() {return new Ud(null, y(this._stack));}constructor(e, t) {super(e), Yn(this, "_stack", void 0), this._stack = t;}static makeFromTransform(e, n) {const { stack: i, groupby: r, as: o, offset: a = "zero" } = n,s = [],l = [];if (void 0 !== n.sort) for (const e of n.sort) s.push(e.field), l.push(X(e.order, "ascending"));const c = { field: s, order: l };let u;return u = function (e) {return t.isArray(e) && e.every((e) => t.isString(e)) && e.length > 1;}(o) ? o : t.isString(o) ? [o, "".concat(o, "_end")] : ["".concat(n.stack, "_start"), "".concat(n.stack, "_end")], new Ud(e, { dimensionFieldDefs: [], stackField: i, groupby: r, offset: a, sort: c, facetby: [], as: u });}static makeFromEncoding(e, n) {const i = n.stack,{ encoding: r } = n;if (!i) return null;const { groupbyChannels: o, fieldChannel: a, offset: s, impute: l } = i,c = o.map((e) => ka(r[e])).filter((e) => !!e),u = function (e) {return e.stack.stackBy.reduce((e, t) => {const n = pa(t.fieldDef);return n && e.push(n), e;}, []);}(n),f = n.encoding.order;let d;if (t.isArray(f) || ea(f)) d = In(f);else {const e = Jo(f) ? f.sort : "y" === a ? "descending" : "ascending";d = u.reduce((t, n) => (t.field.push(n), t.order.push(e), t), { field: [], order: [] });}return new Ud(e, { dimensionFieldDefs: c, stackField: n.vgField(a), facetby: [], stackby: u, sort: d, offset: s, impute: l, as: [n.vgField(a, { suffix: "start", forAs: !0 }), n.vgField(a, { suffix: "end", forAs: !0 })] });}get stack() {return this._stack;}addDimensions(e) {this._stack.facetby.push(...e);}dependentFields() {const e = new Set();return e.add(this._stack.stackField), this.getGroupbyFields().forEach(e.add, e), this._stack.facetby.forEach(e.add, e), this._stack.sort.field.forEach(e.add, e), e;}producedFields() {return new Set(this._stack.as);}hash() {return "Stack ".concat($(this._stack));}getGroupbyFields() {const { dimensionFieldDefs: e, impute: t, groupby: n } = this._stack;return e.length > 0 ? e.map((e) => e.bin ? t ? [pa(e, { binSuffix: "mid" })] : [pa(e, {}), pa(e, { binSuffix: "end" })] : [pa(e)]).flat() : n !== null && n !== void 0 ? n : [];}assemble() {const e = [],{ facetby: t, dimensionFieldDefs: n, stackField: i, stackby: r, sort: o, offset: a, impute: s, as: l } = this._stack;if (s) for (const o of n) {const { bandPosition: n = .5, bin: a } = o;if (a) {const t = pa(o, { expr: "datum" }),i = pa(o, { expr: "datum", binSuffix: "end" });e.push({ type: "formula", expr: "".concat(n, "*").concat(t, "+").concat(1 - n, "*").concat(i), as: pa(o, { binSuffix: "mid", forAs: !0 }) });}e.push({ type: "impute", field: i, groupby: [...r, ...t], key: pa(o, { binSuffix: "mid" }), method: "value", value: 0 });}return e.push({ type: "stack", groupby: [...this.getGroupbyFields(), ...t], field: i, sort: o, as: l, offset: a }), e;}}class Rd extends zc {clone() {return new Rd(null, y(this.transform));}constructor(e, t) {super(e), this.transform = t;}addDimensions(e) {this.transform.groupby = O(this.transform.groupby.concat(e), (e) => e);}dependentFields() {var _this$transform$group, _this$transform$sort;const e = new Set();return ((_this$transform$group = this.transform.groupby) !== null && _this$transform$group !== void 0 ? _this$transform$group : []).forEach(e.add, e), ((_this$transform$sort = this.transform.sort) !== null && _this$transform$sort !== void 0 ? _this$transform$sort : []).forEach((t) => e.add(t.field)), this.transform.window.map((e) => e.field).filter((e) => void 0 !== e).forEach(e.add, e), e;}producedFields() {return new Set(this.transform.window.map(this.getDefaultName));}getDefaultName(e) {var _e$as2;return (_e$as2 = e.as) !== null && _e$as2 !== void 0 ? _e$as2 : pa(e);}hash() {return "WindowTransform ".concat($(this.transform));}assemble() {const e = [],t = [],n = [],i = [];for (const r of this.transform.window) t.push(r.op), n.push(this.getDefaultName(r)), i.push(void 0 === r.param ? null : r.param), e.push(void 0 === r.field ? null : r.field);const r = this.transform.frame,o = this.transform.groupby;if (r && null === r[0] && null === r[1] && t.every((e) => fn(e))) return _objectSpread({ type: "joinaggregate", as: n, ops: t, fields: e }, void 0 !== o ? { groupby: o } : {});const a = [],s = [];if (void 0 !== this.transform.sort) for (const e of this.transform.sort) {var _e$order;a.push(e.field), s.push((_e$order = e.order) !== null && _e$order !== void 0 ? _e$order : "ascending");}const l = { field: a, order: s },c = this.transform.ignorePeers;return _objectSpread(_objectSpread(_objectSpread({ type: "window", params: i, as: n, ops: t, fields: e, sort: l }, void 0 !== c ? { ignorePeers: c } : {}), void 0 !== o ? { groupby: o } : {}), void 0 !== r ? { frame: r } : {});}}function Wd(e) {if (e instanceof pd) {if (1 !== e.numChildren() || e.children[0] instanceof Oc) {const n = e.model.component.data.main;Bd(n);const i = (t = e, function e(n) {if (!(n instanceof pd)) {const i = n.clone();if (i instanceof Oc) {const e = Id + i.getSource();i.setSource(e), t.model.component.data.outputNodes[e] = i;} else (i instanceof md || i instanceof Ud || i instanceof Rd || i instanceof qd) && i.addDimensions(t.fields);for (const t of n.children.flatMap(e)) t.parent = i;return [i];}return n.children.flatMap(e);}),r = e.children.map(i).flat();for (const e of r) e.parent = n;} else {const t = e.children[0];(t instanceof md || t instanceof Ud || t instanceof Rd || t instanceof qd) && t.addDimensions(e.fields), t.swapWithParent(), Wd(e);}} else e.children.map(Wd);var t;}function Bd(e) {if (e instanceof Oc && e.type === xc.Main && 1 === e.numChildren()) {const t = e.children[0];t instanceof pd || (t.swapWithParent(), Bd(e));}}const Id = "scale_",Hd = 5;function Vd(e) {for (const t of e) {for (const e of t.children) if (e.parent !== t) return !1;if (!Vd(t.children)) return !1;}return !0;}function Gd(e, t) {let n = !1;for (const i of t) n = e.optimize(i) || n;return n;}function Yd(e, t, n) {let i = e.sources,r = !1;return r = Gd(new Cd(), i) || r, r = Gd(new _d(t), i) || r, i = i.filter((e) => e.numChildren() > 0), r = Gd(new jd(), i) || r, i = i.filter((e) => e.numChildren() > 0), n || (r = Gd(new Pd(), i) || r, r = Gd(new Md(t), i) || r, r = Gd(new Nd(), i) || r, r = Gd(new Ad(), i) || r, r = Gd(new Ed(), i) || r, r = Gd(new Td(), i) || r, r = Gd(new Od(), i) || r, r = Gd(new Ld(), i) || r), e.sources = i, r;}class Xd {constructor(e) {Yn(this, "signal", void 0), Object.defineProperty(this, "signal", { enumerable: !0, get: e });}static fromName(e, t) {return new Xd(() => e(t));}}function Jd(e) {_m(e) ? function (e) {const t = e.component.scales;for (const n of j(t)) {const i = Qd(e, n);if (t[n].setWithExplicit("domains", i), tm(e, n), e.component.data.isFaceted) {let t = e;for (; !Nm(t) && t.parent;) t = t.parent;if ("shared" === t.component.resolve.scale[n]) for (const e of i.value) On(e) && (e.data = Id + e.data.replace(Id, ""));}}}(e) : function (e) {for (const t of e.children) Jd(t);const t = e.component.scales;for (const n of j(t)) {let i,r = null;for (const t of e.children) {const e = t.component.scales[n];if (e) {i = void 0 === i ? e.getWithExplicit("domains") : fc(i, e.getWithExplicit("domains"), "domains", "scale", im);const t = e.get("selectionExtent");r && t && r.param !== t.param && Ni(si), r = t;}}t[n].setWithExplicit("domains", i), r && t[n].set("selectionExtent", r, !0);}}(e);}function Qd(e, t) {const n = e.getScaleComponent(t).get("type"),{ encoding: i } = e,r = function (e, t, n, i) {if ("unaggregated" === e) {const { valid: e, reason: i } = nm(t, n);if (!e) return void Ni(i);} else if (void 0 === e && i.useUnaggregatedDomain) {const { valid: e } = nm(t, n);if (e) return "unaggregated";}return e;}(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);return r !== e.scaleDomain(t) && (e.specifiedScales[t] = _objectSpread(_objectSpread({}, e.specifiedScales[t]), {}, { domain: r })), "x" === t && Sa(i.x2) ? Sa(i.x) ? fc(Zd(n, r, e, "x"), Zd(n, r, e, "x2"), "domain", "scale", im) : Zd(n, r, e, "x2") : "y" === t && Sa(i.y2) ? Sa(i.y) ? fc(Zd(n, r, e, "y"), Zd(n, r, e, "y2"), "domain", "scale", im) : Zd(n, r, e, "y2") : Zd(n, r, e, t);}function Kd(e, t, n) {var _Xi9;const i = (_Xi9 = Xi(n)) === null || _Xi9 === void 0 ? void 0 : _Xi9.unit;return "temporal" === t || i ? function (e, t, n) {return e.map((e) => ({ signal: "{data: ".concat(Ca(e, { timeUnit: n, type: t }), "}") }));}(e, t, i) : [e];}function Zd(e, n, i, r) {const { encoding: o, markDef: a, mark: s, config: l, stack: c } = i,u = Sa(o[r]),{ type: f } = u,d = u.timeUnit;if (function (e) {return e === null || e === void 0 ? void 0 : e.unionWith;}(n)) {const t = Zd(e, void 0, i, r);return sc([...Kd(n.unionWith, f, d), ...t.value]);}if (Fn(n)) return sc([n]);if (n && "unaggregated" !== n && !Ar(n)) return sc(Kd(n, f, d));if (c && r === c.fieldChannel) {if ("normalize" === c.offset) return lc([[0, 1]]);const e = i.requestDataName(xc.Main);return lc([{ data: e, field: i.vgField(r, { suffix: "start" }) }, { data: e, field: i.vgField(r, { suffix: "end" }) }]);}const m = en(r) && ea(u) ? function (e, t, n) {if (!_r(n)) return;const i = e.fieldDef(t),r = i.sort;if (Ro(r)) return { op: "min", field: gf(i, t), order: "ascending" };const { stack: o } = e,a = o ? new Set([...o.groupbyFields, ...o.stackBy.map((e) => e.fieldDef.field)]) : void 0;if (Uo(r)) {return em(r, o && !a.has(r.field));}if (qo(r)) {const { encoding: t, order: n } = r,i = e.fieldDef(t),{ aggregate: s, field: l } = i,c = o && !a.has(l);if (cn(s) || un(s)) return em({ field: pa(i), order: n }, c);if (fn(s) || !s) return em({ op: s, field: l, order: n }, c);} else {if ("descending" === r) return { op: "min", field: e.vgField(t), order: "descending" };if (k(["ascending", void 0], r)) return !0;}return;}(i, r, e) : void 0;if (na(u)) {return lc(Kd([u.datum], f, d));}const p = u;if ("unaggregated" === n) {const e = i.requestDataName(xc.Main),{ field: t } = u;return lc([{ data: e, field: pa({ field: t, aggregate: "min" }) }, { data: e, field: pa({ field: t, aggregate: "max" }) }]);}if (yn(p.bin)) {if (_r(e)) return lc("bin-ordinal" === e ? [] : [{ data: M(m) ? i.requestDataName(xc.Main) : i.requestDataName(xc.Raw), field: i.vgField(r, Aa(p, r) ? { binSuffix: "range" } : {}), sort: !0 !== m && t.isObject(m) ? m : { field: i.vgField(r, {}), op: "min" } }]);{const { bin: e } = p;if (yn(e)) {const t = cd(i, p.field, e);return lc([new Xd(() => {const e = i.getSignalName(t);return "[".concat(e, ".start, ").concat(e, ".stop]");})]);}return lc([{ data: i.requestDataName(xc.Main), field: i.vgField(r, {}) }]);}}if (p.timeUnit && k(["time", "utc"], e)) {const e = o[dt(r)];if (Xo(p, e, a, l)) {const t = i.requestDataName(xc.Main),n = Go({ fieldDef: p, fieldDef2: e, markDef: a, config: l }),o = ao(s) && .5 !== n && Et(r);return lc([{ data: t, field: i.vgField(r, o ? { suffix: Pc } : {}) }, { data: t, field: i.vgField(r, { suffix: o ? Ac : "end" }) }]);}}return lc(m ? [{ data: M(m) ? i.requestDataName(xc.Main) : i.requestDataName(xc.Raw), field: i.vgField(r), sort: m }] : [{ data: i.requestDataName(xc.Main), field: i.vgField(r) }]);}function em(e, t) {const { op: n, field: i, order: r } = e;return _objectSpread(_objectSpread({ op: n !== null && n !== void 0 ? n : t ? "sum" : Eo }, i ? { field: H(i) } : {}), r ? { order: r } : {});}function tm(e, t) {var _e$fieldDef2;const n = e.component.scales[t],i = e.specifiedScales[t].domain,r = (_e$fieldDef2 = e.fieldDef(t)) === null || _e$fieldDef2 === void 0 ? void 0 : _e$fieldDef2.bin,o = Ar(i) && i,a = bn(r) && xn(r.extent) && r.extent;(o || a) && n.set("selectionExtent", o !== null && o !== void 0 ? o : a, !0);}function nm(e, n) {const { aggregate: i, type: r } = e;return i ? t.isString(i) && !gn.has(i) ? { valid: !1, reason: xi(i) } : "quantitative" === r && "log" === n ? { valid: !1, reason: $i(e) } : { valid: !0 } : { valid: !1, reason: bi(e) };}function im(e, t, n, i) {return e.explicit && t.explicit && Ni(function (e, t, n, i) {return "Conflicting ".concat(t.toString(), " property \"").concat(e.toString(), "\" (").concat(re(n), " and ").concat(re(i), "). Using the union of the two domains.");}(n, i, e.value, t.value)), { explicit: e.explicit, value: [...e.value, ...t.value] };}function rm(e) {const n = O(e.map((e) => {if (On(e)) {const { sort: t } = e,n = _objectWithoutProperties(e, _excluded54);return n;}return e;}), $),i = O(e.map((e) => {if (On(e)) {const t = e.sort;return void 0 === t || M(t) || ("op" in t && "count" === t.op && delete t.field, "ascending" === t.order && delete t.order), t;}}).filter((e) => void 0 !== e), $);if (0 === n.length) return;if (1 === n.length) {const n = e[0];if (On(n) && i.length > 0) {let e = i[0];if (i.length > 1) {Ni(Si);const n = i.filter((e) => t.isObject(e) && "op" in e && "min" !== e.op);e = !i.every((e) => t.isObject(e) && "op" in e) || 1 !== n.length || n[0];} else if (t.isObject(e) && "field" in e) {const t = e.field;n.field === t && (e = !e.order || { order: e.order });}return _objectSpread(_objectSpread({}, n), {}, { sort: e });}return n;}const r = O(i.map((e) => M(e) || !("op" in e) || t.isString(e.op) && e.op in ln ? e : (Ni(function (e) {return "Dropping sort property ".concat(re(e), " as unioned domains only support boolean or op \"count\", \"min\", and \"max\".");}(e)), !0)), $);let o;1 === r.length ? o = r[0] : r.length > 1 && (Ni(Si), o = !0);const a = O(e.map((e) => On(e) ? e.data : null), (e) => e);if (1 === a.length && null !== a[0]) {return _objectSpread({ data: a[0], fields: n.map((e) => e.field) }, o ? { sort: o } : {});}return _objectSpread({ fields: n }, o ? { sort: o } : {});}function om(e) {if (On(e) && t.isString(e.field)) return e.field;if (function (e) {return !t.isArray(e) && "fields" in e && !("data" in e);}(e)) {let n;for (const i of e.fields) if (On(i) && t.isString(i.field)) if (n) {if (n !== i.field) return Ni("Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect."), n;} else n = i.field;return Ni("Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect."), n;}if (function (e) {return !t.isArray(e) && "fields" in e && "data" in e;}(e)) {Ni("Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.");const n = e.fields[0];return t.isString(n) ? n : void 0;}}function am(e, t) {const n = e.component.scales[t].get("domains").map((t) => (On(t) && (t.data = e.lookupDataSource(t.data)), t));return rm(n);}function sm(e) {return Pm(e) || Cm(e) ? e.children.reduce((e, t) => e.concat(sm(t)), lm(e)) : lm(e);}function lm(e) {return j(e.component.scales).reduce((n, i) => {const r = e.component.scales[i];if (r.merged) return n;const o = r.combine(),{ name: a, type: s, selectionExtent: l, domains: c, range: u, reverse: f } = o,d = _objectWithoutProperties(o, _excluded55),m = function (e, n, i, r) {if (Et(i)) {if (zn(e)) return { step: { signal: "".concat(n, "_step") } };} else if (t.isObject(e) && On(e)) return _objectSpread(_objectSpread({}, e), {}, { data: r.lookupDataSource(e.data) });return e;}(o.range, a, i, e),p = am(e, i),g = l ? function (e, n, i, r) {const o = ef(e, n.param, n);return { signal: Nr(i.get("type")) && t.isArray(r) && r[0] > r[1] ? "isValid(".concat(o, ") && reverse(").concat(o, ")") : o };}(e, l, r, p) : null;return n.push(_objectSpread(_objectSpread(_objectSpread(_objectSpread({ name: a, type: s }, p ? { domain: p } : {}), g ? { domainRaw: g } : {}), {}, { range: m }, void 0 !== f ? { reverse: f } : {}), d)), n;}, []);}class cm extends ac {constructor(e, t) {super({}, { name: e }), Yn(this, "merged", !1), this.setWithExplicit("type", t);}domainDefinitelyIncludesZero() {return !1 !== this.get("zero") || S(this.get("domains"), (e) => t.isArray(e) && 2 === e.length && t.isNumber(e[0]) && e[0] <= 0 && t.isNumber(e[1]) && e[1] >= 0);}}const um = ["range", "scheme"];function fm(e, n) {const i = e.fieldDef(n);if (i !== null && i !== void 0 && i.bin) {const { bin: r, field: o } = i,a = mt(n),s = e.getName(a);if (t.isObject(r) && r.binned && void 0 !== r.step) return new Xd(() => {const t = e.scaleName(n),i = "(domain(\"".concat(t, "\")[1] - domain(\"").concat(t, "\")[0]) / ").concat(r.step);return "".concat(e.getSignalName(s), " / (").concat(i, ")");});if (yn(r)) {const t = cd(e, o, r);return new Xd(() => {const n = e.getSignalName(t),i = "(".concat(n, ".stop - ").concat(n, ".start) / ").concat(n, ".step");return "".concat(e.getSignalName(s), " / (").concat(i, ")");});}}}function dm(e, n) {const i = n.specifiedScales[e],{ size: r } = n,o = n.getScaleComponent(e).get("type");for (const r of um) if (void 0 !== i[r]) {const a = Wr(o, r),s = Br(e, r);if (a) {if (s) Ni(s);else switch (r) {case "range":{const r = i.range;if (t.isArray(r)) {if (Et(e)) return sc(r.map((e) => {if ("width" === e || "height" === e) {const t = n.getName(e),i = n.getSignalName.bind(n);return Xd.fromName(i, t);}return e;}));} else if (t.isObject(r)) return sc({ data: n.requestDataName(xc.Main), field: r.field, sort: { op: "min", field: n.vgField(e) } });return sc(r);}case "scheme":return sc(mm(i[r]));}} else Ni(wi(o, r, e));}const a = e === le || "xOffset" === e ? "width" : "height",s = r[a];if (qs(s)) if (Et(e)) {if (_r(o)) {const t = gm(s, n, e);if (t) return sc({ step: t });} else Ni(ki(a));} else if (Rt(e)) {const t = e === de ? "x" : "y";if ("band" === n.getScaleComponent(t).get("type")) {const e = hm(s, o);if (e) return sc(e);}}const { rangeMin: l, rangeMax: c } = i,u = function (e, n) {const { size: i, config: r, mark: o, encoding: a } = n,{ type: s } = Sa(a[e]),l = n.getScaleComponent(e),c = l.get("type"),{ domain: u, domainMid: f } = n.specifiedScales[e];switch (e) {case le:case ce:if (k(["point", "band"], c)) {const t = ym(e, i, r.view);if (qs(t)) {return { step: gm(t, n, e) };}}return pm(e, n, c);case de:case me:return function (e, t, n) {const i = e === de ? "x" : "y",r = t.getScaleComponent(i);if (!r) return pm(i, t, n, { center: !0 });const o = r.get("type"),a = t.scaleName(i),{ markDef: s, config: l } = t;if ("band" === o) {const e = ym(i, t.size, t.config.view);if (qs(e)) {const t = hm(e, n);if (t) return t;}return [0, { signal: "bandwidth('".concat(a, "')") }];}{const n = t.encoding[i];if (ea(n) && n.timeUnit) {const e = Ji(n.timeUnit, (e) => "scale('".concat(a, "', ").concat(e, ")")),i = t.config.scale.bandWithNestedOffsetPaddingInner,r = Go({ fieldDef: n, markDef: s, config: l }) - .5,o = 0 !== r ? " + ".concat(r) : "";if (i) {return [{ signal: "".concat(Fn(i) ? "".concat(i.signal, "/2") + o : "".concat(i / 2 + r), " * (").concat(e, ")") }, { signal: "".concat(Fn(i) ? "(1 - ".concat(i.signal, "/2)") + o : "".concat(1 - i / 2 + r), " * (").concat(e, ")") }];}return [0, { signal: e }];}return v("Cannot use ".concat(e, " scale if ").concat(i, " scale is not discrete."));}}(e, n, c);case Fe:{const a = vm(o, n.component.scales[e].get("zero"), r),s = function (e, n, i, r) {const o = { x: fm(i, "x"), y: fm(i, "y") };switch (e) {case "bar":case "tick":{if (void 0 !== r.scale.maxBandSize) return r.scale.maxBandSize;const e = xm(n, o, r.view);return t.isNumber(e) ? e - 1 : new Xd(() => "".concat(e.signal, " - 1"));}case "line":case "trail":case "rule":return r.scale.maxStrokeWidth;case "text":return r.scale.maxFontSize;case "point":case "square":case "circle":{if (r.scale.maxSize) return r.scale.maxSize;const e = xm(n, o, r.view);return t.isNumber(e) ? Math.pow(bm * e, 2) : new Xd(() => "pow(".concat(bm, " * ").concat(e.signal, ", 2)"));}}throw new Error(gi("size", e));}(o, i, n, r);return Pr(c) ? function (e, t, n) {const i = () => {const i = Mn(t),r = Mn(e),o = "(".concat(i, " - ").concat(r, ") / (").concat(n, " - 1)");return "sequence(".concat(r, ", ").concat(i, " + ").concat(o, ", ").concat(o, ")");};return Fn(t) ? new Xd(i) : { signal: i() };}(a, s, function (e, n, i, r) {switch (e) {case "quantile":return n.scale.quantileCount;case "quantize":return n.scale.quantizeCount;case "threshold":return void 0 !== i && t.isArray(i) ? i.length + 1 : (Ni(function (e) {return "Domain for ".concat(e, " is required for threshold scale.");}(r)), 3);}}(c, r, u, e)) : [a, s];}case he:return [0, 2 * Math.PI];case ze:return [0, 360];case pe:return [0, new Xd(() => "min(".concat(n.getSignalName("width"), ",").concat(n.getSignalName("height"), ")/2"))];case Ce:return [r.scale.minStrokeWidth, r.scale.maxStrokeWidth];case Pe:return [[1, 0], [4, 2], [2, 1], [1, 1], [1, 2, 4, 2]];case De:return "symbol";case we:case ke:case Se:return "ordinal" === c ? "nominal" === s ? "category" : "ordinal" : void 0 !== f ? "diverging" : "rect" === o || "geoshape" === o ? "heatmap" : "ramp";case Oe:case _e:case Ne:return [r.scale.minOpacity, r.scale.maxOpacity];}}(e, n);return (void 0 !== l || void 0 !== c) && Wr(o, "rangeMin") && t.isArray(u) && 2 === u.length ? sc([l !== null && l !== void 0 ? l : u[0], c !== null && c !== void 0 ? c : u[1]]) : lc(u);}function mm(e) {return function (e) {return !t.isString(e) && !!e.name;}(e) ? _objectSpread({ scheme: e.name }, x(e, ["name"])) : { scheme: e };}function pm(e, t, n) {let { center: i } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};const r = mt(e),o = t.getName(r),a = t.getSignalName.bind(t);return e === ce && Nr(n) ? i ? [Xd.fromName((e) => "".concat(a(e), "/2"), o), Xd.fromName((e) => "-".concat(a(e), "/2"), o)] : [Xd.fromName(a, o), 0] : i ? [Xd.fromName((e) => "-".concat(a(e), "/2"), o), Xd.fromName((e) => "".concat(a(e), "/2"), o)] : [0, Xd.fromName(a, o)];}function gm(e, n, i) {const { encoding: r } = n,o = n.getScaleComponent(i),a = gt(i),s = r[a];if ("offset" === Ls({ step: e, offsetIsDiscrete: aa(s) && dr(s.type) }) && Ha(r, a)) {var _o$get;const i = n.getScaleComponent(a);let r = "domain('".concat(n.scaleName(a), "').length");if ("band" === i.get("type")) {var _ref18, _i$get, _ref19, _i$get2;r = "bandspace(".concat(r, ", ").concat((_ref18 = (_i$get = i.get("paddingInner")) !== null && _i$get !== void 0 ? _i$get : i.get("padding")) !== null && _ref18 !== void 0 ? _ref18 : 0, ", ").concat((_ref19 = (_i$get2 = i.get("paddingOuter")) !== null && _i$get2 !== void 0 ? _i$get2 : i.get("padding")) !== null && _ref19 !== void 0 ? _ref19 : 0, ")");}const s = (_o$get = o.get("paddingInner")) !== null && _o$get !== void 0 ? _o$get : o.get("padding");return { signal: "".concat(e.step, " * ").concat(r, " / (1-").concat((l = s, Fn(l) ? l.signal : t.stringValue(l)), ")") };}return e.step;var l;}function hm(e, t) {if ("offset" === Ls({ step: e, offsetIsDiscrete: _r(t) })) return { step: e.step };}function ym(e, t, n) {const i = e === le ? "width" : "height",r = t[i];return r || Is(n, i);}function vm(e, t, n) {if (t) return Fn(t) ? { signal: "".concat(t.signal, " ? 0 : ").concat(vm(e, !1, n)) } : 0;switch (e) {case "bar":case "tick":return n.scale.minBandSize;case "line":case "trail":case "rule":return n.scale.minStrokeWidth;case "text":return n.scale.minFontSize;case "point":case "square":case "circle":return n.scale.minSize;}throw new Error(gi("size", e));}const bm = .95;function xm(e, t, n) {const i = qs(e.width) ? e.width.step : Bs(n, "width"),r = qs(e.height) ? e.height.step : Bs(n, "height");return t.x || t.y ? new Xd(() => "min(".concat([t.x ? t.x.signal : i, t.y ? t.y.signal : r].join(", "), ")")) : Math.min(i, r);}function $m(e, t) {_m(e) ? function (e, t) {const n = e.component.scales,{ config: i, encoding: r, markDef: o, specifiedScales: a } = e;for (const s of j(n)) {const l = a[s],c = n[s],u = e.getScaleComponent(s),f = Sa(r[s]),d = l[t],m = u.get("type"),p = u.get("padding"),g = u.get("paddingInner"),h = Wr(m, t),y = Br(s, t);if (void 0 !== d && (h ? y && Ni(y) : Ni(wi(m, t, s))), h && void 0 === y) if (void 0 !== d) {const e = f.timeUnit,n = f.type;switch (t) {case "domainMax":case "domainMin":Ci(l[t]) || "temporal" === n || e ? c.set(t, { signal: Ca(l[t], { type: n, timeUnit: e }) }, !0) : c.set(t, l[t], !0);break;default:c.copyKeyFromObject(t, l);}} else {const n = t in wm ? wm[t]({ model: e, channel: s, fieldOrDatumDef: f, scaleType: m, scalePadding: p, scalePaddingInner: g, domain: l.domain, domainMin: l.domainMin, domainMax: l.domainMax, markDef: o, config: i, hasNestedOffsetScale: Va(r, s), hasSecondaryRangeChannel: !!r[dt(s)] }) : i.scale[t];void 0 !== n && c.set(t, n, !1);}}}(e, t) : Sm(e, t);}const wm = { bins: (e) => {let { model: t, fieldOrDatumDef: n } = e;return ea(n) ? function (e, t) {const n = t.bin;if (yn(n)) {const i = cd(e, t.field, n);return new Xd(() => e.getSignalName(i));}if (vn(n) && bn(n) && void 0 !== n.step) return { step: n.step };return;}(t, n) : void 0;}, interpolate: (e) => {let { channel: t, fieldOrDatumDef: n } = e;return function (e, t) {if (k([we, ke, Se], e) && "nominal" !== t) return "hcl";return;}(t, n.type);}, nice: (e) => {let { scaleType: n, channel: i, domain: r, domainMin: o, domainMax: a, fieldOrDatumDef: s } = e;return function (e, n, i, r, o, a, _ka) {if ((_ka = ka(a)) !== null && _ka !== void 0 && _ka.bin || t.isArray(i) || null != o || null != r || k([vr.TIME, vr.UTC], e)) return;return !!Et(n) || void 0;}(n, i, r, o, a, s);}, padding: (e) => {let { channel: t, scaleType: n, fieldOrDatumDef: i, markDef: r, config: o } = e;return function (e, t, n, i, r, o) {if (Et(e)) {if (Cr(t)) {if (void 0 !== n.continuousPadding) return n.continuousPadding;const { type: t, orient: a } = r;if ("bar" === t && (!ea(i) || !i.bin && !i.timeUnit) && ("vertical" === a && "x" === e || "horizontal" === a && "y" === e)) return o.continuousBandSize;}if (t === vr.POINT) return n.pointPadding;}return;}(t, n, o.scale, i, r, o.bar);}, paddingInner: (e) => {let { scalePadding: t, channel: n, markDef: i, scaleType: r, config: o, hasNestedOffsetScale: a } = e;return function (e, t, n, i, r) {let o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];if (void 0 !== e) return;if (Et(t)) {const { bandPaddingInner: e, barBandPaddingInner: t, rectBandPaddingInner: i, bandWithNestedOffsetPaddingInner: a } = r;return o ? a : X(e, "bar" === n ? t : i);}if (Rt(t) && i === vr.BAND) return r.offsetBandPaddingInner;return;}(t, n, i.type, r, o.scale, a);}, paddingOuter: (e) => {let { scalePadding: t, channel: n, scaleType: i, scalePaddingInner: r, config: o, hasNestedOffsetScale: a } = e;return function (e, t, n, i, r) {let o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];if (void 0 !== e) return;if (Et(t)) {const { bandPaddingOuter: e, bandWithNestedOffsetPaddingOuter: t } = r;if (o) return t;if (n === vr.BAND) return X(e, Fn(i) ? { signal: "".concat(i.signal, "/2") } : i / 2);} else if (Rt(t)) {if (n === vr.POINT) return .5;if (n === vr.BAND) return r.offsetBandPaddingOuter;}return;}(t, n, i, r, o.scale, a);}, reverse: (e) => {let { fieldOrDatumDef: t, scaleType: n, channel: i, config: r } = e;return function (e, t, n, i) {if ("x" === n && void 0 !== i.xReverse) return Nr(e) && "descending" === t ? Fn(i.xReverse) ? { signal: "!".concat(i.xReverse.signal) } : !i.xReverse : i.xReverse;if (Nr(e) && "descending" === t) return !0;return;}(n, ea(t) ? t.sort : void 0, i, r.scale);}, zero: (e) => {let { channel: n, fieldOrDatumDef: i, domain: r, markDef: o, scaleType: a, config: s, hasSecondaryRangeChannel: l } = e;return function (e, n, i, r, o, a, s) {if (i && "unaggregated" !== i && Nr(o)) {if (t.isArray(i)) {const e = i[0],n = i[i.length - 1];if (t.isNumber(e) && e <= 0 && t.isNumber(n) && n >= 0) return !0;}return !1;}if ("size" === e && "quantitative" === n.type && !Pr(o)) return !0;if ((!ea(n) || !n.bin) && k([...Tt, ...Lt], e)) {const { orient: t, type: n } = r;return (!k(["bar", "area", "line", "trail"], n) || !("horizontal" === t && "y" === e || "vertical" === t && "x" === e)) && (!(!k(["bar", "area"], n) || s) || (a === null || a === void 0 ? void 0 : a.zero));}return !1;}(n, i, r, o, a, s.scale, l);} };function km(e) {_m(e) ? function (e) {const t = e.component.scales;for (const n of Zt) {const i = t[n];if (!i) continue;const r = dm(n, e);i.setWithExplicit("range", r);}}(e) : Sm(e, "range");}function Sm(e, t) {const n = e.component.scales;for (const n of e.children) "range" === t ? km(n) : $m(n, t);for (const i of j(n)) {let r;for (const n of e.children) {const e = n.component.scales[i];if (e) {r = fc(r, e.getWithExplicit(t), t, "scale", cc((e, n) => "range" === t && e.step && n.step ? e.step - n.step : 0));}}n[i].setWithExplicit(t, r);}}function Dm(e, t, n, i) {const r = function (e, t, n, i, _t$axis) {switch (t.type) {case "nominal":case "ordinal":if (Ye(e) || "discrete" === an(e)) return "shape" === e && "ordinal" === t.type && Ni(vi(e, "ordinal")), "ordinal";if (Et(e) || Rt(e)) {if (k(["rect", "bar", "image", "rule"], n.type)) return "band";if (i) return "band";} else if ("arc" === n.type && e in Mt) return "band";return mo(n[mt(e)]) || ua(t) && (_t$axis = t.axis) !== null && _t$axis !== void 0 && _t$axis.tickBand ? "band" : "point";case "temporal":return Ye(e) ? "time" : "discrete" === an(e) ? (Ni(vi(e, "temporal")), "ordinal") : ea(t) && t.timeUnit && Xi(t.timeUnit).utc ? "utc" : "time";case "quantitative":return Ye(e) ? ea(t) && yn(t.bin) ? "bin-ordinal" : "linear" : "discrete" === an(e) ? (Ni(vi(e, "quantitative")), "ordinal") : "linear";case "geojson":return;}throw new Error(di(t.type));}(t, n, i, arguments.length > 4 && void 0 !== arguments[4] && arguments[4]),{ type: o } = e;return en(t) ? void 0 !== o ? function (e, t) {let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];if (!en(e)) return !1;switch (e) {case le:case ce:case de:case me:case he:case pe:return !!Cr(t) || "band" === t || "point" === t && !n;case Fe:case Ce:case Oe:case _e:case Ne:case ze:return Cr(t) || Pr(t) || k(["band", "point", "ordinal"], t);case we:case ke:case Se:return "band" !== t;case Pe:case De:return "ordinal" === t || Pr(t);}}(t, o) ? ea(n) && (a = o, s = n.type, !(k([pr, hr], s) ? void 0 === a || _r(a) : s === gr ? k([vr.TIME, vr.UTC, void 0], a) : s !== mr || Dr(a) || Pr(a) || void 0 === a)) ? (Ni(function (e, t) {return "FieldDef does not work with \"".concat(e, "\" scale. We are using \"").concat(t, "\" scale instead.");}(o, r)), r) : o : (Ni(function (e, t, n) {return "Channel \"".concat(e, "\" does not work with \"").concat(t, "\" scale. We are using \"").concat(n, "\" scale instead.");}(t, o, r)), r) : r : null;var a, s;}function Fm(e) {_m(e) ? e.component.scales = function (e) {const { encoding: t, mark: n, markDef: i } = e,r = {};for (const o of Zt) {const a = Sa(t[o]);if (a && n === ro && o === De && a.type === yr) continue;let s = a && a.scale;if (a && null !== s && !1 !== s) {var _s3;(_s3 = s) !== null && _s3 !== void 0 ? _s3 : s = {};const n = Dm(s, o, a, i, Va(t, o));r[o] = new cm(e.scaleName("".concat(o), !0), { value: n, explicit: s.type === n });}}return r;}(e) : e.component.scales = function (e) {const t = e.component.scales = {},n = {},i = e.component.resolve;for (const t of e.children) {Fm(t);for (const r of j(t.component.scales)) {var _i$scale4, _i$scale4$r;if ((_i$scale4$r = (_i$scale4 = i.scale)[r]) !== null && _i$scale4$r !== void 0 ? _i$scale4$r : _i$scale4[r] = Mf(r, e), "shared" === i.scale[r]) {const e = n[r],o = t.component.scales[r].getWithExplicit("type");e ? xr(e.value, o.value) ? n[r] = fc(e, o, "type", "scale", zm) : (i.scale[r] = "independent", delete n[r]) : n[r] = o;}}}for (const i of j(n)) {const r = e.scaleName(i, !0),o = n[i];t[i] = new cm(r, o);for (const t of e.children) {const e = t.component.scales[i];e && (t.renameScale(e.get("name"), r), e.merged = !0);}}return t;}(e);}const zm = cc((e, t) => wr(e) - wr(t));class Om {constructor() {Yn(this, "nameMap", void 0), this.nameMap = {};}rename(e, t) {this.nameMap[e] = t;}has(e) {return void 0 !== this.nameMap[e];}get(e) {for (; this.nameMap[e] && e !== this.nameMap[e];) e = this.nameMap[e];return e;}}function _m(e) {return "unit" === (e === null || e === void 0 ? void 0 : e.type);}function Nm(e) {return "facet" === (e === null || e === void 0 ? void 0 : e.type);}function Cm(e) {return "concat" === (e === null || e === void 0 ? void 0 : e.type);}function Pm(e) {return "layer" === (e === null || e === void 0 ? void 0 : e.type);}class Am {constructor(e, n, i, r, o, a, s) {var _e$name, _e$transform;this.type = n, this.parent = i, this.config = o, Yn(this, "name", void 0), Yn(this, "size", void 0), Yn(this, "title", void 0), Yn(this, "description", void 0), Yn(this, "data", void 0), Yn(this, "transforms", void 0), Yn(this, "layout", void 0), Yn(this, "scaleNameMap", void 0), Yn(this, "projectionNameMap", void 0), Yn(this, "signalNameMap", void 0), Yn(this, "component", void 0), Yn(this, "view", void 0), Yn(this, "children", void 0), Yn(this, "correctDataNames", (e) => {var _e$from2, _e$from3;return (_e$from2 = e.from) !== null && _e$from2 !== void 0 && _e$from2.data && (e.from.data = this.lookupDataSource(e.from.data)), (_e$from3 = e.from) !== null && _e$from3 !== void 0 && (_e$from3 = _e$from3.facet) !== null && _e$from3 !== void 0 && _e$from3.data && (e.from.facet.data = this.lookupDataSource(e.from.facet.data)), e;}), this.parent = i, this.config = o, this.view = kn(s), this.name = (_e$name = e.name) !== null && _e$name !== void 0 ? _e$name : r, this.title = Dn(e.title) ? { text: e.title } : e.title ? kn(e.title) : void 0, this.scaleNameMap = i ? i.scaleNameMap : new Om(), this.projectionNameMap = i ? i.projectionNameMap : new Om(), this.signalNameMap = i ? i.signalNameMap : new Om(), this.data = e.data, this.description = e.description, this.transforms = ((_e$transform = e.transform) !== null && _e$transform !== void 0 ? _e$transform : []).map((e) => Ol(e) ? { filter: h(e.filter, ur) } : e), this.layout = "layer" === n || "unit" === n ? {} : function (e, n, i) {const r = i[n],o = {},{ spacing: a, columns: s } = r;void 0 !== a && (o.spacing = a), void 0 !== s && (Io(e) && !Wo(e.facet) || Ts(e)) && (o.columns = s), Es(e) && (o.columns = 1);for (const n of Rs) if (void 0 !== e[n]) if ("spacing" === n) {var _i$row, _i$column;const i = e[n];o[n] = t.isNumber(i) ? i : { row: (_i$row = i.row) !== null && _i$row !== void 0 ? _i$row : a, column: (_i$column = i.column) !== null && _i$column !== void 0 ? _i$column : a };} else o[n] = e[n];return o;}(e, n, o), this.component = { data: { sources: i ? i.component.data.sources : [], outputNodes: i ? i.component.data.outputNodes : {}, outputNodeRefCounts: i ? i.component.data.outputNodeRefCounts : {}, isFaceted: Io(e) || (i === null || i === void 0 ? void 0 : i.component.data.isFaceted) && void 0 === e.data }, layoutSize: new ac(), layoutHeaders: { row: {}, column: {}, facet: {} }, mark: null, resolve: _objectSpread({ scale: {}, axis: {}, legend: {} }, a ? y(a) : {}), selection: null, scales: null, projection: null, axes: {}, legends: {} };}get width() {return this.getSizeSignalRef("width");}get height() {return this.getSizeSignalRef("height");}parse() {this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup();}parseScale() {!function (e) {let { ignoreRange: t } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};Fm(e), Jd(e);for (const t of Rr) $m(e, t);t || km(e);}(this);}parseProjection() {ad(this);}renameTopLevelLayoutSizeSignal() {"width" !== this.getName("width") && this.renameSignal(this.getName("width"), "width"), "height" !== this.getName("height") && this.renameSignal(this.getName("height"), "height");}parseLegends() {Jf(this);}assembleEncodeFromView(e) {const { style: t } = e,n = _objectWithoutProperties(e, _excluded56),i = {};for (const e of j(n)) {const t = n[e];void 0 !== t && (i[e] = Tn(t));}return i;}assembleGroupEncodeEntry(e) {var _t3;let t = {};return this.view && (t = this.assembleEncodeFromView(this.view)), e || (this.description && (t.description = Tn(this.description)), "unit" !== this.type && "layer" !== this.type) ? A(t) ? void 0 : t : _objectSpread({ width: this.getSizeSignalRef("width"), height: this.getSizeSignalRef("height") }, (_t3 = t) !== null && _t3 !== void 0 ? _t3 : {});}assembleLayout() {if (!this.layout) return;const _this$layout = this.layout,{ spacing: e } = _this$layout,t = _objectWithoutProperties(_this$layout, _excluded57),{ component: n, config: i } = this,r = function (e, t) {const n = {};for (const i of Je) {const r = e[i];if (r !== null && r !== void 0 && r.facetFieldDef) {const { titleAnchor: e, titleOrient: o } = vf(["titleAnchor", "titleOrient"], r.facetFieldDef.header, t, i),a = hf(i, o),s = _f(e, a);void 0 !== s && (n[a] = s);}}return A(n) ? void 0 : n;}(n.layoutHeaders, i);return _objectSpread(_objectSpread(_objectSpread({ padding: e }, this.assembleDefaultLayout()), t), r ? { titleBand: r } : {});}assembleDefaultLayout() {return {};}assembleHeaderMarks() {const { layoutHeaders: e } = this.component;let t = [];for (const n of Je) e[n].title && t.push($f(this, n));for (const e of bf) t = t.concat(Sf(this, e));return t;}assembleAxes() {return function (e, t) {const { x: n = [], y: i = [] } = e;return [...n.map((e) => rf(e, "grid", t)), ...i.map((e) => rf(e, "grid", t)), ...n.map((e) => rf(e, "main", t)), ...i.map((e) => rf(e, "main", t))].filter((e) => e);}(this.component.axes, this.config);}assembleLegends() {return td(this);}assembleProjections() {return nd(this);}assembleTitle() {var _this$title, _n$frame, _n$anchor;const _ref20 = (_this$title = this.title) !== null && _this$title !== void 0 ? _this$title : {},{ encoding: e } = _ref20,t = _objectWithoutProperties(_ref20, _excluded58),n = _objectSpread(_objectSpread(_objectSpread({}, Sn(this.config.title).nonMarkTitleProperties), t), e ? { encode: { update: e } } : {});if (n.text) return k(["unit", "layer"], this.type) ? k(["middle", void 0], n.anchor) && ((_n$frame = n.frame) !== null && _n$frame !== void 0 ? _n$frame : n.frame = "group") : (_n$anchor = n.anchor) !== null && _n$anchor !== void 0 ? _n$anchor : n.anchor = "start", A(n) ? void 0 : n;}assembleGroup() {let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];const t = {};e = e.concat(this.assembleSignals()), e.length > 0 && (t.signals = e);const n = this.assembleLayout();n && (t.layout = n), t.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());const i = !this.parent || Nm(this.parent) ? sm(this) : [];i.length > 0 && (t.scales = i);const r = this.assembleAxes();r.length > 0 && (t.axes = r);const o = this.assembleLegends();return o.length > 0 && (t.legends = o), t;}getName(e) {return L((this.name ? "".concat(this.name, "_") : "") + e);}getDataName(e) {return this.getName(xc[e].toLowerCase());}requestDataName(e) {const t = this.getDataName(e),n = this.component.data.outputNodeRefCounts;return n[t] = (n[t] || 0) + 1, t;}getSizeSignalRef(e) {if (Nm(this.parent)) {const t = qt(Tf(e)),n = this.component.scales[t];if (n && !n.merged) {const e = n.get("type"),i = n.get("range");if (_r(e) && zn(i)) {const e = n.get("name"),i = om(am(this, t));if (i) {return { signal: jf(e, n, pa({ aggregate: "distinct", field: i }, { expr: "datum" })) };}return Ni(ii(t)), null;}}}return { signal: this.signalNameMap.get(this.getName(e)) };}lookupDataSource(e) {const t = this.component.data.outputNodes[e];return t ? t.getSource() : e;}getSignalName(e) {return this.signalNameMap.get(e);}renameSignal(e, t) {this.signalNameMap.rename(e, t);}renameScale(e, t) {this.scaleNameMap.rename(e, t);}renameProjection(e, t) {this.projectionNameMap.rename(e, t);}scaleName(e, t) {return t ? this.getName(e) : st(e) && en(e) && this.component.scales[e] || this.scaleNameMap.has(this.getName(e)) ? this.scaleNameMap.get(this.getName(e)) : void 0;}projectionName(e) {return e ? this.getName("projection") : this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection")) ? this.projectionNameMap.get(this.getName("projection")) : void 0;}getScaleComponent(e) {if (!this.component.scales) throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");const t = this.component.scales[e];return t && !t.merged ? t : this.parent ? this.parent.getScaleComponent(e) : void 0;}getSelectionComponent(e, t) {let n = this.component.selection[e];if (!n && this.parent && (n = this.parent.getSelectionComponent(e, t)), !n) throw new Error(function (e) {return "Cannot find a selection named \"".concat(e, "\".");}(t));return n;}hasAxisOrientSignalRef() {var _this$component$axes$, _this$component$axes$2;return ((_this$component$axes$ = this.component.axes.x) === null || _this$component$axes$ === void 0 ? void 0 : _this$component$axes$.some((e) => e.hasOrientSignalRef())) || ((_this$component$axes$2 = this.component.axes.y) === null || _this$component$axes$2 === void 0 ? void 0 : _this$component$axes$2.some((e) => e.hasOrientSignalRef()));}}class jm extends Am {vgField(e) {let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};const n = this.fieldDef(e);if (n) return pa(n, t);}reduceFieldDef(e, n) {return function (e, n, i, r) {return e ? j(e).reduce((i, o) => {const a = e[o];return t.isArray(a) ? a.reduce((e, t) => n.call(r, e, t, o), i) : n.call(r, i, a, o);}, i) : i;}(this.getMapping(), (t, n, i) => {const r = ka(n);return r ? e(t, r, i) : t;}, n);}forEachFieldDef(e, t) {Qa(this.getMapping(), (t, n) => {const i = ka(t);i && e(i, n);}, t);}}class Tm extends zc {clone() {return new Tm(null, y(this.transform));}constructor(e, t) {var _this$transform$as, _n$, _n$2;super(e), this.transform = t, this.transform = y(t);const n = (_this$transform$as = this.transform.as) !== null && _this$transform$as !== void 0 ? _this$transform$as : [void 0, void 0];this.transform.as = [(_n$ = n[0]) !== null && _n$ !== void 0 ? _n$ : "value", (_n$2 = n[1]) !== null && _n$2 !== void 0 ? _n$2 : "density"];}dependentFields() {var _this$transform$group2;return new Set([this.transform.density, ...((_this$transform$group2 = this.transform.groupby) !== null && _this$transform$group2 !== void 0 ? _this$transform$group2 : [])]);}producedFields() {return new Set(this.transform.as);}hash() {return "DensityTransform ".concat($(this.transform));}assemble() {const _this$transform = this.transform,{ density: e } = _this$transform,t = _objectWithoutProperties(_this$transform, _excluded59),n = _objectSpread({ type: "kde", field: e }, t);return this.transform.groupby && (n.resolve = "shared"), n;}}class Em extends zc {clone() {return new Em(null, y(this.transform));}constructor(e, t) {super(e), this.transform = t, this.transform = y(t);}dependentFields() {return new Set([this.transform.extent]);}producedFields() {return new Set([]);}hash() {return "ExtentTransform ".concat($(this.transform));}assemble() {const { extent: e, param: t } = this.transform;return { type: "extent", field: e, signal: t };}}class Mm extends zc {clone() {return new Mm(null, _objectSpread({}, this.filter));}constructor(e, t) {super(e), this.filter = t;}static make(e, t) {const { config: n, mark: i, markDef: r } = t;if ("filter" !== Un("invalid", r, n)) return null;const o = t.reduceFieldDef((e, n, r) => {const o = en(r) && t.getScaleComponent(r);if (o) {Nr(o.get("type")) && "count" !== n.aggregate && !oo(i) && (e[n.field] = n);}return e;}, {});return j(o).length ? new Mm(e, o) : null;}dependentFields() {return new Set(j(this.filter));}producedFields() {return new Set();}hash() {return "FilterInvalid ".concat($(this.filter));}assemble() {const e = j(this.filter).reduce((e, t) => {const n = this.filter[t],i = pa(n, { expr: "datum" });return null !== n && ("temporal" === n.type ? e.push("(isDate(".concat(i, ") || (isValid(").concat(i, ") && isFinite(+").concat(i, ")))")) : "quantitative" === n.type && (e.push("isValid(".concat(i, ")")), e.push("isFinite(+".concat(i, ")")))), e;}, []);return e.length > 0 ? { type: "filter", expr: e.join(" && ") } : null;}}class Lm extends zc {clone() {return new Lm(this.parent, y(this.transform));}constructor(e, t) {super(e), this.transform = t, this.transform = y(t);const { flatten: n, as: i = [] } = this.transform;this.transform.as = n.map((e, t) => {var _i$t3;return (_i$t3 = i[t]) !== null && _i$t3 !== void 0 ? _i$t3 : e;});}dependentFields() {return new Set(this.transform.flatten);}producedFields() {return new Set(this.transform.as);}hash() {return "FlattenTransform ".concat($(this.transform));}assemble() {const { flatten: e, as: t } = this.transform;return { type: "flatten", fields: e, as: t };}}class qm extends zc {clone() {return new qm(null, y(this.transform));}constructor(e, t) {var _this$transform$as2, _n$3, _n$4;super(e), this.transform = t, this.transform = y(t);const n = (_this$transform$as2 = this.transform.as) !== null && _this$transform$as2 !== void 0 ? _this$transform$as2 : [void 0, void 0];this.transform.as = [(_n$3 = n[0]) !== null && _n$3 !== void 0 ? _n$3 : "key", (_n$4 = n[1]) !== null && _n$4 !== void 0 ? _n$4 : "value"];}dependentFields() {return new Set(this.transform.fold);}producedFields() {return new Set(this.transform.as);}hash() {return "FoldTransform ".concat($(this.transform));}assemble() {const { fold: e, as: t } = this.transform;return { type: "fold", fields: e, as: t };}}class Um extends zc {clone() {return new Um(null, y(this.fields), this.geojson, this.signal);}static parseAll(e, t) {if (t.component.projection && !t.component.projection.isFit) return e;let n = 0;for (const i of [[be, ve], [$e, xe]]) {const r = i.map((e) => {const n = Sa(t.encoding[e]);return ea(n) ? n.field : na(n) ? { expr: "".concat(n.datum) } : la(n) ? { expr: "".concat(n.value) } : void 0;});(r[0] || r[1]) && (e = new Um(e, r, null, t.getName("geojson_" + n++)));}if (t.channelHasField(De)) {const i = t.typedFieldDef(De);i.type === yr && (e = new Um(e, null, i.field, t.getName("geojson_" + n++)));}return e;}constructor(e, t, n, i) {super(e), this.fields = t, this.geojson = n, this.signal = i;}dependentFields() {var _this$fields;const e = ((_this$fields = this.fields) !== null && _this$fields !== void 0 ? _this$fields : []).filter(t.isString);return new Set([...(this.geojson ? [this.geojson] : []), ...e]);}producedFields() {return new Set();}hash() {return "GeoJSON ".concat(this.geojson, " ").concat(this.signal, " ").concat($(this.fields));}assemble() {return [...(this.geojson ? [{ type: "filter", expr: "isValid(datum[\"".concat(this.geojson, "\"])") }] : []), _objectSpread(_objectSpread(_objectSpread({ type: "geojson" }, this.fields ? { fields: this.fields } : {}), this.geojson ? { geojson: this.geojson } : {}), {}, { signal: this.signal })];}}class Rm extends zc {clone() {return new Rm(null, this.projection, y(this.fields), y(this.as));}constructor(e, t, n, i) {super(e), this.projection = t, this.fields = n, this.as = i;}static parseAll(e, t) {if (!t.projectionName()) return e;for (const n of [[be, ve], [$e, xe]]) {const i = n.map((e) => {const n = Sa(t.encoding[e]);return ea(n) ? n.field : na(n) ? { expr: "".concat(n.datum) } : la(n) ? { expr: "".concat(n.value) } : void 0;}),r = n[0] === $e ? "2" : "";(i[0] || i[1]) && (e = new Rm(e, t.projectionName(), i, [t.getName("x".concat(r)), t.getName("y".concat(r))]));}return e;}dependentFields() {return new Set(this.fields.filter(t.isString));}producedFields() {return new Set(this.as);}hash() {return "Geopoint ".concat(this.projection, " ").concat($(this.fields), " ").concat($(this.as));}assemble() {return { type: "geopoint", projection: this.projection, fields: this.fields, as: this.as };}}class Wm extends zc {clone() {return new Wm(null, y(this.transform));}constructor(e, t) {super(e), this.transform = t;}dependentFields() {var _this$transform$group3;return new Set([this.transform.impute, this.transform.key, ...((_this$transform$group3 = this.transform.groupby) !== null && _this$transform$group3 !== void 0 ? _this$transform$group3 : [])]);}producedFields() {return new Set([this.transform.impute]);}processSequence(e) {const { start: t = 0, stop: n, step: i } = e;return { signal: "sequence(".concat([t, n, ...(i ? [i] : [])].join(","), ")") };}static makeFromTransform(e, t) {return new Wm(e, t);}static makeFromEncoding(e, t) {const n = t.encoding,i = n.x,r = n.y;if (ea(i) && ea(r)) {const o = i.impute ? i : r.impute ? r : void 0;if (void 0 === o) return;const a = i.impute ? r : r.impute ? i : void 0,{ method: s, value: l, frame: c, keyvals: u } = o.impute,f = Ka(t.mark, n);return new Wm(e, _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({ impute: o.field, key: a.field }, s ? { method: s } : {}), void 0 !== l ? { value: l } : {}), c ? { frame: c } : {}), void 0 !== u ? { keyvals: u } : {}), f.length ? { groupby: f } : {}));}return null;}hash() {return "Impute ".concat($(this.transform));}assemble() {var _l3;const { impute: e, key: t, keyvals: n, method: i, groupby: r, value: o, frame: a = [null, null] } = this.transform,s = _objectSpread(_objectSpread(_objectSpread({ type: "impute", field: e, key: t }, n ? { keyvals: (l = n, void 0 !== ((_l3 = l) === null || _l3 === void 0 ? void 0 : _l3.stop) ? this.processSequence(n) : n) } : {}), {}, { method: "value" }, r ? { groupby: r } : {}), {}, { value: i && "value" !== i ? null : o });var l;if (i && "value" !== i) {return [s, _objectSpread({ type: "window", as: ["imputed_".concat(e, "_value")], ops: [i], fields: [e], frame: a, ignorePeers: !1 }, r ? { groupby: r } : {}), { type: "formula", expr: "datum.".concat(e, " === null ? datum.imputed_").concat(e, "_value : datum.").concat(e), as: e }];}return [s];}}class Bm extends zc {clone() {return new Bm(null, y(this.transform));}constructor(e, t) {var _this$transform$as3, _n$5, _n$6;super(e), this.transform = t, this.transform = y(t);const n = (_this$transform$as3 = this.transform.as) !== null && _this$transform$as3 !== void 0 ? _this$transform$as3 : [void 0, void 0];this.transform.as = [(_n$5 = n[0]) !== null && _n$5 !== void 0 ? _n$5 : t.on, (_n$6 = n[1]) !== null && _n$6 !== void 0 ? _n$6 : t.loess];}dependentFields() {var _this$transform$group4;return new Set([this.transform.loess, this.transform.on, ...((_this$transform$group4 = this.transform.groupby) !== null && _this$transform$group4 !== void 0 ? _this$transform$group4 : [])]);}producedFields() {return new Set(this.transform.as);}hash() {return "LoessTransform ".concat($(this.transform));}assemble() {const _this$transform2 = this.transform,{ loess: e, on: t } = _this$transform2,n = _objectWithoutProperties(_this$transform2, _excluded60);return _objectSpread({ type: "loess", x: t, y: e }, n);}}class Im extends zc {clone() {return new Im(null, y(this.transform), this.secondary);}constructor(e, t, n) {super(e), this.transform = t, this.secondary = n;}static make(e, t, n, i) {const r = t.component.data.sources,{ from: o } = n;let a = null;if (function (e) {return "data" in e;}(o)) {let e = op(o.data, r);e || (e = new wd(o.data), r.push(e));const n = t.getName("lookup_".concat(i));a = new Oc(e, n, xc.Lookup, t.component.data.outputNodeRefCounts), t.component.data.outputNodes[n] = a;} else if (function (e) {return "param" in e;}(o)) {const e = o.param;let i;n = _objectSpread({ as: e }, n);try {i = t.getSelectionComponent(L(e), e);} catch (t) {throw new Error(function (e) {return "Lookups can only be performed on selection parameters. \"".concat(e, "\" is a variable parameter.");}(e));}if (a = i.materialized, !a) throw new Error(function (e) {return "Cannot define and lookup the \"".concat(e, "\" selection in the same view. Try moving the lookup into a second, layered view?");}(e));}return new Im(e, n, a.getSource());}dependentFields() {return new Set([this.transform.lookup]);}producedFields() {return new Set(this.transform.as ? t.array(this.transform.as) : this.transform.from.fields);}hash() {return "Lookup ".concat($({ transform: this.transform, secondary: this.secondary }));}assemble() {let e;if (this.transform.from.fields) e = _objectSpread({ values: this.transform.from.fields }, this.transform.as ? { as: t.array(this.transform.as) } : {});else {let n = this.transform.as;t.isString(n) || (Ni('If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.'), n = "_lookup"), e = { as: [n] };}return _objectSpread(_objectSpread({ type: "lookup", from: this.secondary, key: this.transform.from.key, fields: [this.transform.lookup] }, e), this.transform.default ? { default: this.transform.default } : {});}}class Hm extends zc {clone() {return new Hm(null, y(this.transform));}constructor(e, t) {var _this$transform$as4, _n$7, _n$8;super(e), this.transform = t, this.transform = y(t);const n = (_this$transform$as4 = this.transform.as) !== null && _this$transform$as4 !== void 0 ? _this$transform$as4 : [void 0, void 0];this.transform.as = [(_n$7 = n[0]) !== null && _n$7 !== void 0 ? _n$7 : "prob", (_n$8 = n[1]) !== null && _n$8 !== void 0 ? _n$8 : "value"];}dependentFields() {var _this$transform$group5;return new Set([this.transform.quantile, ...((_this$transform$group5 = this.transform.groupby) !== null && _this$transform$group5 !== void 0 ? _this$transform$group5 : [])]);}producedFields() {return new Set(this.transform.as);}hash() {return "QuantileTransform ".concat($(this.transform));}assemble() {const _this$transform3 = this.transform,{ quantile: e } = _this$transform3,t = _objectWithoutProperties(_this$transform3, _excluded61);return _objectSpread({ type: "quantile", field: e }, t);}}class Vm extends zc {clone() {return new Vm(null, y(this.transform));}constructor(e, t) {var _this$transform$as5, _n$9, _n$10;super(e), this.transform = t, this.transform = y(t);const n = (_this$transform$as5 = this.transform.as) !== null && _this$transform$as5 !== void 0 ? _this$transform$as5 : [void 0, void 0];this.transform.as = [(_n$9 = n[0]) !== null && _n$9 !== void 0 ? _n$9 : t.on, (_n$10 = n[1]) !== null && _n$10 !== void 0 ? _n$10 : t.regression];}dependentFields() {var _this$transform$group6;return new Set([this.transform.regression, this.transform.on, ...((_this$transform$group6 = this.transform.groupby) !== null && _this$transform$group6 !== void 0 ? _this$transform$group6 : [])]);}producedFields() {return new Set(this.transform.as);}hash() {return "RegressionTransform ".concat($(this.transform));}assemble() {const _this$transform4 = this.transform,{ regression: e, on: t } = _this$transform4,n = _objectWithoutProperties(_this$transform4, _excluded62);return _objectSpread({ type: "regression", x: t, y: e }, n);}}class Gm extends zc {clone() {return new Gm(null, y(this.transform));}constructor(e, t) {super(e), this.transform = t;}addDimensions(e) {var _this$transform$group7;this.transform.groupby = O(((_this$transform$group7 = this.transform.groupby) !== null && _this$transform$group7 !== void 0 ? _this$transform$group7 : []).concat(e), (e) => e);}producedFields() {}dependentFields() {var _this$transform$group8;return new Set([this.transform.pivot, this.transform.value, ...((_this$transform$group8 = this.transform.groupby) !== null && _this$transform$group8 !== void 0 ? _this$transform$group8 : [])]);}hash() {return "PivotTransform ".concat($(this.transform));}assemble() {const { pivot: e, value: t, groupby: n, limit: i, op: r } = this.transform;return _objectSpread(_objectSpread(_objectSpread({ type: "pivot", field: e, value: t }, void 0 !== i ? { limit: i } : {}), void 0 !== r ? { op: r } : {}), void 0 !== n ? { groupby: n } : {});}}class Ym extends zc {clone() {return new Ym(null, y(this.transform));}constructor(e, t) {super(e), this.transform = t;}dependentFields() {return new Set();}producedFields() {return new Set();}hash() {return "SampleTransform ".concat($(this.transform));}assemble() {return { type: "sample", size: this.transform.sample };}}function Xm(e) {let t = 0;return function n(i, r) {var _r$format2;if (i instanceof wd && !i.isGenerator && !mc(i.data)) {e.push(r);r = { name: null, source: r.name, transform: [] };}if (i instanceof vd && (i.parent instanceof wd && !r.source ? (r.format = _objectSpread(_objectSpread({}, (_r$format2 = r.format) !== null && _r$format2 !== void 0 ? _r$format2 : {}), {}, { parse: i.assembleFormatParse() }), r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof pd) return r.name || (r.name = "data_" + t++), !r.source || r.transform.length > 0 ? (e.push(r), i.data = r.name) : i.data = r.source, void e.push(...i.assemble());if ((i instanceof xd || i instanceof $d || i instanceof Mm || i instanceof Ku || i instanceof pf || i instanceof Rm || i instanceof md || i instanceof Im || i instanceof Rd || i instanceof qd || i instanceof qm || i instanceof Lm || i instanceof Tm || i instanceof Bm || i instanceof Hm || i instanceof Vm || i instanceof bd || i instanceof Ym || i instanceof Gm || i instanceof Em) && r.transform.push(i.assemble()), (i instanceof fd || i instanceof Cc || i instanceof Wm || i instanceof Ud || i instanceof Um) && r.transform.push(...i.assemble()), i instanceof Oc) if (r.source && 0 === r.transform.length) i.setSource(r.source);else if (i.parent instanceof Oc) i.setSource(r.name);else if (r.name || (r.name = "data_" + t++), i.setSource(r.name), 1 === i.numChildren()) {e.push(r);r = { name: null, source: r.name, transform: [] };}switch (i.numChildren()) {case 0:i instanceof Oc && (!r.source || r.transform.length > 0) && e.push(r);break;case 1:n(i.children[0], r);break;default:{r.name || (r.name = "data_" + t++);let o = r.name;!r.source || r.transform.length > 0 ? e.push(r) : o = r.source;for (const e of i.children) {n(e, { name: null, source: o, transform: [] });}break;}}};}function Jm(e) {return "top" === e || "left" === e || Fn(e) ? "header" : "footer";}function Qm(e, n) {const { facet: i, config: r, child: o, component: a } = e;if (e.channelHasField(n)) {var _s$header;const s = i[n],l = yf("title", null, r, n);let c = ba(s, r, { allowDisabling: !0, includeDefault: void 0 === l || !!l });o.component.layoutHeaders[n].title && (c = t.isArray(c) ? c.join(", ") : c, c += " / ".concat(o.component.layoutHeaders[n].title), o.component.layoutHeaders[n].title = null);const u = yf("labelOrient", s.header, r, n),f = null !== s.header && X((_s$header = s.header) === null || _s$header === void 0 ? void 0 : _s$header.labels, r.header.labels, !0),d = k(["bottom", "right"], u) ? "footer" : "header";a.layoutHeaders[n] = { title: null !== s.header ? c : null, facetFieldDef: s, [d]: "facet" === n ? [] : [Km(e, n, f)] };}}function Km(e, t, n) {const i = "row" === t ? "height" : "width";return { labels: n, sizeSignal: e.child.component.layoutSize.get(i) ? e.child.getSizeSignalRef(i) : void 0, axes: [] };}function Zm(e, t) {const { child: n } = e;if (n.component.axes[t]) {const { layoutHeaders: i, resolve: r } = e.component;if (r.axis[t] = Lf(r, t), "shared" === r.axis[t]) {const r = "x" === t ? "column" : "row",o = i[r];for (const i of n.component.axes[t]) {var _o$t;const t = Jm(i.get("orient"));(_o$t = o[t]) !== null && _o$t !== void 0 ? _o$t : o[t] = [Km(e, r, !1)];const n = rf(i, "main", e.config, { header: !0 });n && o[t][0].axes.push(n), i.mainExtracted = !0;}}}}function ep(e) {for (const t of e.children) t.parseLayoutSize();}function tp(e, t) {const n = Tf(t),i = qt(n),r = e.component.resolve,o = e.component.layoutSize;let a;for (const t of e.children) {var _r$scale$i;const o = t.component.layoutSize.getWithExplicit(n),s = (_r$scale$i = r.scale[i]) !== null && _r$scale$i !== void 0 ? _r$scale$i : Mf(i, e);if ("independent" === s && "step" === o.value) {a = void 0;break;}if (a) {if ("independent" === s && a.value !== o.value) {a = void 0;break;}a = fc(a, o, n, "");} else a = o;}if (a) {for (const i of e.children) e.renameSignal(i.getName(n), e.getName(t)), i.component.layoutSize.set(n, "merged", !1);o.setWithExplicit(t, a);} else o.setWithExplicit(t, { explicit: !1, value: void 0 });}function np(e, t) {const n = "width" === t ? "x" : "y",i = e.config,r = e.getScaleComponent(n);if (r) {const e = r.get("type"),n = r.get("range");if (_r(e)) {const e = Is(i.view, t);return zn(n) || qs(e) ? "step" : e;}return Ws(i.view, t);}if (e.hasProjection || "arc" === e.mark) return Ws(i.view, t);{const e = Is(i.view, t);return qs(e) ? e.step : e;}}function ip(e, t, n) {return pa(t, _objectSpread({ suffix: "by_".concat(pa(e)) }, n !== null && n !== void 0 ? n : {}));}class rp extends jm {constructor(e, t, n, i) {super(e, "facet", t, n, i, e.resolve), Yn(this, "facet", void 0), Yn(this, "child", void 0), Yn(this, "children", void 0), this.child = Cp(e.spec, this, this.getName("child"), void 0, i), this.children = [this.child], this.facet = this.initFacet(e.facet);}initFacet(e) {if (!Wo(e)) return { facet: this.initFacetFieldDef(e, "facet") };const t = j(e),n = {};for (const i of t) {if (![oe, ae].includes(i)) {Ni(gi(i, "facet"));break;}const t = e[i];if (void 0 === t.field) {Ni(pi(t, i));break;}n[i] = this.initFacetFieldDef(t, i);}return n;}initFacetFieldDef(e, t) {const n = za(e, t);return n.header ? n.header = kn(n.header) : null === n.header && (n.header = null), n;}channelHasField(e) {return !!this.facet[e];}fieldDef(e) {return this.facet[e];}parseData() {this.component.data = ap(this), this.child.parseData();}parseLayoutSize() {ep(this);}parseSelections() {this.child.parseSelections(), this.component.selection = this.child.component.selection;}parseMarkGroup() {this.child.parseMarkGroup();}parseAxesAndHeaders() {this.child.parseAxesAndHeaders(), function (e) {for (const t of Je) Qm(e, t);Zm(e, "x"), Zm(e, "y");}(this);}assembleSelectionTopLevelSignals(e) {return this.child.assembleSelectionTopLevelSignals(e);}assembleSignals() {return this.child.assembleSignals(), [];}assembleSelectionData(e) {return this.child.assembleSelectionData(e);}getHeaderLayoutMixins() {const e = {};for (const t of Je) for (const n of xf) {const i = this.component.layoutHeaders[t],r = i[n],{ facetFieldDef: o } = i;if (o) {const n = yf("titleOrient", o.header, this.config, t);if (["right", "bottom"].includes(n)) {var _e$titleAnchor;const i = hf(t, n);(_e$titleAnchor = e.titleAnchor) !== null && _e$titleAnchor !== void 0 ? _e$titleAnchor : e.titleAnchor = {}, e.titleAnchor[i] = "end";}}if (r !== null && r !== void 0 && r[0]) {var _e$o, _e$offset;const r = "row" === t ? "height" : "width",o = "header" === n ? "headerBand" : "footerBand";"facet" === t || this.child.component.layoutSize.get(r) || ((_e$o = e[o]) !== null && _e$o !== void 0 ? _e$o : e[o] = {}, e[o][t] = .5), i.title && ((_e$offset = e.offset) !== null && _e$offset !== void 0 ? _e$offset : e.offset = {}, e.offset["row" === t ? "rowTitle" : "columnTitle"] = 10);}}return e;}assembleDefaultLayout() {const { column: e, row: t } = this.facet,n = e ? this.columnDistinctSignal() : t ? 1 : void 0;let i = "all";return (t || "independent" !== this.component.resolve.scale.x) && (e || "independent" !== this.component.resolve.scale.y) || (i = "none"), _objectSpread(_objectSpread(_objectSpread({}, this.getHeaderLayoutMixins()), n ? { columns: n } : {}), {}, { bounds: "full", align: i });}assembleLayoutSignals() {return this.child.assembleLayoutSignals();}columnDistinctSignal() {if (!(this.parent && this.parent instanceof rp)) {return { signal: "length(data('".concat(this.getName("column_domain"), "'))") };}}assembleGroupStyle() {}assembleGroup(e) {return this.parent && this.parent instanceof rp ? _objectSpread(_objectSpread({}, this.channelHasField("column") ? { encode: { update: { columns: { field: pa(this.facet.column, { prefix: "distinct" }) } } } } : {}), super.assembleGroup(e)) : super.assembleGroup(e);}getCardinalityAggregateForChild() {const e = [],t = [],n = [];if (this.child instanceof rp) {if (this.child.channelHasField("column")) {const i = pa(this.child.facet.column);e.push(i), t.push("distinct"), n.push("distinct_".concat(i));}} else for (const i of Tt) {const r = this.child.component.scales[i];if (r && !r.merged) {const o = r.get("type"),a = r.get("range");if (_r(o) && zn(a)) {const r = om(am(this.child, i));r ? (e.push(r), t.push("distinct"), n.push("distinct_".concat(r))) : Ni(ii(i));}}}return { fields: e, ops: t, as: n };}assembleFacet() {const { name: e, data: n } = this.component.data.facetRoot,{ row: i, column: r } = this.facet,{ fields: o, ops: a, as: s } = this.getCardinalityAggregateForChild(),l = [];for (const e of Je) {const n = this.facet[e];if (n) {l.push(pa(n));const { bin: c, sort: u } = n;if (yn(c) && l.push(pa(n, { binSuffix: "end" })), Uo(u)) {const { field: e, op: t = Eo } = u,l = ip(n, u);i && r ? (o.push(l), a.push("max"), s.push(l)) : (o.push(e), a.push(t), s.push(l));} else if (t.isArray(u)) {const t = gf(n, e);o.push(t), a.push("max"), s.push(t);}}}const c = !!i && !!r;return _objectSpread({ name: e, data: n, groupby: l }, c || o.length > 0 ? { aggregate: _objectSpread(_objectSpread({}, c ? { cross: c } : {}), o.length ? { fields: o, ops: a, as: s } : {}) } : {});}facetSortFields(e) {const { facet: n } = this,i = n[e];return i ? Uo(i.sort) ? [ip(i, i.sort, { expr: "datum" })] : t.isArray(i.sort) ? [gf(i, e, { expr: "datum" })] : [pa(i, { expr: "datum" })] : [];}facetSortOrder(e) {const { facet: n } = this,i = n[e];if (i) {const { sort: e } = i;return [(Uo(e) ? e.order : !t.isArray(e) && e) || "ascending"];}return [];}assembleLabelTitle() {const { facet: e, config: t } = this;if (e.facet) return Ff(e.facet, "facet", t);const n = { row: ["top", "bottom"], column: ["left", "right"] };for (const i of bf) if (e[i]) {var _e$i;const r = yf("labelOrient", (_e$i = e[i]) === null || _e$i === void 0 ? void 0 : _e$i.header, t, i);if (n[i].includes(r)) return Ff(e[i], i, t);}}assembleMarks() {const { child: e } = this,t = function (e) {const t = [],n = Xm(t);for (const t of e.children) n(t, { source: e.name, name: null, transform: [] });return t;}(this.component.data.facetRoot),n = e.assembleGroupEncodeEntry(!1),i = this.assembleLabelTitle() || e.assembleTitle(),r = e.assembleGroupStyle();return [_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({ name: this.getName("cell"), type: "group" }, i ? { title: i } : {}), r ? { style: r } : {}), {}, { from: { facet: this.assembleFacet() }, sort: { field: Je.map((e) => this.facetSortFields(e)).flat(), order: Je.map((e) => this.facetSortOrder(e)).flat() } }, t.length > 0 ? { data: t } : {}), n ? { encode: { update: n } } : {}), e.assembleGroup(Sc(this, [])))];}getMapping() {return this.facet;}}function op(e, t) {for (const n of t) {var _e$format, _t$format, _e$format2, _t$format2;const t = n.data;if (e.name && n.hasName() && e.name !== n.dataName) continue;const i = (_e$format = e.format) === null || _e$format === void 0 ? void 0 : _e$format.mesh,r = (_t$format = t.format) === null || _t$format === void 0 ? void 0 : _t$format.feature;if (i && r) continue;const o = (_e$format2 = e.format) === null || _e$format2 === void 0 ? void 0 : _e$format2.feature;if ((o || r) && o !== r) continue;const a = (_t$format2 = t.format) === null || _t$format2 === void 0 ? void 0 : _t$format2.mesh;if (!i && !a || i === a) if (pc(e) && pc(t)) {if (ie(e.values, t.values)) return n;} else if (mc(e) && mc(t)) {if (e.url === t.url) return n;} else if (gc(e) && e.name === n.dataName) return n;}return null;}function ap(e) {var _r$format3, _vd$makeExplicit, _fd$makeFromEncoding, _vd$makeWithAncestors2, _fd$makeFromEncoding2, _Cc$makeFromEncoding, _Mm$make;let t = function (e, t) {if (e.data || !e.parent) {if (null === e.data) {const e = new wd({ values: [] });return t.push(e), e;}const n = op(e.data, t);if (n) return hc(e.data) || (n.data.format = F({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n;{const n = new wd(e.data);return t.push(n), n;}}return e.parent.component.data.facetRoot ? e.parent.component.data.facetRoot : e.parent.component.data.main;}(e, e.component.data.sources);const { outputNodes: n, outputNodeRefCounts: i } = e.component.data,r = e.data,o = !(r && (hc(r) || mc(r) || pc(r))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new dc();hc(r) ? (yc(r) ? t = new $d(t, r.sequence) : bc(r) && (t = new xd(t, r.graticule)), o.parseNothing = !0) : null === (r === null || r === void 0 || (_r$format3 = r.format) === null || _r$format3 === void 0 ? void 0 : _r$format3.parse) && (o.parseNothing = !0), t = (_vd$makeExplicit = vd.makeExplicit(t, e, o)) !== null && _vd$makeExplicit !== void 0 ? _vd$makeExplicit : t, t = new bd(t);const a = e.parent && Pm(e.parent);(_m(e) || Nm(e)) && a && (t = (_fd$makeFromEncoding = fd.makeFromEncoding(t, e)) !== null && _fd$makeFromEncoding !== void 0 ? _fd$makeFromEncoding : t), e.transforms.length > 0 && (t = function (e, t, n) {let i = 0;for (const r of t.transforms) {let o, a;if (ql(r)) a = e = new pf(e, r), o = "derived";else if (Ol(r)) {var _vd$makeWithAncestors;const i = hd(r);a = e = (_vd$makeWithAncestors = vd.makeWithAncestors(e, {}, i, n)) !== null && _vd$makeWithAncestors !== void 0 ? _vd$makeWithAncestors : e, e = new Ku(e, t, r.filter);} else if (Ul(r)) a = e = fd.makeFromTransform(e, r, t), o = "number";else if (Wl(r)) o = "date", void 0 === n.getWithExplicit(r.field).value && (e = new vd(e, { [r.field]: o }), n.set(r.field, o, !1)), a = e = Cc.makeFromTransform(e, r);else if (Bl(r)) a = e = md.makeFromTransform(e, r), o = "number", Gu(t) && (e = new bd(e));else if (_l(r)) a = e = Im.make(e, t, r, i++), o = "derived";else if (El(r)) a = e = new Rd(e, r), o = "number";else if (Ml(r)) a = e = new qd(e, r), o = "number";else if (Il(r)) a = e = Ud.makeFromTransform(e, r), o = "derived";else if (Hl(r)) a = e = new qm(e, r), o = "derived";else if (Vl(r)) a = e = new Em(e, r), o = "derived";else if (Ll(r)) a = e = new Lm(e, r), o = "derived";else if (Nl(r)) a = e = new Gm(e, r), o = "derived";else if (Tl(r)) e = new Ym(e, r);else if (Rl(r)) a = e = Wm.makeFromTransform(e, r), o = "derived";else if (Cl(r)) a = e = new Tm(e, r), o = "derived";else if (Pl(r)) a = e = new Hm(e, r), o = "derived";else if (Al(r)) a = e = new Vm(e, r), o = "derived";else {if (!jl(r)) {Ni("Ignoring an invalid transform: ".concat(re(r), "."));continue;}a = e = new Bm(e, r), o = "derived";}if (a && void 0 !== o) for (const e of (_a$producedFields = a.producedFields()) !== null && _a$producedFields !== void 0 ? _a$producedFields : []) {var _a$producedFields;n.set(e, o, !1);}}return e;}(t, e, o));const s = function (e) {const t = {};if (_m(e) && e.component.selection) for (const n of j(e.component.selection)) {const i = e.component.selection[n];for (const e of i.project.items) !e.channel && Y(e.field) > 1 && (t[e.field] = "flatten");}return t;}(e),l = yd(e);t = (_vd$makeWithAncestors2 = vd.makeWithAncestors(t, {}, _objectSpread(_objectSpread({}, s), l), o)) !== null && _vd$makeWithAncestors2 !== void 0 ? _vd$makeWithAncestors2 : t, _m(e) && (t = Um.parseAll(t, e), t = Rm.parseAll(t, e)), (_m(e) || Nm(e)) && (a || (t = (_fd$makeFromEncoding2 = fd.makeFromEncoding(t, e)) !== null && _fd$makeFromEncoding2 !== void 0 ? _fd$makeFromEncoding2 : t), t = (_Cc$makeFromEncoding = Cc.makeFromEncoding(t, e)) !== null && _Cc$makeFromEncoding !== void 0 ? _Cc$makeFromEncoding : t, t = pf.parseAllForSortIndex(t, e));const c = e.getDataName(xc.Raw),u = new Oc(t, c, xc.Raw, i);if (n[c] = u, t = u, _m(e)) {var _Wm$makeFromEncoding, _Ud$makeFromEncoding;const n = md.makeFromEncoding(t, e);n && (t = n, Gu(e) && (t = new bd(t))), t = (_Wm$makeFromEncoding = Wm.makeFromEncoding(t, e)) !== null && _Wm$makeFromEncoding !== void 0 ? _Wm$makeFromEncoding : t, t = (_Ud$makeFromEncoding = Ud.makeFromEncoding(t, e)) !== null && _Ud$makeFromEncoding !== void 0 ? _Ud$makeFromEncoding : t;}_m(e) && (t = (_Mm$make = Mm.make(t, e)) !== null && _Mm$make !== void 0 ? _Mm$make : t);const f = e.getDataName(xc.Main),d = new Oc(t, f, xc.Main, i);n[f] = d, t = d, _m(e) && function (e, t) {for (const [n, i] of E((_e$component$selectio6 = e.component.selection) !== null && _e$component$selectio6 !== void 0 ? _e$component$selectio6 : {})) {var _e$component$selectio6;const r = e.getName("lookup_".concat(n));e.component.data.outputNodes[r] = i.materialized = new Oc(new Ku(t, e, { param: n }), r, xc.Lookup, e.component.data.outputNodeRefCounts);}}(e, d);let m = null;if (Nm(e)) {var _ref21;const i = e.getName("facet");t = (_ref21 = function (e, t) {const { row: n, column: i } = t;if (n && i) {let t = null;for (const r of [n, i]) if (Uo(r.sort)) {const { field: n, op: i = Eo } = r.sort;e = t = new qd(e, { joinaggregate: [{ op: i, field: n, as: ip(r, r.sort, { forAs: !0 }) }], groupby: [pa(r)] });}return t;}return null;}(t, e.facet)) !== null && _ref21 !== void 0 ? _ref21 : t, m = new pd(t, e, i, d.getSource()), n[i] = m;}return _objectSpread(_objectSpread({}, e.component.data), {}, { outputNodes: n, outputNodeRefCounts: i, raw: u, main: d, facetRoot: m, ancestorParse: o });}class sp extends Am {constructor(e, t, n, i) {var _e$resolve, _e$resolve2;super(e, "concat", t, n, i, e.resolve), Yn(this, "children", void 0), "shared" !== ((_e$resolve = e.resolve) === null || _e$resolve === void 0 || (_e$resolve = _e$resolve.axis) === null || _e$resolve === void 0 ? void 0 : _e$resolve.x) && "shared" !== ((_e$resolve2 = e.resolve) === null || _e$resolve2 === void 0 || (_e$resolve2 = _e$resolve2.axis) === null || _e$resolve2 === void 0 ? void 0 : _e$resolve2.y) || Ni("Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415)."), this.children = this.getChildren(e).map((e, t) => Cp(e, this, this.getName("concat_".concat(t)), void 0, i));}parseData() {this.component.data = ap(this);for (const e of this.children) e.parseData();}parseSelections() {this.component.selection = {};for (const e of this.children) {e.parseSelections();for (const t of j(e.component.selection)) this.component.selection[t] = e.component.selection[t];}}parseMarkGroup() {for (const e of this.children) e.parseMarkGroup();}parseAxesAndHeaders() {for (const e of this.children) e.parseAxesAndHeaders();}getChildren(e) {return Es(e) ? e.vconcat : Ms(e) ? e.hconcat : e.concat;}parseLayoutSize() {!function (e) {ep(e);const t = 1 === e.layout.columns ? "width" : "childWidth",n = void 0 === e.layout.columns ? "height" : "childHeight";tp(e, t), tp(e, n);}(this);}parseAxisGroup() {return null;}assembleSelectionTopLevelSignals(e) {return this.children.reduce((e, t) => t.assembleSelectionTopLevelSignals(e), e);}assembleSignals() {return this.children.forEach((e) => e.assembleSignals()), [];}assembleLayoutSignals() {const e = Cf(this);for (const t of this.children) e.push(...t.assembleLayoutSignals());return e;}assembleSelectionData(e) {return this.children.reduce((e, t) => t.assembleSelectionData(e), e);}assembleMarks() {return this.children.map((e) => {const t = e.assembleTitle(),n = e.assembleGroupStyle(),i = e.assembleGroupEncodeEntry(!1);return _objectSpread(_objectSpread(_objectSpread(_objectSpread({ type: "group", name: e.getName("group") }, t ? { title: t } : {}), n ? { style: n } : {}), i ? { encode: { update: i } } : {}), e.assembleGroup());});}assembleGroupStyle() {}assembleDefaultLayout() {const e = this.layout.columns;return _objectSpread(_objectSpread({}, null != e ? { columns: e } : {}), {}, { bounds: "full", align: "each" });}}const lp = _objectSpread(_objectSpread({ disable: 1, gridScale: 1, scale: 1 }, La), {}, { labelExpr: 1, encode: 1 }),cp = j(lp);class up extends ac {constructor() {let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];super(), this.explicit = e, this.implicit = t, this.mainExtracted = n;}clone() {return new up(y(this.explicit), y(this.implicit), this.mainExtracted);}hasAxisPart(e) {return "axis" === e || ("grid" === e || "title" === e ? !!this.get(e) : !(!1 === (t = this.get(e)) || null === t));var t;}hasOrientSignalRef() {return Fn(this.explicit.orient);}}const fp = { bottom: "top", top: "bottom", left: "right", right: "left" };function dp(e, t) {if (!e) return t.map((e) => e.clone());{if (e.length !== t.length) return;const n = e.length;for (let i = 0; i < n; i++) {const n = e[i],r = t[i];if (!!n != !!r) return;if (n && r) {const t = n.getWithExplicit("orient"),o = r.getWithExplicit("orient");if (t.explicit && o.explicit && t.value !== o.value) return;e[i] = mp(n, r);}}}return e;}function mp(e, t) {for (const n of cp) {const i = fc(e.getWithExplicit(n), t.getWithExplicit(n), n, "axis", (e, t) => {switch (n) {case "title":return Gn(e, t);case "gridScale":return { explicit: e.explicit, value: X(e.value, t.value) };}return uc(e, t, n, "axis");});e.setWithExplicit(n, i);}return e;}function pp(e, t, n, i, r) {if ("disable" === t) return void 0 !== n;switch (n = n || {}, t) {case "titleAngle":case "labelAngle":return e === (Fn(n.labelAngle) ? n.labelAngle : ee(n.labelAngle));case "values":return !!n.values;case "encode":return !!n.encoding || !!n.labelAngle;case "title":if (e === mf(i, r)) return !0;}return e === n[t];}const gp = new Set(["grid", "translate", "format", "formatType", "orient", "labelExpr", "tickCount", "position", "tickMinStep"]);function hp(e, t) {var _n6, _a2, _a$axis, _n7, _n$encoding2;let n = t.axis(e);const i = new up(),r = Sa(t.encoding[e]),{ mark: o, config: a } = t,s = ((_n6 = n) === null || _n6 === void 0 ? void 0 : _n6.orient) || ((_a2 = a["x" === e ? "axisX" : "axisY"]) === null || _a2 === void 0 ? void 0 : _a2.orient) || ((_a$axis = a.axis) === null || _a$axis === void 0 ? void 0 : _a$axis.orient) || function (e) {return "x" === e ? "bottom" : "left";}(e),l = t.getScaleComponent(e).get("type"),c = function (e, t, n, i) {const r = "band" === t ? ["axisDiscrete", "axisBand"] : "point" === t ? ["axisDiscrete", "axisPoint"] : Dr(t) ? ["axisQuantitative"] : "time" === t || "utc" === t ? ["axisTemporal"] : [],o = "x" === e ? "axisX" : "axisY",a = Fn(n) ? "axisOrient" : "axis".concat(R(n)),s = [...r, ...r.map((e) => o + e.substr(4))],l = ["axis", a, o];return { vlOnlyAxisConfig: af(s, i, e, n), vgAxisConfig: af(l, i, e, n), axisConfigStyle: sf([...l, ...s], i) };}(e, l, s, t.config),u = void 0 !== n ? !n : lf("disable", a.style, (_n7 = n) === null || _n7 === void 0 ? void 0 : _n7.style, c).configValue;if (i.set("disable", u, void 0 !== n), u) return i;n = n || {};const f = function (e, t, n, i, r) {const o = t === null || t === void 0 ? void 0 : t.labelAngle;if (void 0 !== o) return Fn(o) ? o : ee(o);{const { configValue: o } = lf("labelAngle", i, t === null || t === void 0 ? void 0 : t.style, r);return void 0 !== o ? ee(o) : n !== le || !k([hr, pr], e.type) || ea(e) && e.timeUnit ? void 0 : 270;}}(r, n, e, a.style, c),d = Co(n.formatType, r, l),m = No(r, r.type, n.format, n.formatType, a, !0),p = { fieldOrDatumDef: r, axis: n, channel: e, model: t, scaleType: l, orient: s, labelAngle: f, format: m, formatType: d, mark: o, config: a };for (const r of cp) {const o = r in cf ? cf[r](p) : Ua(r) ? n[r] : void 0,s = void 0 !== o,l = pp(o, r, n, t, e);if (s && l) i.set(r, o, l);else {const { configValue: e, configFrom: t } = Ua(r) && "values" !== r ? lf(r, a.style, n.style, c) : {},u = void 0 !== e;s && !u ? i.set(r, o, l) : ("vgAxisConfig" !== t || gp.has(r) && u || Ta(e) || Fn(e)) && i.set(r, e, !1);}}const g = (_n$encoding2 = n.encoding) !== null && _n$encoding2 !== void 0 ? _n$encoding2 : {},h = Ea.reduce((n, r) => {var _g$r;if (!i.hasAxisPart(r)) return n;const o = Ef((_g$r = g[r]) !== null && _g$r !== void 0 ? _g$r : {}, t),a = "labels" === r ? function (e, t, n, _Sa) {const { encoding: i, config: r } = e,o = (_Sa = Sa(i[t])) !== null && _Sa !== void 0 ? _Sa : Sa(i[dt(t)]),a = e.axis(t) || {},{ format: s, formatType: l } = a;if (So(l)) return _objectSpread({ text: _o({ fieldOrDatumDef: o, field: "datum.value", format: s, formatType: l, config: r }) }, n);if (void 0 === s && void 0 === l && r.customFormatTypes) {if ("quantitative" === ta(o)) {if (ua(o) && "normalize" === o.stack && r.normalizedNumberFormatType) return _objectSpread({ text: _o({ fieldOrDatumDef: o, field: "datum.value", format: r.normalizedNumberFormat, formatType: r.normalizedNumberFormatType, config: r }) }, n);if (r.numberFormatType) return _objectSpread({ text: _o({ fieldOrDatumDef: o, field: "datum.value", format: r.numberFormat, formatType: r.numberFormatType, config: r }) }, n);}if ("temporal" === ta(o) && r.timeFormatType && ea(o) && !o.timeUnit) return _objectSpread({ text: _o({ fieldOrDatumDef: o, field: "datum.value", format: r.timeFormat, formatType: r.timeFormatType, config: r }) }, n);}return n;}(t, e, o) : o;return void 0 === a || A(a) || (n[r] = { update: a }), n;}, {});return A(h) || i.set("encode", h, !!n.encoding || void 0 !== n.labelAngle), i;}function yp(e, t) {const { config: n } = e;return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", size: "include", orient: "ignore", theta: "ignore" })), lu("x", e, { defaultPos: "mid" })), lu("y", e, { defaultPos: "mid" })), ru("size", e)), ru("angle", e)), vp(e, n, t));}function vp(e, t, n) {return n ? { shape: { value: n } } : ru("shape", e);}const bp = { vgMark: "rule", encodeEntry: (e) => {const { markDef: t } = e,n = t.orient;return e.encoding.x || e.encoding.y || e.encoding.latitude || e.encoding.longitude ? _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", orient: "ignore", size: "ignore", theta: "ignore" })), mu("x", e, { defaultPos: "horizontal" === n ? "zeroOrMax" : "mid", defaultPos2: "zeroOrMin", range: "vertical" !== n })), mu("y", e, { defaultPos: "vertical" === n ? "zeroOrMax" : "mid", defaultPos2: "zeroOrMin", range: "horizontal" !== n })), ru("size", e, { vgChannel: "strokeWidth" })) : {};} };function xp(e, t, n) {if (void 0 === Un("align", e, n)) return "center";}function $p(e, t, n) {if (void 0 === Un("baseline", e, n)) return "middle";}const wp = { vgMark: "rect", encodeEntry: (e) => {const { config: t, markDef: n } = e,i = n.orient,r = "horizontal" === i ? "width" : "height",o = "horizontal" === i ? "height" : "width";return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", orient: "ignore", size: "ignore", theta: "ignore" })), lu("x", e, { defaultPos: "mid", vgChannel: "xc" })), lu("y", e, { defaultPos: "mid", vgChannel: "yc" })), ru("size", e, { defaultValue: kp(e), vgChannel: r })), {}, { [o]: Tn(Un("thickness", n, t)) });} };function kp(e) {var _Un4;const { config: n, markDef: i } = e,{ orient: r } = i,o = "horizontal" === r ? "width" : "height",a = e.getScaleComponent("horizontal" === r ? "x" : "y"),s = (_Un4 = Un("size", i, n, { vgChannel: o })) !== null && _Un4 !== void 0 ? _Un4 : n.tick.bandSize;if (void 0 !== s) return s;{const e = a ? a.get("range") : void 0;if (e && zn(e) && t.isNumber(e.step)) return 3 * e.step / 4;return 3 * Bs(n.view, o) / 4;}}const Sp = { arc: { vgMark: "arc", encodeEntry: (e) => _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", size: "ignore", orient: "ignore", theta: "ignore" })), lu("x", e, { defaultPos: "mid" })), lu("y", e, { defaultPos: "mid" })), hu(e, "radius")), hu(e, "theta")) }, area: { vgMark: "area", encodeEntry: (e) => _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", orient: "include", size: "ignore", theta: "ignore" })), mu("x", e, { defaultPos: "zeroOrMin", defaultPos2: "zeroOrMin", range: "horizontal" === e.markDef.orient })), mu("y", e, { defaultPos: "zeroOrMin", defaultPos2: "zeroOrMin", range: "vertical" === e.markDef.orient })), Su(e)) }, bar: { vgMark: "rect", encodeEntry: (e) => _objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", orient: "ignore", size: "ignore", theta: "ignore" })), hu(e, "x")), hu(e, "y")) }, circle: { vgMark: "symbol", encodeEntry: (e) => yp(e, "circle") }, geoshape: { vgMark: "shape", encodeEntry: (e) => _objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", size: "ignore", orient: "ignore", theta: "ignore" })), postEncodingTransform: (e) => {const { encoding: t } = e,n = t.shape;return [_objectSpread({ type: "geoshape", projection: e.projectionName() }, n && ea(n) && n.type === yr ? { field: pa(n, { expr: "datum" }) } : {})];} }, image: { vgMark: "image", encodeEntry: (e) => _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "ignore", orient: "ignore", size: "ignore", theta: "ignore" })), hu(e, "x")), hu(e, "y")), Jc(e, "url")) }, line: { vgMark: "line", encodeEntry: (e) => _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", size: "ignore", orient: "ignore", theta: "ignore" })), lu("x", e, { defaultPos: "mid" })), lu("y", e, { defaultPos: "mid" })), ru("size", e, { vgChannel: "strokeWidth" })), Su(e)) }, point: { vgMark: "symbol", encodeEntry: (e) => yp(e) }, rect: { vgMark: "rect", encodeEntry: (e) => _objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", orient: "ignore", size: "ignore", theta: "ignore" })), hu(e, "x")), hu(e, "y")) }, rule: bp, square: { vgMark: "symbol", encodeEntry: (e) => yp(e, "square") }, text: { vgMark: "text", encodeEntry: (e) => {const { config: t, encoding: n } = e;return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "include", baseline: "include", color: "include", size: "ignore", orient: "ignore", theta: "include" })), lu("x", e, { defaultPos: "mid" })), lu("y", e, { defaultPos: "mid" })), Jc(e)), ru("size", e, { vgChannel: "fontSize" })), ru("angle", e)), Du("align", xp(e.markDef, n, t))), Du("baseline", $p(e.markDef, n, t))), lu("radius", e, { defaultPos: null })), lu("theta", e, { defaultPos: null }));} }, tick: wp, trail: { vgMark: "trail", encodeEntry: (e) => _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, $u(e, { align: "ignore", baseline: "ignore", color: "include", size: "include", orient: "ignore", theta: "ignore" })), lu("x", e, { defaultPos: "mid" })), lu("y", e, { defaultPos: "mid" })), ru("size", e)), Su(e)) } };function Dp(e) {if (k([Xr, Vr, to], e.mark)) {const t = Ka(e.mark, e.encoding);if (t.length > 0) return function (e, t) {return [{ name: e.getName("pathgroup"), type: "group", from: { facet: { name: Fp + e.requestDataName(xc.Main), data: e.requestDataName(xc.Main), groupby: t } }, encode: { update: { width: { field: { group: "width" } }, height: { field: { group: "height" } } } }, marks: Op(e, { fromPrefix: Fp }) }];}(e, t);} else if (e.mark === Gr) {const t = Cn.some((t) => Un(t, e.markDef, e.config));if (e.stack && !e.fieldDef("size") && t) return function (e, _e$stack$groupbyChann) {const [t] = Op(e, { fromPrefix: zp }),n = e.scaleName(e.stack.fieldChannel),i = function i() {let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};return e.vgField(e.stack.fieldChannel, t);},r = (e, t) => "".concat(e, "(").concat([i({ prefix: "min", suffix: "start", expr: t }), i({ prefix: "max", suffix: "start", expr: t }), i({ prefix: "min", suffix: "end", expr: t }), i({ prefix: "max", suffix: "end", expr: t })].map((e) => "scale('".concat(n, "',").concat(e, ")")).join(","), ")");let o, a;"x" === e.stack.fieldChannel ? (o = _objectSpread(_objectSpread({}, b(t.encode.update, ["y", "yc", "y2", "height", ...Cn])), {}, { x: { signal: r("min", "datum") }, x2: { signal: r("max", "datum") }, clip: { value: !0 } }), a = { x: { field: { group: "x" }, mult: -1 }, height: { field: { group: "height" } } }, t.encode.update = _objectSpread(_objectSpread({}, x(t.encode.update, ["y", "yc", "y2"])), {}, { height: { field: { group: "height" } } })) : (o = _objectSpread(_objectSpread({}, b(t.encode.update, ["x", "xc", "x2", "width"])), {}, { y: { signal: r("min", "datum") }, y2: { signal: r("max", "datum") }, clip: { value: !0 } }), a = { y: { field: { group: "y" }, mult: -1 }, width: { field: { group: "width" } } }, t.encode.update = _objectSpread(_objectSpread({}, x(t.encode.update, ["x", "xc", "x2"])), {}, { width: { field: { group: "width" } } }));for (const n of Cn) {const i = Rn(n, e.markDef, e.config);t.encode.update[n] ? (o[n] = t.encode.update[n], delete t.encode.update[n]) : i && (o[n] = Tn(i)), i && (t.encode.update[n] = { value: 0 });}const s = [];if (((_e$stack$groupbyChann = e.stack.groupbyChannels) === null || _e$stack$groupbyChann === void 0 ? void 0 : _e$stack$groupbyChann.length) > 0) for (const t of e.stack.groupbyChannels) {const n = e.fieldDef(t),i = pa(n);i && s.push(i), ((n === null || n === void 0 ? void 0 : n.bin) || (n === null || n === void 0 ? void 0 : n.timeUnit)) && s.push(pa(n, { binSuffix: "end" }));}o = ["stroke", "strokeWidth", "strokeJoin", "strokeCap", "strokeDash", "strokeDashOffset", "strokeMiterLimit", "strokeOpacity"].reduce((n, i) => {if (t.encode.update[i]) return _objectSpread(_objectSpread({}, n), {}, { [i]: t.encode.update[i] });{const t = Rn(i, e.markDef, e.config);return void 0 !== t ? _objectSpread(_objectSpread({}, n), {}, { [i]: Tn(t) }) : n;}}, o), o.stroke && (o.strokeForeground = { value: !0 }, o.strokeOffset = { value: 0 });return [{ type: "group", from: { facet: { data: e.requestDataName(xc.Main), name: zp + e.requestDataName(xc.Main), groupby: s, aggregate: { fields: [i({ suffix: "start" }), i({ suffix: "start" }), i({ suffix: "end" }), i({ suffix: "end" })], ops: ["min", "max", "min", "max"] } } }, encode: { update: o }, marks: [{ type: "group", encode: { update: a }, marks: [t] }] }];}(e);}return Op(e);}const Fp = "faceted_path_";const zp = "stack_group_";function Op(e) {let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { fromPrefix: "" };const { mark: i, markDef: r, encoding: o, config: a } = e,s = X(r.clip, function (e) {const t = e.getScaleComponent("x"),n = e.getScaleComponent("y");return !(!(t !== null && t !== void 0 && t.get("selectionExtent")) && !(n !== null && n !== void 0 && n.get("selectionExtent"))) || void 0;}(e), function (e) {const t = e.component.projection;return !(!t || t.isFit) || void 0;}(e)),l = qn(r),c = o.key,u = function (e) {const { encoding: n, stack: i, mark: r, markDef: o, config: a } = e,s = n.order;if (!(!t.isArray(s) && la(s) && w(s.value) || !s && w(Un("order", o, a)))) {if ((t.isArray(s) || ea(s)) && !i) return In(s, { expr: "datum" });if (oo(r)) {const i = "horizontal" === o.orient ? "y" : "x",r = n[i];if (ea(r)) {var _e$stack2;const n = r.sort;return t.isArray(n) ? { field: pa(r, { prefix: i, suffix: "sort_index", expr: "datum" }) } : Uo(n) ? { field: pa({ aggregate: Ga(e.encoding) ? n.op : void 0, field: n.field }, { expr: "datum" }) } : qo(n) ? { field: pa(e.fieldDef(n.encoding), { expr: "datum" }), order: n.order } : null === n ? void 0 : { field: pa(r, { binSuffix: (_e$stack2 = e.stack) !== null && _e$stack2 !== void 0 && _e$stack2.impute ? "mid" : void 0, expr: "datum" }) };}}}}(e),f = function (e) {if (!e.component.selection) return null;const t = j(e.component.selection).length;let n = t,i = e.parent;for (; i && 0 === n;) n = j(i.component.selection).length, i = i.parent;return n ? { interactive: t > 0 || "geoshape" === e.mark || !!e.encoding.tooltip } : null;}(e),d = Un("aria", r, a),m = Sp[i].postEncodingTransform ? Sp[i].postEncodingTransform(e) : null;return [_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({ name: e.getName("marks"), type: Sp[i].vgMark }, s ? { clip: !0 } : {}), l ? { style: l } : {}), c ? { key: c.field } : {}), u ? { sort: u } : {}), f || {}), !1 === d ? { aria: d } : {}), {}, { from: { data: n.fromPrefix + e.requestDataName(xc.Main) }, encode: { update: Sp[i].encodeEntry(e) } }, m ? { transform: m } : {})];}class _p extends jm {constructor(e, n, i) {var _e$params;let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},o = arguments.length > 4 ? arguments[4] : void 0;super(e, "unit", n, i, o, void 0, Us(e) ? e.view : void 0), Yn(this, "markDef", void 0), Yn(this, "encoding", void 0), Yn(this, "specifiedScales", {}), Yn(this, "stack", void 0), Yn(this, "specifiedAxes", {}), Yn(this, "specifiedLegends", {}), Yn(this, "specifiedProjection", {}), Yn(this, "selection", []), Yn(this, "children", []);const a = lo(e.mark) ? _objectSpread({}, e.mark) : { type: e.mark },s = a.type;void 0 === a.filled && (a.filled = function (e, t, n) {let { graticule: i } = n;if (i) return !1;const r = Rn("filled", e, t),o = e.type;return X(r, o !== Jr && o !== Xr && o !== Kr);}(a, o, { graticule: e.data && bc(e.data) }));const l = this.encoding = function (e, n, i, r) {const o = {};for (const t of j(e)) st(t) || Ni("".concat(a = t, "-encoding is dropped as ").concat(a, " is not a valid encoding channel."));var a;for (let a of yt) {if (!e[a]) continue;const s = e[a];if (Rt(a)) {const e = ht(a),t = o[e];if (ea(t) && fr(t.type) && ea(s) && !t.timeUnit) {Ni(fi(e));continue;}}if ("angle" !== a || "arc" !== n || e.theta || (Ni("Arc marks uses theta channel rather than angle, replacing angle with theta."), a = he), Xa(e, a, n)) {if (a === Fe && "line" === n) {const t = ka(e[a]);if (t !== null && t !== void 0 && t.aggregate) {Ni("Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.");continue;}}if (a === we && (i ? "fill" in e : "stroke" in e)) Ni(mi("encoding", { fill: "fill" in e, stroke: "stroke" in e }));else if (a === Te || a === je && !t.isArray(s) && !la(s) || a === Me && t.isArray(s)) {if (s) {if (a === je) {const t = e[a];if (Jo(t)) {o[a] = t;continue;}}o[a] = t.array(s).reduce((e, t) => (ea(t) ? e.push(za(t, a)) : Ni(pi(t, a)), e), []);}} else {if (a === Me && null === s) o[a] = null;else if (!(ea(s) || na(s) || la(s) || Qo(s) || Fn(s))) {Ni(pi(s, a));continue;}o[a] = Da(s, a, r);}} else Ni(gi(a, n));}return o;}(e.encoding || {}, s, a.filled, o);this.markDef = dl(a, l, o), this.size = function (e) {let { encoding: t, size: n } = e;for (const e of Tt) {const i = mt(e);qs(n[i]) && ia(t[e]) && (delete n[i], Ni(ki(i)));}return n;}({ encoding: l, size: Us(e) ? _objectSpread(_objectSpread(_objectSpread({}, r), e.width ? { width: e.width } : {}), e.height ? { height: e.height } : {}) : r }), this.stack = fl(this.markDef, l), this.specifiedScales = this.initScales(s, l), this.specifiedAxes = this.initAxes(l), this.specifiedLegends = this.initLegends(l), this.specifiedProjection = e.projection, this.selection = ((_e$params = e.params) !== null && _e$params !== void 0 ? _e$params : []).filter((e) => As(e));}get hasProjection() {const { encoding: e } = this,t = this.mark === ro,n = e && Ve.some((t) => aa(e[t]));return t || n;}scaleDomain(e) {const t = this.specifiedScales[e];return t ? t.domain : void 0;}axis(e) {return this.specifiedAxes[e];}legend(e) {return this.specifiedLegends[e];}initScales(e, t) {return Zt.reduce((e, n) => {var _i$scale5;const i = Sa(t[n]);return i && (e[n] = this.initScale((_i$scale5 = i.scale) !== null && _i$scale5 !== void 0 ? _i$scale5 : {})), e;}, {});}initScale(e) {const { domain: n, range: i } = e,r = kn(e);return t.isArray(n) && (r.domain = n.map(An)), t.isArray(i) && (r.range = i.map(An)), r;}initAxes(e) {return Tt.reduce((t, n) => {const i = e[n];if (aa(i) || n === le && aa(e.x2) || n === ce && aa(e.y2)) {const e = aa(i) ? i.axis : void 0;t[n] = e ? this.initAxis(_objectSpread({}, e)) : e;}return t;}, {});}initAxis(e) {const t = j(e),n = {};for (const i of t) {const t = e[i];n[i] = Ta(t) ? Pn(t) : An(t);}return n;}initLegends(e) {return Qt.reduce((t, n) => {const i = Sa(e[n]);if (i && function (e) {switch (e) {case we:case ke:case Se:case Fe:case De:case Oe:case Ce:case Pe:return !0;case _e:case Ne:case ze:return !1;}}(n)) {const e = i.legend;t[n] = e ? kn(e) : e;}return t;}, {});}parseData() {this.component.data = ap(this);}parseLayoutSize() {!function (e) {const { size: t, component: n } = e;for (const i of Tt) {const r = mt(i);if (t[r]) {const e = t[r];n.layoutSize.set(r, qs(e) ? "step" : e, !0);} else {const t = np(e, r);n.layoutSize.set(r, t, !1);}}}(this);}parseSelections() {this.component.selection = function (e, n) {const i = {},r = e.config.selection;if (!n || !n.length) return i;for (const o of n) {const n = L(o.name),a = o.select,s = t.isString(a) ? a : a.type,l = t.isObject(a) ? y(a) : { type: s },c = r[s];for (const e in c) {var _c$e;"fields" !== e && "encodings" !== e && ("mark" === e && (l[e] = _objectSpread(_objectSpread({}, c[e]), l[e])), void 0 !== l[e] && !0 !== l[e] || (l[e] = y((_c$e = c[e]) !== null && _c$e !== void 0 ? _c$e : l[e])));}const u = i[n] = _objectSpread(_objectSpread({}, l), {}, { name: n, type: s, init: o.value, bind: o.bind, events: t.isString(l.on) ? t.parseSelector(l.on, "scope") : t.array(y(l.on)) }),f = y(o);for (const t of Hu) t.defined(u) && t.parse && t.parse(e, u, f);}return i;}(this, this.selection);}parseMarkGroup() {this.component.mark = Dp(this);}parseAxesAndHeaders() {var e;this.component.axes = (e = this, Tt.reduce((t, n) => (e.component.scales[n] && (t[n] = [hp(n, e)]), t), {}));}assembleSelectionTopLevelSignals(e) {return function (e, n) {let i = !1;for (const r of T((_e$component$selectio7 = e.component.selection) !== null && _e$component$selectio7 !== void 0 ? _e$component$selectio7 : {})) {var _e$component$selectio7;const o = r.name,a = t.stringValue(o + Ru);if (0 === n.filter((e) => e.name === o).length) {const e = "global" === r.resolve ? "union" : r.resolve,i = "point" === r.type ? ", true, true)" : ")";n.push({ name: r.name, update: "".concat(Iu, "(").concat(a, ", ").concat(t.stringValue(e)).concat(i) });}i = !0;for (const t of Hu) t.defined(r) && t.topLevelSignals && (n = t.topLevelSignals(e, r, n));}i && 0 === n.filter((e) => "unit" === e.name).length && n.unshift({ name: "unit", value: {}, on: [{ events: "pointermove", update: "isTuple(group()) ? group() : unit" }] });return Fc(n);}(this, e);}assembleSignals() {return [...of(this), ...kc(this, [])];}assembleSelectionData(e) {return function (e, t) {const n = [...t],i = Vu(e, { escape: !1 });for (const t of T((_e$component$selectio8 = e.component.selection) !== null && _e$component$selectio8 !== void 0 ? _e$component$selectio8 : {})) {var _e$component$selectio8;const e = { name: t.name + Ru };if (t.project.hasSelectionId && (e.transform = [{ type: "collect", sort: { field: _s } }]), t.init) {const n = t.project.items.map($c);e.values = t.project.hasSelectionId ? t.init.map((e) => ({ unit: i, [_s]: wc(e, !1)[0] })) : t.init.map((e) => ({ unit: i, fields: n, values: wc(e, !1) }));}n.filter((e) => e.name === t.name + Ru).length || n.push(e);}return n;}(this, e);}assembleLayout() {return null;}assembleLayoutSignals() {return Cf(this);}assembleMarks() {var _this$component$mark;let e = (_this$component$mark = this.component.mark) !== null && _this$component$mark !== void 0 ? _this$component$mark : [];return this.parent && Pm(this.parent) || (e = Dc(this, e)), e.map(this.correctDataNames);}assembleGroupStyle() {const { style: e } = this.view || {};return void 0 !== e ? e : this.encoding.x || this.encoding.y ? "cell" : "view";}getMapping() {return this.encoding;}get mark() {return this.markDef.type;}channelHasField(e) {return Ia(this.encoding, e);}fieldDef(e) {return ka(this.encoding[e]);}typedFieldDef(e) {const t = this.fieldDef(e);return sa(t) ? t : null;}}class Np extends Am {constructor(e, t, n, i, r) {super(e, "layer", t, n, r, e.resolve, e.view), Yn(this, "children", void 0);const o = _objectSpread(_objectSpread(_objectSpread({}, i), e.width ? { width: e.width } : {}), e.height ? { height: e.height } : {});this.children = e.layer.map((e, t) => {if (rl(e)) return new Np(e, this, this.getName("layer_".concat(t)), o, r);if (Wa(e)) return new _p(e, this, this.getName("layer_".concat(t)), o, r);throw new Error(Kn(e));});}parseData() {this.component.data = ap(this);for (const e of this.children) e.parseData();}parseLayoutSize() {var e;ep(e = this), tp(e, "width"), tp(e, "height");}parseSelections() {this.component.selection = {};for (const e of this.children) {e.parseSelections();for (const t of j(e.component.selection)) this.component.selection[t] = e.component.selection[t];}}parseMarkGroup() {for (const e of this.children) e.parseMarkGroup();}parseAxesAndHeaders() {!function (e) {const { axes: t, resolve: n } = e.component,i = { top: 0, bottom: 0, right: 0, left: 0 };for (const i of e.children) {i.parseAxesAndHeaders();for (const r of j(i.component.axes)) n.axis[r] = Lf(e.component.resolve, r), "shared" === n.axis[r] && (t[r] = dp(t[r], i.component.axes[r]), t[r] || (n.axis[r] = "independent", delete t[r]));}for (const r of Tt) {for (const o of e.children) if (o.component.axes[r]) {if ("independent" === n.axis[r]) {var _t$r;t[r] = ((_t$r = t[r]) !== null && _t$r !== void 0 ? _t$r : []).concat(o.component.axes[r]);for (const e of o.component.axes[r]) {const { value: t, explicit: n } = e.getWithExplicit("orient");if (!Fn(t)) {if (i[t] > 0 && !n) {const n = fp[t];i[t] > i[n] && e.set("orient", n, !1);}i[t]++;}}}delete o.component.axes[r];}if ("independent" === n.axis[r] && t[r] && t[r].length > 1) for (const [e, n] of (t[r] || []).entries()) e > 0 && n.get("grid") && !n.explicit.grid && (n.implicit.grid = !1);}}(this);}assembleSelectionTopLevelSignals(e) {return this.children.reduce((e, t) => t.assembleSelectionTopLevelSignals(e), e);}assembleSignals() {return this.children.reduce((e, t) => e.concat(t.assembleSignals()), of(this));}assembleLayoutSignals() {return this.children.reduce((e, t) => e.concat(t.assembleLayoutSignals()), Cf(this));}assembleSelectionData(e) {return this.children.reduce((e, t) => t.assembleSelectionData(e), e);}assembleGroupStyle() {const e = new Set();for (const n of this.children) for (const i of t.array(n.assembleGroupStyle())) e.add(i);const n = Array.from(e);return n.length > 1 ? n : 1 === n.length ? n[0] : void 0;}assembleTitle() {let e = super.assembleTitle();if (e) return e;for (const t of this.children) if (e = t.assembleTitle(), e) return e;}assembleLayout() {return null;}assembleMarks() {return function (e, t) {for (const n of e.children) _m(n) && (t = Dc(n, t));return t;}(this, this.children.flatMap((e) => e.assembleMarks()));}assembleLegends() {return this.children.reduce((e, t) => e.concat(t.assembleLegends()), td(this));}}function Cp(e, t, n, i, r) {if (Io(e)) return new rp(e, t, n, r);if (rl(e)) return new Np(e, t, n, i, r);if (Wa(e)) return new _p(e, t, n, i, r);if (function (e) {return Es(e) || Ms(e) || Ts(e);}(e)) return new sp(e, t, n, r);throw new Error(Kn(e));}const Pp = n;e.accessPathDepth = Y, e.accessPathWithDatum = W, e.compile = function (e) {let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};var i;n.logger && (i = n.logger, _i = i), n.fieldTitle && va(n.fieldTitle);try {const i = Ks(t.mergeConfig(n.config, e.config)),r = Zl(e, i),o = Cp(r, null, "", void 0, i);o.parse(), function (e, t) {Vd(e.sources);let n = 0,i = 0;for (let i = 0; i < Hd && Yd(e, t, !0); i++) n++;e.sources.map(Wd);for (let n = 0; n < Hd && Yd(e, t, !1); n++) i++;Vd(e.sources), Math.max(n, i) === Hd && Ni("Maximum optimization runs(".concat(Hd, ") reached."));}(o.component.data, o);const a = function (e, t) {let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},i = arguments.length > 3 ? arguments[3] : void 0;const r = e.config ? nl(e.config) : void 0,o = [].concat(e.assembleSelectionData([]), function (e, t) {const n = [],i = Xm(n);let r = 0;for (const t of e.sources) {t.hasName() || (t.dataName = "source_" + r++);const e = t.assemble();i(t, e);}for (const e of n) 0 === e.transform.length && delete e.transform;let o = 0;for (const [e, t] of n.entries()) {var _t$transform;0 !== ((_t$transform = t.transform) !== null && _t$transform !== void 0 ? _t$transform : []).length || t.source || n.splice(o++, 0, n.splice(e, 1)[0]);}for (const t of n) for (const n of (_t$transform2 = t.transform) !== null && _t$transform2 !== void 0 ? _t$transform2 : []) {var _t$transform2;"lookup" === n.type && (n.from = e.outputNodes[n.from].getSource());}for (const e of n) e.name in t && (e.values = t[e.name]);return n;}(e.component.data, n)),a = e.assembleProjections(),s = e.assembleTitle(),l = e.assembleGroupStyle(),c = e.assembleGroupEncodeEntry(!0);let u = e.assembleLayoutSignals();u = u.filter((e) => "width" !== e.name && "height" !== e.name || void 0 === e.value || (t[e.name] = +e.value, !1));const { params: f } = t,d = _objectWithoutProperties(t, _excluded63);return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({ $schema: "https://vega.github.io/schema/vega/v5.json" }, e.description ? { description: e.description } : {}), d), s ? { title: s } : {}), l ? { style: l } : {}), c ? { encode: { update: c } } : {}), {}, { data: o }, a.length > 0 ? { projections: a } : {}), e.assembleGroup([...u, ...e.assembleSelectionTopLevelSignals([]), ...js(f)])), r ? { config: r } : {}), i ? { usermeta: i } : {});}(o, function (e, n, i, r) {const o = r.component.layoutSize.get("width"),a = r.component.layoutSize.get("height");void 0 === n ? (n = { type: "pad" }, r.hasAxisOrientSignalRef() && (n.resize = !0)) : t.isString(n) && (n = { type: n });if (o && a && (s = n.type, "fit" === s || "fit-x" === s || "fit-y" === s)) if ("step" === o && "step" === a) Ni(ni()), n.type = "pad";else if ("step" === o || "step" === a) {const e = "step" === o ? "width" : "height";Ni(ni(qt(e)));const t = "width" === e ? "height" : "width";n.type = function (e) {return e ? "fit-".concat(qt(e)) : "fit";}(t);}var s;return _objectSpread(_objectSpread(_objectSpread({}, 1 === j(n).length && n.type ? "pad" === n.type ? {} : { autosize: n.type } : { autosize: n }), oc(i, !1)), oc(e, !0));}(e, r.autosize, i, o), e.datasets, e.usermeta);return { spec: a, normalized: r };} finally {n.logger && (_i = Oi), n.fieldTitle && va(ha);}}, e.contains = k, e.deepEqual = ie, e.deleteNestedProperty = U, e.duplicate = y, e.entries = E, e.every = D, e.fieldIntersection = P, e.flatAccessWithDatum = B, e.getFirstDefined = X, e.hasIntersection = N, e.hash = $, e.internalField = K, e.isBoolean = M, e.isEmpty = A, e.isEqual = function (e, t) {const n = j(e),i = j(t);if (n.length !== i.length) return !1;for (const i of n) if (e[i] !== t[i]) return !1;return !0;}, e.isInternalField = Z, e.isNullOrFalse = w, e.isNumeric = te, e.keys = j, e.logicalExpr = q, e.mergeDeep = F, e.never = v, e.normalize = Zl, e.normalizeAngle = ee, e.omit = x, e.pick = b, e.prefixGenerator = C, e.removePathFromField = G, e.replaceAll = V, e.replacePathInField = H, e.resetIdCounter = function () {J = 42;}, e.setEqual = _, e.some = S, e.stringify = re, e.titleCase = R, e.unique = O, e.uniqueId = Q, e.vals = T, e.varName = L, e.version = Pp;});